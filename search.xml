<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Eureka源码—EurekaClient]]></title>
    <url>%2F2018%2F03%2F21%2FEureka%E6%BA%90%E7%A0%81%E2%80%94EurekaClient%2F</url>
    <content type="text"><![CDATA[前言本篇文章主要解读Eureka-Client的相关源码，文章较长，请谨慎点击！ EurekaInstanceConfig EurekaInstanceConfig简介所属包：com.netflix.appinfo.EurekaInstanceConfig，Eureka 应用实例配置接口（Application Provider，Application Consumer）。 EurekaInstanceConfig源码博主已添加中文注释，点击查看。 EurekaInstanceConfig重要属性或者重要方法 getInstanceId()获取实例id，组成结构为${spring.application.name}:${spring.application.instance_id:${random.value}}默认为null。 geAppName()获取应用名，默认为”unknown”。 getLeaseRenewalIntervalInSeconds()获取租约续约频率，单位为秒。默认为30s。应用发送心跳给Eureka-Server进行续约（告诉Eureka-Server自己还活着）。 getLeaseExpirationDurationInSeconds() 获取租约过期时间，单位为秒。默认为90s。如果超过该时间，应用还没有向Eureka-Server发送心跳，那该租约就过期了，Eureka-Serever会进行应用移除。 getMetadataMap()获取实例的元数据。如果你想自定义一些数据，在各服务之间使用，就需要该方法。 getHealthCheckUrlPath(),getHealthCheckUrl(),getSecureHealthCheckUrl()健康检查相关的几个方法。 getNamespace()获取命名空间，已配置对应的eureka属性，默认为eureka。 ​ AbstractInstanceConfigAbstractInstanceConfig简介所属包：com.netflix.appinfo.AbstractInstanceConfig，Eureka 应用实例配置抽象基类，主要实现一些相对通用的配置 AbstractInstanceConfig源码博主已添加中文注释，点击查看。 AbstractInstanceConfig重要属性或者重要方法 主要设置一些基础的属性，以及对应的get/set方法 getHostInfo()获取本地服务器的主机名和主机IP地址 PropertiesInstanceConfigPropertiesInstanceConfig简介所属包：com.netflix.appinfo.PropertiesInstanceConfig，通过配置文件进行Eureka实例配置的抽象基类 PropertiesInstanceConfig源码博主已添加中文注释，点击查看。 PropertiesInstanceConfig重要属性或者重要方法 namespace命名空间。 configInstance配置文件，基于Netflix Archaius 1.x 实现读取配置文件。基于Netflix Archaius 2.x 的还在开发中。 appGrpNameFromEnv从环境变量中获取应用分组，ConfigurationManager.getConfigInstance获取当前的系统范围配置。 Archaius1Utils.initConfig(CommonConstants.CONFIG_FILE_NAME)，CommonConstants.CONFIG_FILE_NAME为eureka-client，Archaius1Utils.initConfig方法源码如下： 12345678910111213141516171819202122232425262728293031323334public final class Archaius1Utils &#123; private static final Logger logger = LoggerFactory.getLogger(Archaius1Utils.class); private static final String ARCHAIUS_DEPLOYMENT_ENVIRONMENT = "archaius.deployment.environment"; private static final String EUREKA_ENVIRONMENT = "eureka.environment"; public static DynamicPropertyFactory initConfig(String configName) &#123; // 配置文件对象 DynamicPropertyFactory configInstance = DynamicPropertyFactory.getInstance(); // 配置文件名，如果configName没有配置，即为CommonConstants.CONFIG_FILE_NAME（"eureka-client"） DynamicStringProperty EUREKA_PROPS_FILE = configInstance.getStringProperty("eureka.client.props", configName); // 配置文件环境 String env = ConfigurationManager.getConfigInstance().getString(EUREKA_ENVIRONMENT, "test"); // 将配置文件加载到环境变量 ConfigurationManager.getConfigInstance().setProperty(ARCHAIUS_DEPLOYMENT_ENVIRONMENT, env); String eurekaPropsFile = EUREKA_PROPS_FILE.get(); try &#123; //读取配置文件到环境变量，首先读取 $&#123;eureka.client.props&#125; 对应的配置文件；然后读取 $&#123;eureka.client.props&#125;-$&#123;eureka.environment&#125; 对应的配置文件。若有相同属性，进行覆盖。 ConfigurationManager.loadCascadedPropertiesFromResources(eurekaPropsFile); &#125; catch (IOException e) &#123; logger.warn( "Cannot find the properties specified : &#123;&#125;. This may be okay if there are other environment " + "specific properties or the configuration is installed with a different mechanism.", eurekaPropsFile); &#125; return configInstance; &#125;&#125; 其他实现方法基本类似，都是从配置文件中获取值，举一个例子： ​ isInstanceEnabledOnit()：从配置文件中获取是否在实例初始化的时候开启，并传一个默认值（这里是父类AbstractInstanceConfig中实现的方法），namespace的属性key都在PropertyBasedInstanceConfigConstants中 MyDataCenterInstanceConfigMyDataCenterInstanceConfig简介所属包：com.netflix.appinfo.MyDataCenterInstanceConfig，Eureka应用实例配置实现类 MyDataCenterInstanceConfig源码123456789101112131415161718public class MyDataCenterInstanceConfig extends PropertiesInstanceConfig implements EurekaInstanceConfig &#123; /** * 无参构造方法 */ public MyDataCenterInstanceConfig() &#123; &#125; public MyDataCenterInstanceConfig(String namespace) &#123; //调用父类含有namespace参数的构造函数进行初始化 super(namespace); &#125; public MyDataCenterInstanceConfig(String namespace, DataCenterInfo dataCenterInfo) &#123; //调用父类含有namespace和dataCenterInfo参数的构造函数进行初始化 super(namespace, dataCenterInfo); &#125;&#125; InstanceInfoInstanceInfo简介所属包：com.netflix.appinfo.InstanceInfo，应用实例信息。Eureka-Client 向 Eureka-Server 注册该对象信息。注册成功后，可以被其他 Eureka-Client 发现。Eureka通过com.netflix.appinfo.providers.EurekaConfigBasedInstanceInfoProvider基于EurekaInstanceConfig创建InstanceInfo。 EurekaConfigBasedInstanceInfoProvider源码博主已添加中文注释，点击查看。 EurekaConfigBasedInstanceInfoProvider重要属性或者重要方法 基本上每个属性和每个方法都添加了注释 其中vip地址解析器源码如下： 12345678910public interface VipAddressResolver &#123; /** * Convert &lt;code&gt;VIPAddress&lt;/code&gt; by substituting environment variables if necessary. * * @param vipAddressMacro the macro for which the interpolation needs to be made. * @return a string representing the final &lt;code&gt;VIPAddress&lt;/code&gt; after substitution. */ String resolveDeploymentContextBasedVipAddresses(String vipAddressMacro);&#125; 实现类源码（Archaius1实现，Archaius2还在开发中）： 1234567891011121314151617181920212223242526272829303132public class Archaius1VipAddressResolver implements VipAddressResolver &#123; private static final Logger logger = LoggerFactory.getLogger(Archaius1VipAddressResolver.class); private static final Pattern VIP_ATTRIBUTES_PATTERN = Pattern.compile("\\$\\&#123;(.*?)\\&#125;"); @Override public String resolveDeploymentContextBasedVipAddresses(String vipAddressMacro) &#123; if (vipAddressMacro == null) &#123; return null; &#125; String result = vipAddressMacro; //匹配$&#123;(.*?)&#125; Matcher matcher = VIP_ATTRIBUTES_PATTERN.matcher(result); while (matcher.find()) &#123; String key = matcher.group(1); String value = DynamicPropertyFactory.getInstance().getStringProperty(key, "").get(); logger.debug("att:&#123;&#125;", matcher.group()); logger.debug(", att key:&#123;&#125;", key); logger.debug(", att value:&#123;&#125;", value); logger.debug(""); //将$&#123;(.*?)&#125;替换为配置文件中对应的value result = result.replaceAll("\\$\\&#123;" + key + "\\&#125;", value); matcher = VIP_ATTRIBUTES_PATTERN.matcher(result); &#125; return result; &#125;&#125; ApplicationInfoManagerApplicationInfoManager简介所属包：com.netflix.appinfo.ApplicationInfoManager，应用信息管理类，由InstanceInfo和EurekaInstanceConfig生成。 ApplicationInfoManager源码博主已添加中文注释，点击查看。 EurekaClientConfigEurekaClientConfig简介所属包：com.netflix.discovery.EurekaClientConfig，Eureka-Client 配置接口，获取连接的 Eureka-Server 的地址、获取服务提供者列表的频率、注册自身为服务提供者的频率等等。 EurekaClientConfig源码博主已添加中文注释，点击查看。 EurekaClientConfig重要属性或者重要方法 getRegion()，getAvailabilityZones()：region和zone（或者Availability Zone）均是AWS的概念。在非AWS环境下，我们可以简单地将region理解为Eureka集群，zone理解成机房。Spring Cloud中默认的region是us-east-1 。具体可查看《周立 —— Region、Zone解析》。 getEurekaServerServiceUrls()：获取Eureka-Server的Url集合 从Eureka-Server获取注册信息的相关方法： getRegistryFetchIntervalSeconds()：获取注册信息的时间间隔，单位为秒。默认为30s getEurekaServiceUrlPollIntervalSeconds()：向Eureka-Server获取Eureka服务地址的变化时间间隔，单位为秒。默认为 5 60 1000 s getEurekaServerReadTimeoutSeconds()：获取Eureka-Server读取超时时间，单位为秒。默认为8s getBackupRegistryImpl()：获取备份注册中心实现类。默认为null shouldPreferSameZoneEureka()：相同Zone的Eureka是否优先。默认为true shouldDisableDelta()：是否使用增量形式获取注册信息。默认为false fetchRegistryForRemoteRegions()：获取远程区域的注册信息。默认为null shouldFilterOnlyUpInstances()：是否只获取Up（启动）状态的实例。默认为true shouldFetchRegistry()：是否从Eureka-Server获取注册信息。默认为true getRegistryRefreshSingleVipAddress()：获取单个vip地址（虚拟IP地址）的注册信息。默认为null getCacheRefreshExecutorThreadPoolSize()：获取注册信息缓存刷新的线程池大小。默认为5 getCacheRefreshExecutorExponentialBackOffBound()：获取注册信息缓存刷新执行超时后的延迟重试时间的最大倍数。默认为10 向Eureka-Server注册自身服务的相关方法： getInstanceInfoReplicationIntervalSeconds()：获取向Eureka-Server同步实例信息的时间间隔，单位为秒。默认为30s getInitialInstanceInfoReplicationIntervalSeconds()：获取最初向Eureka-Server同步实例信息的时间间隔，单位为秒。默认为40s getEurekaServerConnectTimeoutSeconds()：获取Eureka-Server连接超时时间，单位为秒。默认为5s shouldRegisterWithEureka()：是否向Eureka-Server注册自身服务。默认为true shouldUnregisterOnShutdown()：当Eureka-Server关闭的时候，是否注销自己的服务。默认为true getHeartbeatExecutorThreadPoolSize()：获取心跳检测执行的线程池大小。默认为5 getHeartbeatExecutorExponentialBackOffBound()：获取心跳检测执行超时后的延迟重试时间的最大倍数。默认为10 shouldEnforceRegistrationAtInit()：是否在实例初始化的时候进行注册。默认为false DefaultEurekaClientConfigDefaultEurekaClientConfig简介所属包：com.netflix.discovery.DefaultEurekaClientConfig，基于配置文件的Eureka-Client配置实现类。 DefaultEurekaClientConfig源码博主已添加中文注释，点击查看。 DefaultEurekaClientConfig重要属性或者重要方法 其中属性和构造方法基本上都加了中文注释。 其他实现方法基本类似，都是从配置文件中获取值，举一个例子： `getRegistryFetchIntervalSeconds()`：从配置文件中获取读取注册信息的时间间隔，并传一个默认值（这里是30），namespace后面的属性key都在PropertyBasedClientConfigConstants中。 DefaultEurekaClientConfigProviderDefaultEurekaClientConfigProvider简介所属包：com.netflix.discovery.providers.DefaultEurekaClientConfigProvider，创建 DefaultEurekaClientConfig 的工厂 。 DefaultEurekaClientConfigProvider源码1234567891011121314151617181920212223public class DefaultEurekaClientConfigProvider implements Provider&lt;EurekaClientConfig&gt; &#123; @Inject(optional = true) @EurekaNamespace private String namespace; private DefaultEurekaClientConfig config; @Override public synchronized EurekaClientConfig get() &#123; if (config == null) &#123; //根据命名空间是否为空来判断调用哪一个构造方法创建DefaultEurekaClientConfigProvider config = (namespace == null) ? new DefaultEurekaClientConfig() : new DefaultEurekaClientConfig(namespace); // TODO: Remove this when DiscoveryManager is finally no longer used DiscoveryManager.getInstance().setEurekaClientConfig(config); &#125; return config; &#125;&#125; 很简单的一个类，不做过多的分析。 EurekaTransportConfigEurekaTransportConfig简介所属包：com.netflix.discovery.shared.transport.EurekaTransportConfig，Eureka网络传输配置接口。 EurekaTransportConfig源码博主已添加中文注释，点击查看。 EurekaTransportConfig重要属性或者重要方法 getSessionedClientReconnectIntervalSeconds()：Eureka-Client 会话重新连接的时间间隔，单位为秒，默认为20*60s。 getRetryableClientQuarantineRefreshPercentage()：请求失败的Eureka-Client隔离集合占Eureka-Client总数的占比，超过该比例会进行清空，默认为0.66。 Endpoint相关： getAsyncResolverRefreshIntervalMs()：异步解析 EndPoint 集群频率，单位为毫秒。默认为5 60 1000ms。 getAsyncResolverWarmUpTimeoutMs()：异步解析器预热解析 EndPoint 集群超时时间，单位为毫秒。默认为5000s。 getAsyncExecutorThreadPoolSize()：异步线程池大小，默认为5。 DefaultEurekaTransportConfigDefaultEurekaTransportConfig简介所属包：com.netflix.discovery.shared.transport.DefaultEurekaTransportConfig，基于配置文件的网络传输配置实现类 。 DefaultEurekaTransportConfig源码博主已添加中文注释，点击查看。 DefaultEurekaTransportConfig重要属性或者重要方法 其他实现方法基本类似，都是从配置文件中获取值，举一个例子： getSessionedClientReconnectIntervalSeconds()：Eureka-Client 会话重新连接的时间间隔，并传一个默认值（这里是20*60），namespace的属性key都在PropertyBasedTransportConfigConstants中。 LookupServiceLookupService简介所属包：com.netflix.discovery.shared.LookupService，查找服务接口，可以获取应用集合和应用实例集合。 在 Eureka-Client 里，EurekaClient 继承该接口。 在 Eureka-Server 里，com.netflix.eureka.registry.InstanceRegistry 继承该接口。 LookupService源码 博主已添加中文注释，点击查看。 EurekaClientEurekaClient简介所属包：com.netflix.discovery.EurekaClient，Eureka-Client接口 。 EurekaClient源码博主已添加中文注释，点击查看。 EurkeaClient重要属性或者重要方法 获取应用集合： getApplicationsForARegion(@Nullable String region)：获取指定区域中的Applications。 getApplications(String serviceUrl)：获取指定的Eureka服务地址中注册的应用集合。 获取应用实例集合： getInstancesByVipAddress(String vipAddress, boolean secure)：获取指定VIP地址的实例列表。 getInstancesByVipAddress(String vipAddress, boolean secure, @Nullable String region)：获取指定VIP地址和区域的实例信息列表。 getInstancesByVipAddressAndAppName(String vipAddress, String appName, boolean secure)：获取指定VIP地址和appName的实例信息列表。 getAllKnownRegions()：获取所有已知的区域。 getInstanceRemoteStatus()：获取实例状态。 registerHealthCheck()：Eureka-Client注册健康检查。 getHealthCheckHandler()：获取健康监测处理器。 registerEventListener()：Eureka-Client注册事件监听。 unregisterEventListener()：Eureka-Client取消事件监听注册。 getEurekaClientConfig()：获取Eureka-Client配置。 getApplicationInfoManager()：获取应用信息管理器。 DiscoveryClient DiscoveryClient简介所属包：com.netflix.discovery.DiscoveryClient，EurekaClient接口的实现类，用于与 Eureka-Server 交互。包含方法： 向 Eureka-Server 注册自身服务 向 Eureka-Server 续约自身服务 向 Eureka-Server 取消自身服务，当关闭时 从 Eureka-Server 查询应用集合和应用实例信息 本文主要介绍DiscoveryClient的初始化，其他方法后续文章会有介绍 DiscoveryClient源码博主已添加中文注释，点击查看。 DiscoveryClient重要属性或者重要方法构造函数： 12345@InjectDiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args, Provider&lt;BackupRegistry&gt; backupRegistryProvider) &#123; //省略具体代码&#125; 参数： ApplicationInfoManager：应用信息管理类，具体可查看ApplicationInfoManager小结。 EurekaClientConfig：Eureka-Client 配置接口，获取连接的 Eureka-Server 的地址、获取服务提供者列表的频率、注册自身为服务提供者的频率等等，具体可查看EurekaClientConfig小结。 AbstractDiscoveryClientOptionalArgs：DiscoveryClient 可选参数抽象基类。该参数是选填参数，实际生产中很少使用，源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public abstract class AbstractDiscoveryClientOptionalArgs&lt;T&gt; &#123; /** * 健康检查回调的工厂 */ Provider&lt;HealthCheckCallback&gt; healthCheckCallbackProvider; /** * 健康检查处理器的工厂 */ Provider&lt;HealthCheckHandler&gt; healthCheckHandlerProvider; /** * 向Eureka-Server注册之前的处理器 */ PreRegistrationHandler preRegistrationHandler; /** * Jersey 过滤器集合 */ Collection&lt;T&gt; additionalFilters; /** * Jersey 客户端 */ EurekaJerseyClient eurekaJerseyClient; /** * 生成 Jersey 客户端工厂 */ TransportClientFactory transportClientFactory; /** * 生成 Jersey 客户端工厂 */ TransportClientFactories transportClientFactories; /** * Eureka 事件监听集合 */ private Set&lt;EurekaEventListener&gt; eventListeners; /** * ssl */ private Optional&lt;SSLContext&gt; sslContext = Optional.empty(); /** * 主机认证 */ private Optional&lt;HostnameVerifier&gt; hostnameVerifier = Optional.empty(); //省略set方法&#125; Provider&lt;BackupRegistry&gt;：备份注册中心接口，当 Eureka-Client 启动时，无法从 Eureka-Server 读取注册信息，就从备份注册中心读取注册信息 ，源码如下： 1234567@ImplementedBy(NotImplementedRegistryImpl.class)public interface BackupRegistry &#123; Applications fetchRegistry(); Applications fetchRegistry(String[] includeRemoteRegions);&#125; 实现类源码如下（可以看出暂未提供合适的实现）： 123456789101112131415161718192021222324@Singletonpublic class NotImplementedRegistryImpl implements BackupRegistry &#123; /** * 获取应用注册信息 * * @return 应用列表对象 （默认为null） */ @Override public Applications fetchRegistry() &#123; return null; &#125; /** * 获取应用注册信息 * * @param includeRemoteRegions 远程区域列表 * @return 应用列表对象（默认为null） */ @Override public Applications fetchRegistry(String[] includeRemoteRegions) &#123; return null; &#125;&#125; 具体逻辑可查看源码，博主已添加中文注释 总结我们可以看到 EurekaClient 的创建，先是通过 EurekaInstanceConfig 生成 InstanceInfo，再通过 EurekaInstanceConfig 和 InstanceInfo 生成 ApplicationInfoManager，最后 EurekaClientConfig 和 ApplicationInfoManager 生成 EurekaClient。 欢迎关注博主其他的文章。]]></content>
      <categories>
        <category>SpringCloud</category>
        <category>Eureka</category>
      </categories>
      <tags>
        <tag>Eureka</tag>
        <tag>SpringCloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eureka源码系列简介]]></title>
    <url>%2F2018%2F03%2F18%2FEureka%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[前言最近关于微服务的话题很火热，本系列文章主要是从源码去解读Eureka。 PS： 什么是微服务，本文不做具体介绍，可以自行上网查找。 如果没有使用过SpringCloud，博主建议先自行搭建一套服务之后，再进行源码的解读。 该系列文章很枯燥也很耗时，请合理安排时间。 博主是参考了芋艿大佬的路线进行源码解读的，其中有部分问题借鉴了芋艿大佬的解读。点击访问芋艿大佬的博客 Eureka项目结构简介 eureka-client com.netflix.appinfo : Eureka-Client 的应用配置 com.netflix.discovery : Eureka-Client 的注册和发现功能 eureka-client-archaius2Archaius是 Netflix 开源的配置管理组件。Eureka 使用 1.x 版本，2.x 版本仍然在开发中，2.x只兼容jdk1.8以上的版本。 eureka-client-jersey2Jersey 框架实现Eureka的 RESTful HTTP接口。Eureka 使用 1.x 版本，2.x 版本由社区实现。 eureka-core com.netflix.eureka.aws : 与AWS (Amazon Web Services) 相关，该系列文章暂不涉及AWS的分析 com.netflix.eureka.cluster : 与peer节点复制(replication)相关 com.netflix.eureka.lease : 租约，用来控制注册信息的生命周期(注册、续约、剔除) com.netflix.eureka.registry : 存储、查询服务注册信息 com.netflix.eureka.resources : RESTful中的”R”，即资源。相当于SpringMVC中的Controller com.netflix.eureka.transport : 发送HTTP请求的客户端，如发送心跳 com.netflix.eureka.util : 相关工具包 eureka-core-jersey2Jersey 框架实现Eureka的 RESTful HTTP接口。Eureka 使用 1.x 版本，2.x 版本由社区实现。 eureka-examplesEureka-Client 使用例子。 eureka-resources通过 JSP 实现 Eureka-Server 的运维后台界面。 eureka-server由 eureka-client + eureka-core + eureka-resources 打包成 Eureka-Server 的war包。 eureka-server-governator使用 Netflix Governator （Google Guice的扩展类库，提供了Classpath扫描及自动绑定、生命周期管理、成员属性验证等功能）管理 Eureka-Server 的生命周期。目前该模块正在测试阶段。 eureka-test-utilsEureka 单元测试工具类。]]></content>
      <categories>
        <category>SpringCloud</category>
        <category>Eureka</category>
      </categories>
      <tags>
        <tag>Eureka</tag>
        <tag>SpringCloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JPA使用Java8的LocalDateTime]]></title>
    <url>%2F2017%2F12%2F02%2FJPA%E4%BD%BF%E7%94%A8Java8%E7%9A%84LocalDateTime%2F</url>
    <content type="text"><![CDATA[前言这篇文章主要介绍JPA如何正确使用LocalDateTime与数据库datetime属性进行映射。 对应的JPA版本是2.1以下的，由于JPA2.1发布时间早于Java8，所以不能直接支持Java8的新特新。Oracle最新发布的JPA2.2版本是支持新的时间API以及查询结果流等。 MyBatis请查看MyBatis使用Java8的LocalDateTime。 解决方法spring-boot-starter-data-jpa的版本为1.5.9.RELEASE，对应的hibernate-core版本为5.0.12.Final 将数据保存到数据库 添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-java8&lt;/artifactId&gt; &lt;version&gt;5.0.12.Final&lt;/version&gt;&lt;/dependency&gt; 添加注解，在获取LocalDateTime时，指定时间格式 12345678910public class User &#123; @Id @Column(name = "id", nullable = false, length = 20) private Long id; @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", locale = "zh", timezone = "GMT+8") @Column(name = "gmt_create") private LocalDateTime gmtCreate; //省略get，set方法&#125; 总结博主一开始遇到了一个坑，我用的hibernate-java8版本为5.2.8.Final，结果报错了。后来发现这个版本的hibernate-core是5.2.8.Final。后来改成对应的5.0.12.Final就正确了。 欢迎关注博主其他的文章。]]></content>
      <categories>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>Java8</tag>
        <tag>JPA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis使用Java8的LocalDateTime]]></title>
    <url>%2F2017%2F12%2F01%2FMyBatis%E4%BD%BF%E7%94%A8Java8%E7%9A%84LocalDateTime%2F</url>
    <content type="text"><![CDATA[前言众所周知，Java8之前的时间API有很多问题，比如：非线程安全，设计很差。时区处理麻烦。新的时间API（java.time包）解决了这些问题，所以我们在平时开发尽可能的使用新的时间API。但是MyBatis使用LocalDataTime映射到数据库的datetime属性时，会报错。 解决方法mybatis-spring-boot-starter的版本为1.3.1，对应的MyBatis版本为3.4.5（版本低于3.4.0还需要特殊配置） 将数据保存到数据库 添加依赖 12345678910111213&lt;!-- LocalDateTime映射到数据库需要的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-typehandlers-jsr310&lt;/artifactId&gt; &lt;version&gt;1.0.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 格式化LocalDateTime需要的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt; &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt; 添加注解，设置时间格式 1234567public class User &#123; private Integer id; @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", locale = "zh", timezone = "GMT+8") private LocalDateTime gmtCreate; //省略get，set方法&#125; 总结关于MyBatis使用LocalDateTime的内容就是上面这些了，如果使用的ORM框架式JPA，请点击JPA使用Java8的LocalDateTime。 欢迎关注博主其他的文章。]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>Java8</tag>
      </tags>
  </entry>
</search>
