<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Eureka]]></title>
    <url>%2F2018%2F04%2F14%2FEureka-Client%2F</url>
    <content type="text"></content>
      <categories>
        <category>Spring</category>
        <category>SpringCloud</category>
        <category>Eureka</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringCloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F04%2F13%2Feureka%2F</url>
    <content type="text"><![CDATA[tip: region和zone（或者Availability Zone）均是AWS的概念。在非AWS环境下，我们可以简单地将region理解为Eureka集群，zone理解成机房。Spring Cloud中默认的region是us-east-1 。 我们在将一个普通的Spring Boot应用注册到Eureka Server中，或是从Eureka Server中获取服务列表时，主要就做了两件事： 在应用主类中配置了@EnableDiscoveryClient注解 在application.properties中用eureka.client.serviceUrl.defaultZone参数指定了服务注册中心的位置 @EnableDiscoveryClient我们先查看@EnableDiscoveryClient的源码如下： 12345678@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Import(&#123;EnableDiscoveryClientImportSelector.class&#125;)public @interface EnableDiscoveryClient &#123; boolean autoRegister() default true;&#125; DiscoveryClient 在具体研究Eureka Client具体负责的任务之前，我们先看看对Eureka Server的URL列表配置在哪里。 EndpointUtils-&gt;getServiceUrlsMapFromConfig 1234567891011121314151617181920212223242526272829303132333435363738public static Map&lt;String, List&lt;String&gt;&gt; getServiceUrlsMapFromConfig(EurekaClientConfig clientConfig, String instanceZone, boolean preferSameZone) &#123; Map&lt;String, List&lt;String&gt;&gt; orderedUrls = new LinkedHashMap(); String region = getRegion(clientConfig);//获取region String[] availZones = clientConfig.getAvailabilityZones(clientConfig.getRegion());//获取region中的所有zone if (availZones == null || availZones.length == 0) &#123; availZones = new String[]&#123;"default"&#125;; &#125; logger.debug("The availability zone for the given region &#123;&#125; are &#123;&#125;", region, Arrays.toString(availZones)); int myZoneOffset = getZoneOffset(instanceZone, preferSameZone, availZones);//获取实例zone的位置 String zone = availZones[myZoneOffset];//获取zone List&lt;String&gt; serviceUrls = clientConfig.getEurekaServerServiceUrls(zone);//获取zone中的所有serviceUrl if (serviceUrls != null) &#123; orderedUrls.put(zone, serviceUrls); &#125; int currentOffset = myZoneOffset == availZones.length - 1 ? 0 : myZoneOffset + 1; while(currentOffset != myZoneOffset) &#123;//循环遍历所有zone，获取serviceUrls zone = availZones[currentOffset]; serviceUrls = clientConfig.getEurekaServerServiceUrls(zone); if (serviceUrls != null) &#123; orderedUrls.put(zone, serviceUrls); &#125; if (currentOffset == availZones.length - 1) &#123; currentOffset = 0; &#125; else &#123; ++currentOffset; &#125; &#125; if (orderedUrls.size() &lt; 1) &#123; throw new IllegalArgumentException("DiscoveryClient: invalid serviceUrl specified!"); &#125; else &#123; return orderedUrls; &#125;&#125; Region,Zone 在上面函数中，我们发现客户端依次加载了两个内容，一个是Region，一个是Zone，从其加载逻辑上我们可以看出他们的关系： 通过getRegion函数，我们可以看到它从配置中读取了一个Region返回，所以一个微服务应用只可以属于一个Region，如果不特别配置，就默认为us-east-1。若我们要自己设置，可以通过eureka.client.region属性来定义 123456789public static String getRegion(EurekaClientConfig clientConfig) &#123; String region = clientConfig.getRegion(); if (region == null) &#123; region = "default"; &#125; region = region.trim().toLowerCase(); return region;&#125; 通过EurekaClientConfigBean的getAvailabilityZones方法来获取Zone，EurekaClientConfigBean类是EurekaClientConfig和EurekaConstants接口的实现，用来加载配置文件中的内容，这里有非常多有用的信息 12345678public String[] getAvailabilityZones(String region) &#123; String value = (String)this.availabilityZones.get(region); if (value == null) &#123; value = "defaultZone"; &#125; return value.split(",");&#125; serviceUrls 在获取了Region和Zone信息之后，才开始真正加载Eureka Server的具体地址。它根据传入的参数按一定算法确定加载位于哪一个Zone配置的serviceUrls。 123int myZoneOffset = getZoneOffset(instanceZone, preferSameZone, availZones);String zone = availZones[myZoneOffset];List&lt;String&gt; serviceUrls = clientConfig.getEurekaServerServiceUrls(zone); EurekaClientConfigBean的getEurekaServerServiceUrls方法 1234567891011121314151617181920212223242526public List&lt;String&gt; getEurekaServerServiceUrls(String myZone) &#123; String serviceUrls = (String)this.serviceUrl.get(myZone);//获取zone中的serviceUrls if (serviceUrls == null || serviceUrls.isEmpty()) &#123;//为空的话，获取defaultZone中的serviceUrls serviceUrls = (String)this.serviceUrl.get("defaultZone"); &#125; if (!StringUtils.isEmpty(serviceUrls)) &#123; String[] serviceUrlsSplit = StringUtils.commaDelimitedListToStringArray(serviceUrls);//将serviceUrls用,分割 List&lt;String&gt; eurekaServiceUrls = new ArrayList(serviceUrlsSplit.length); String[] var5 = serviceUrlsSplit; int var6 = serviceUrlsSplit.length; for(int var7 = 0; var7 &lt; var6; ++var7) &#123; String eurekaServiceUrl = var5[var7]; if (!this.endsWithSlash(eurekaServiceUrl)) &#123;//如果url结尾不是/，就添加/ eurekaServiceUrl = eurekaServiceUrl + "/"; &#125; eurekaServiceUrls.add(eurekaServiceUrl); &#125; return eurekaServiceUrls; &#125; else &#123; return new ArrayList(); &#125;&#125; 当客户端在服务列表中选择实例进行访问时，对于Zone和Region遵循这样的规则：优先访问同自己一个Zone中的实例，其次才访问其他Zone中的实例。通过Region和Zone的两层级别定义，配合实际部署的物理结构，我们就可以有效的设计出区域性故障的容错集群。 服务注册在理解了多个服务注册中心信息的加载后，我们再回头看看DiscoveryClient类是如何实现“服务注册”行为的，其中DiscoveryClient实现了EurekaClient接口，并且它是一个单例模式，而EurekaClient继承了LookupService接口。通过查看它的构造类，可以找到它调用了下面这个函数： 12345678910111213141516171819202122232425262728293031323334353637383940private void initScheduledTasks() &#123; int renewalIntervalInSecs; int expBackOffBound; if (this.clientConfig.shouldFetchRegistry()) &#123;//默认为true renewalIntervalInSecs = this.clientConfig.getRegistryFetchIntervalSeconds();//服务发现时间间隔默认为30 expBackOffBound = this.clientConfig.getCacheRefreshExecutorExponentialBackOffBound();//默认为10 this.scheduler.schedule(new TimedSupervisorTask("cacheRefresh", this.scheduler, this.cacheRefreshExecutor, renewalIntervalInSecs, TimeUnit.SECONDS, expBackOffBound, new DiscoveryClient.CacheRefreshThread()), (long)renewalIntervalInSecs, TimeUnit.SECONDS); &#125; if (this.clientConfig.shouldRegisterWithEureka()) &#123;//默认为true renewalIntervalInSecs = this.instanceInfo.getLeaseInfo().getRenewalIntervalInSecs();//默认为30 expBackOffBound = this.clientConfig.getHeartbeatExecutorExponentialBackOffBound();//默认为10 logger.info("Starting heartbeat executor: renew interval is: " + renewalIntervalInSecs); this.scheduler.schedule(new TimedSupervisorTask("heartbeat", this.scheduler, this.heartbeatExecutor, renewalIntervalInSecs, TimeUnit.SECONDS, expBackOffBound, new DiscoveryClient.HeartbeatThread(null)), (long)renewalIntervalInSecs, TimeUnit.SECONDS); this.instanceInfoReplicator = new InstanceInfoReplicator(this, this.instanceInfo, this.clientConfig.getInstanceInfoReplicationIntervalSeconds(), 2); this.statusChangeListener = new StatusChangeListener() &#123; public String getId() &#123; return "statusChangeListener"; &#125; public void notify(StatusChangeEvent statusChangeEvent) &#123; if (InstanceStatus.DOWN != statusChangeEvent.getStatus() &amp;&amp; InstanceStatus.DOWN != statusChangeEvent.getPreviousStatus()) &#123; DiscoveryClient.logger.info("Saw local status change event &#123;&#125;", statusChangeEvent); &#125; else &#123; DiscoveryClient.logger.warn("Saw local status change event &#123;&#125;", statusChangeEvent); &#125; DiscoveryClient.this.instanceInfoReplicator.onDemandUpdate(); &#125; &#125;; if (this.clientConfig.shouldOnDemandUpdateStatusChange()) &#123; this.applicationInfoManager.registerStatusChangeListener(this.statusChangeListener); &#125; this.instanceInfoReplicator.start(this.clientConfig.getInitialInstanceInfoReplicationIntervalSeconds()); &#125; else &#123; logger.info("Not registering with Eureka server per configuration"); &#125;&#125; 在上面的函数中，我们可以看到关键的判断依据if (this.clientConfig.shouldRegisterWithEureka())。在该分支内，创建了一个InstanceInfoReplicator类的实例，它会执行一个定时任务，查看该类的run()函数了解该任务做了什么工作： 1234567891011121314151617181920212223242526272829303132333435public void run() &#123; boolean var6 = false; ScheduledFuture next; label53: &#123; try &#123; var6 = true; this.discoveryClient.refreshInstanceInfo(); Long dirtyTimestamp = this.instanceInfo.isDirtyWithTime(); if (dirtyTimestamp != null) &#123; this.discoveryClient.register(); this.instanceInfo.unsetIsDirty(dirtyTimestamp); var6 = false; &#125; else &#123; var6 = false; &#125; break label53; &#125; catch (Throwable var7) &#123; logger.warn("There was a problem with the instance info replicator", var7); var6 = false; &#125; finally &#123; if (var6) &#123; ScheduledFuture next = this.scheduler.schedule(this, (long)this.replicationIntervalSeconds, TimeUnit.SECONDS); this.scheduledPeriodicRef.set(next); &#125; &#125; next = this.scheduler.schedule(this, (long)this.replicationIntervalSeconds, TimeUnit.SECONDS); this.scheduledPeriodicRef.set(next); return; &#125; next = this.scheduler.schedule(this, (long)this.replicationIntervalSeconds, TimeUnit.SECONDS); this.scheduledPeriodicRef.set(next);&#125; 相信大家都发现了discoveryClient.register();这一行，真正触发调用注册的地方就在这里。继续查看register()的实现内容如下： 1234567891011121314151617boolean register() throws Throwable &#123; logger.info("DiscoveryClient_" + this.appPathIdentifier + ": registering service..."); EurekaHttpResponse httpResponse; try &#123; httpResponse = this.eurekaTransport.registrationClient.register(this.instanceInfo); &#125; catch (Exception var3) &#123; logger.warn("&#123;&#125; - registration failed &#123;&#125;", new Object[]&#123;"DiscoveryClient_" + this.appPathIdentifier, var3.getMessage(), var3&#125;); throw var3; &#125; if (logger.isInfoEnabled()) &#123; logger.info("&#123;&#125; - registration status: &#123;&#125;", "DiscoveryClient_" + this.appPathIdentifier, httpResponse.getStatusCode()); &#125; return httpResponse.getStatusCode() == 204;&#125; 通过属性命名，大家基本也能猜出来，注册操作也是通过REST请求的方式进行的。同时，这里我们也能看到发起注册请求的时候，传入了一个com.netflix.appinfo.InstanceInfo对象，该对象就是注册时候客户端给服务端的服务的元数据。 ApplicationResource-&gt;PeerAwareInstanceRegistryImpl]]></content>
  </entry>
</search>
