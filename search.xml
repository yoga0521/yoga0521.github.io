<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[漏桶算法与令牌桶算法简介]]></title>
    <url>%2F2018%2F03%2F26%2F%E6%BC%8F%E6%A1%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[前言我们项目中的API接口都是有访问上限的，当访问频率或者并发量超过其承受范围时，我们就必须考虑限流来保证接口的可用性。防止非预期的请求对系统压力过大而引起的系统瘫痪。本篇文章会介绍限流算法中比较常见的漏桶算法和令牌桶算法。 漏桶算法]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>限流算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eureka源码—EurekaServer]]></title>
    <url>%2F2018%2F03%2F23%2FEureka%E6%BA%90%E7%A0%81%E2%80%94EurekaServer%2F</url>
    <content type="text"><![CDATA[前言本篇文章主要解读Eureka-Server初始化的相关源码，文章较长，请谨慎点击！ EurekaServerConfigEurekaServerConfig简介所属包：com.netflix.eureka.EurekaSeverConfig，Eureka-Server配置接口。 EurekaServerConfig源码博主已添加中文注释，点击查看。 EurekaServerConfig重要属性或者重要方法 自我保护相关： shouldEnableSelfPreservation()：是否开启自我保护机制，默认为true。 getRenewalPercentThreshold()：自我保护百分比阈值，超过这个值就会开启自我保护模式。默认为0.85。 getRenewalThresholdUpdateIntervalMs（）:自我保护阈值更新的时间间隔，单位为毫秒（ms）。默认为 15 * 60 * 1000 ms。 注册信息相关： getWaitTimeInMsWhenSyncEmpty()：如果eureka在启动的时候，获取不到注册信息，就等待。单位为毫秒（ms）。默认为 1000 * 60 * 5 ms。 getPeerNodeConnectTimeoutMs()：eureka集群节点之间请求连接超时的时间（进行复制信息操作），单位为毫秒（ms）。默认为 1000 ms。 getPeerNodeReadTimeoutMs()：eureka集群节点之间请求读取超时的时间（进行复制信息操作），单位为毫秒（ms），默认为 5000 ms。 getRetentionTimeInMSInDeltaQueue()：获取增量信息缓存的时间，以避免客户端检索的时候丢失，单位为毫秒。默认为 30 * 60 * 1000 ms。 getDeltaRetentionTimerIntervalInMs()：获取清理过期的增量信息任务应唤醒的时间间隔，单位为毫秒。默认为 30 * 1000 ms。 shouldDisableDelta()：是否可以将增量信息提供给客户端，默认为false。 shouldSyncWhenTimestampDiffers()：否同步应用实例信息，当应用实例信息最后更新时间戳( lastDirtyTimestamp )发生改变。默认为true。 getRegistrySyncRetries()：获取eureka服务器启动时，从远程 Eureka-Server 读取失败重试次数。默认为5。 getRegistrySyncRetryWaitMs()：Eureka-Server 启动时，从远程 Eureka-Server 读取注册信息失败，再次尝试获取的等待( sleep )间隔，单位为毫秒，默认为30 * 1000 ms。 shouldDisableDeltaForRemoteRegions()：是否将增量信息提供给客户端或远程区域，默认为false。 getRemoteRegionConnectTimeoutMs()：获取连接到远程Eureka-Server的超时时间，单位为毫秒，默认为2000ms。 getRemoteRegionReadTimeoutMs()：获取读取远程Eureka-Server的超时时间，单位为毫秒，默认为5000ms。 getRemoteRegionUrlsWithName()：获取远程Eureka-Server的地址，key为Eureka-server名，value为Eureka-Server地址。 getRemoteRegionAppWhitelist(@Nullable String regionName)：获取远程Eureka-Server获取注册的Applications集合。 getRemoteRegionRegistryFetchInterval()：获取从远程Eureka-Server获取注册信息的时间间隔，单位为秒，默认为30s。 限流相关： isRateLimiterEnabled()：是否开启请求限流，默认为false。 isRateLimiterThrottleStandardClients()：是否限制非标准客户端的访问，默认为false。标准客户端通过请求头的 DiscoveryIdentity-Name 来判断，是否在标准客户端名集合里。 getRateLimiterPrivilegedClients()：获取标准客户端名集合。标准客户端名集合。默认包含DefaultClient 和 DefaultServer 。 getRateLimiterBurstSize()：速率限制的burst size，默认为10。令牌桶算法。 getRateLimiterRegistryFetchAverageRate()：指定增量获取注册信息的平均执行注册请求速率，默认为500。 getRateLimiterFullFetchAverageRate()：指定全量获取注册信息的平均执行注册请求速率，默认为100。 getEvictionIntervalTimerInMs()：租约过期定时任务执行频率，单位为毫秒。默认为 60 * 1000 ms。 DefaultEurekaServerConfigDefaultEurekaServerConfig所属包：com.netflic.eureka.DefaultEurekaServerConfig，基于配置文件的Eureka-Server配置实现类。 DefaultEurekaServerConfig源码博主已添加中文注释，点击查看。 DefaultEurekaServerConfig重要属性或者重要方法 其他实现方法基本类似，都是从配置文件中获取值，举一个例子： shouldEnableSelfPreservation()：是否开启自我保护模式，并传一个默认值（这里是true）。 EurekaBootStrap EurekaBootStrap简介所属包：com.netflix.eureka.EurekaBootStrap，Eureka-Server启动入口。EurekaBootStrap 实现了 javax.servlet.ServletContextListener 接口，在 Servlet 容器( 例如 Tomcat、Jetty )启动时，调用 contextInitialized() 方法，初始化 Eureka-Server 。源码如下： 12345678910111213141516171819public class EurekaBootStrap implements ServletContextListener &#123; // 省略部分代码 @Override public void contextInitialized(ServletContextEvent event) &#123; try &#123; // 初始化Eureka配置环境 initEurekaEnvironment(); // 初始化Eureka-Server上下文 initEurekaServerContext(); ServletContext sc = event.getServletContext(); sc.setAttribute(EurekaServerContext.class.getName(), serverContext); &#125; catch (Throwable e) &#123; logger.error("Cannot bootstrap eureka server :", e); throw new RuntimeException("Cannot bootstrap eureka server :", e); &#125; &#125; // 省略部分代码&#125; EurekaBootStrap源码博主已添加中文注释，点击查看。 EurekaBootStrap重要属性或者重要方法 Eureka-Server上下文相关： com.netflix.eureka.EurekaServerContext：Eureka-Server上下文接口，包含了初始化，关闭，获取EurekaServer配置对象，获取集群节点集合，获取编解码器，获取应用实例注册表，获取应用信息管理器这些方法。源码如下： 1234567891011121314151617public interface EurekaServerContext &#123; void initialize() throws Exception; void shutdown() throws Exception; EurekaServerConfig getServerConfig(); PeerEurekaNodes getPeerEurekaNodes(); ServerCodecs getServerCodecs(); PeerAwareInstanceRegistry getRegistry(); ApplicationInfoManager getApplicationInfoManager();&#125; com.netflix.eureka.DefaultEurekaServerContext：Eureka-Server上下文默认实现类，源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586@Singletonpublic class DefaultEurekaServerContext implements EurekaServerContext &#123; private static final Logger logger = LoggerFactory.getLogger(DefaultEurekaServerContext.class); /** * Eureka-Server配置对象 */ private final EurekaServerConfig serverConfig; /** * 编解码器 */ private final ServerCodecs serverCodecs; /** * 应用实例信息注册表 */ private final PeerAwareInstanceRegistry registry; /** * Eureka-Server集群节点集合 */ private final PeerEurekaNodes peerEurekaNodes; /** * 应用信息管理器 */ private final ApplicationInfoManager applicationInfoManager; @Inject public DefaultEurekaServerContext(EurekaServerConfig serverConfig, ServerCodecs serverCodecs, PeerAwareInstanceRegistry registry, PeerEurekaNodes peerEurekaNodes, ApplicationInfoManager applicationInfoManager) &#123; this.serverConfig = serverConfig; this.serverCodecs = serverCodecs; this.registry = registry; this.peerEurekaNodes = peerEurekaNodes; this.applicationInfoManager = applicationInfoManager; &#125; @PostConstruct @Override public void initialize() throws Exception &#123; logger.info("Initializing ..."); // 启动Eureka-Server集群节点集合 peerEurekaNodes.start(); // 初始化应用实例信息注册表 registry.init(peerEurekaNodes); logger.info("Initialized"); &#125; @PreDestroy @Override public void shutdown() throws Exception &#123; logger.info("Shutting down ..."); // 关闭应用实例信息注册表 registry.shutdown(); // 关闭Eureka-Server集群节点集合 peerEurekaNodes.shutdown(); logger.info("Shut down"); &#125; @Override public EurekaServerConfig getServerConfig() &#123; return serverConfig; &#125; @Override public PeerEurekaNodes getPeerEurekaNodes() &#123; return peerEurekaNodes; &#125; @Override public ServerCodecs getServerCodecs() &#123; return serverCodecs; &#125; @Override public PeerAwareInstanceRegistry getRegistry() &#123; return registry; &#125; @Override public ApplicationInfoManager getApplicationInfoManager() &#123; return applicationInfoManager; &#125;&#125; com.netflix.eureka.EurekaServerContextHolder：Eureka-Server上下文持有者，可以通过它获取上下文，源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class EurekaServerContextHolder &#123; /** * Eureka-Server上下文 */ private final EurekaServerContext serverContext; private EurekaServerContextHolder(EurekaServerContext serverContext) &#123; this.serverContext = serverContext; &#125; /** * 获取Eureka-Server上下文 * * @return Eureka-Server上下文 */ public EurekaServerContext getServerContext() &#123; return this.serverContext; &#125; /** * Eureka-Server上下文持有者 */ private static EurekaServerContextHolder holder; /** * 初始化 * * @param serverContext Eureka-Server上下文 */ public static synchronized void initialize(EurekaServerContext serverContext) &#123; holder = new EurekaServerContextHolder(serverContext); &#125; /** * 获取Eureka-Server上下文持有者 * * @return Eureka-Server上下文持有者 */ public static EurekaServerContextHolder getInstance() &#123; return holder; &#125;&#125; StatusFilterStatusFilter简介所属包：com.netflix.eureka.StatusFilter，根据InstanceStatus过滤Eureka-Server。当 Eureka-Server 未处于开启( InstanceStatus.UP )状态，返回 HTTP 状态码 307 重定向 。 StatusFilter源码123456789101112public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; InstanceInfo myInfo = ApplicationInfoManager.getInstance().getInfo(); InstanceStatus status = myInfo.getStatus(); if (status != InstanceStatus.UP &amp;&amp; response instanceof HttpServletResponse) &#123; HttpServletResponse httpRespone = (HttpServletResponse) response; httpRespone.sendError(SC_TEMPORARY_REDIRECT, "Current node is currently not ready to serve requests -- current status: " + status + " - try another DS node: "); &#125; chain.doFilter(request, response);&#125; ServerRequestAuthFilterServerRequestAuthFilter简介所属包：com.netflix.eureka.ServerRequestAuthFilter，用于客户端请求的身份验证过滤器。目前，它只记录来自标题信息的支持的客户端标识数据。 ServerRequestAuthFilter源码1234567891011121314151617protected void logAuth(ServletRequest request) &#123; if (serverConfig.shouldLogIdentityHeaders()) &#123; if (request instanceof HttpServletRequest) &#123; HttpServletRequest httpRequest = (HttpServletRequest) request; String clientName = getHeader(httpRequest, AbstractEurekaIdentity.AUTH_NAME_HEADER_KEY); String clientVersion = getHeader(httpRequest, AbstractEurekaIdentity.AUTH_VERSION_HEADER_KEY); DynamicCounter.increment(MonitorConfig.builder(NAME_PREFIX + clientName + "-" + clientVersion).build()); &#125; &#125;&#125;protected String getHeader(HttpServletRequest request, String headerKey) &#123; String value = request.getHeader(headerKey); return Strings.isNullOrEmpty(value) ? UNKNOWN : value;&#125; RateLimitingFilterRateLimitingFilter简介所属包：com.netflix.eureka.RateLimitingFilter，请求速率限制过滤器。 GzipEncodingEnforcingFilterGzipEncodingEnforcingFilter简介所属包：com.netflix.eureka.GzipEncodingEnforcingFilter，gzip编码。最初Eureka仅支持非压缩响应, 对于大型注册管理机构来说，它非常低效，因此增加了gzip编码。如今，所有现代HTTP客户端都透明地支持gzip HTTP响应，因此不再需要维护未压缩的内容。 通过添加此过滤器，Eureka 服务器将只接受明确支持gzip编码回复的GET请求。, 在即将到来的次要版本中，非压缩回复将完全丢弃，因此此过滤器将成为必需。 GzipEncodingEnforcingFilter源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273@Overridepublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest httpRequest = (HttpServletRequest) request; if ("GET".equals(httpRequest.getMethod())) &#123; String acceptEncoding = httpRequest.getHeader(HttpHeaders.ACCEPT_ENCODING); if (acceptEncoding == null) &#123; chain.doFilter(addGzipAcceptEncoding(httpRequest), response); return; &#125; if (!acceptEncoding.contains("gzip")) &#123; ((HttpServletResponse) response).setStatus(HttpServletResponse.SC_NOT_ACCEPTABLE); return; &#125; &#125; chain.doFilter(request, response);&#125;private static HttpServletRequest addGzipAcceptEncoding(HttpServletRequest request) &#123; return new HttpServletRequestWrapper(request) &#123; @Override public Enumeration&lt;String&gt; getHeaders(String name) &#123; if (HttpHeaders.ACCEPT_ENCODING.equals(name)) &#123; return new EnumWrapper&lt;String&gt;("gzip"); &#125; return new EnumWrapper&lt;String&gt;(super.getHeaders(name), HttpHeaders.ACCEPT_ENCODING); &#125; @Override public Enumeration&lt;String&gt; getHeaderNames() &#123; return new EnumWrapper&lt;String&gt;(super.getHeaderNames(), HttpHeaders.ACCEPT_ENCODING); &#125; @Override public String getHeader(String name) &#123; if (HttpHeaders.ACCEPT_ENCODING.equals(name)) &#123; return "gzip"; &#125; return super.getHeader(name); &#125; &#125;;&#125;private static class EnumWrapper&lt;E&gt; implements Enumeration&lt;E&gt; &#123; private final Enumeration&lt;E&gt; delegate; private final AtomicReference&lt;E&gt; extraElementRef; private EnumWrapper(E extraElement) &#123; this(null, extraElement); &#125; private EnumWrapper(Enumeration&lt;E&gt; delegate, E extraElement) &#123; this.delegate = delegate; this.extraElementRef = new AtomicReference&lt;&gt;(extraElement); &#125; @Override public boolean hasMoreElements() &#123; return extraElementRef.get() != null || delegate != null &amp;&amp; delegate.hasMoreElements(); &#125; @Override public E nextElement() &#123; E extra = extraElementRef.getAndSet(null); if (extra != null) &#123; return extra; &#125; if (delegate == null) &#123; throw new NoSuchElementException(); &#125; return delegate.nextElement(); &#125;&#125; ServletContainerServletContainer简介所属包：com.sun.jersey.spi.container.servlet.ServletContainer，Jersey MVC 请求过滤器。 总结我们可以看到Eureka-Server的生成，是EurekaBootStrap实现了 javax.servlet.ServletContextListener 接口，在 Servlet 容器( 例如 Tomcat、Jetty )启动时，调用 contextInitialized() 方法初始化Eureka-Server。Eureka-Server内嵌 Eureka-Client，用于和Eureka-Server集群里其他节点通信交互。 欢迎关注博主其他的文章。]]></content>
      <categories>
        <category>SpringCloud</category>
        <category>Eureka</category>
      </categories>
      <tags>
        <tag>Eureka</tag>
        <tag>SpringCloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eureka源码—EurekaClient]]></title>
    <url>%2F2018%2F03%2F21%2FEureka%E6%BA%90%E7%A0%81%E2%80%94EurekaClient%2F</url>
    <content type="text"><![CDATA[前言本篇文章主要解读Eureka-Client初始化的相关源码，文章较长，请谨慎点击！ EurekaInstanceConfig EurekaInstanceConfig简介所属包：com.netflix.appinfo.EurekaInstanceConfig，Eureka 应用实例配置接口（Application Provider，Application Consumer）。 EurekaInstanceConfig源码博主已添加中文注释，点击查看。 EurekaInstanceConfig重要属性或者重要方法 getInstanceId()获取实例id，组成结构为${spring.application.name}:${spring.application.instance_id:${random.value}}默认为null。 geAppName()获取应用名，默认为”unknown”。 getLeaseRenewalIntervalInSeconds()获取租约续约频率，单位为秒。默认为30s。应用发送心跳给Eureka-Server进行续约（告诉Eureka-Server自己还活着）。 getLeaseExpirationDurationInSeconds() 获取租约过期时间，单位为秒。默认为90s。如果超过该时间，应用还没有向Eureka-Server发送心跳，那该租约就过期了，Eureka-Serever会进行应用移除。 getMetadataMap()获取实例的元数据。如果你想自定义一些数据，在各服务之间使用，就需要该方法。 getHealthCheckUrlPath(),getHealthCheckUrl(),getSecureHealthCheckUrl()健康检查相关的几个方法。 getNamespace()获取命名空间，已配置对应的eureka属性，默认为eureka。 ​ AbstractInstanceConfigAbstractInstanceConfig简介所属包：com.netflix.appinfo.AbstractInstanceConfig，Eureka 应用实例配置抽象基类，主要实现一些相对通用的配置 AbstractInstanceConfig源码博主已添加中文注释，点击查看。 AbstractInstanceConfig重要属性或者重要方法 主要设置一些基础的属性，以及对应的get/set方法 getHostInfo()获取本地服务器的主机名和主机IP地址 PropertiesInstanceConfigPropertiesInstanceConfig简介所属包：com.netflix.appinfo.PropertiesInstanceConfig，通过配置文件进行Eureka实例配置的抽象基类 PropertiesInstanceConfig源码博主已添加中文注释，点击查看。 PropertiesInstanceConfig重要属性或者重要方法 namespace命名空间。 configInstance配置文件，基于Netflix Archaius 1.x 实现读取配置文件。基于Netflix Archaius 2.x 的还在开发中。 appGrpNameFromEnv从环境变量中获取应用分组，ConfigurationManager.getConfigInstance获取当前的系统范围配置。 Archaius1Utils.initConfig(CommonConstants.CONFIG_FILE_NAME)，CommonConstants.CONFIG_FILE_NAME为eureka-client，Archaius1Utils.initConfig方法源码如下： 12345678910111213141516171819202122232425262728293031323334public final class Archaius1Utils &#123; private static final Logger logger = LoggerFactory.getLogger(Archaius1Utils.class); private static final String ARCHAIUS_DEPLOYMENT_ENVIRONMENT = "archaius.deployment.environment"; private static final String EUREKA_ENVIRONMENT = "eureka.environment"; public static DynamicPropertyFactory initConfig(String configName) &#123; // 配置文件对象 DynamicPropertyFactory configInstance = DynamicPropertyFactory.getInstance(); // 配置文件名，如果configName没有配置，即为CommonConstants.CONFIG_FILE_NAME（"eureka-client"） DynamicStringProperty EUREKA_PROPS_FILE = configInstance.getStringProperty("eureka.client.props", configName); // 配置文件环境 String env = ConfigurationManager.getConfigInstance().getString(EUREKA_ENVIRONMENT, "test"); // 将配置文件加载到环境变量 ConfigurationManager.getConfigInstance().setProperty(ARCHAIUS_DEPLOYMENT_ENVIRONMENT, env); String eurekaPropsFile = EUREKA_PROPS_FILE.get(); try &#123; //读取配置文件到环境变量，首先读取 $&#123;eureka.client.props&#125; 对应的配置文件；然后读取 $&#123;eureka.client.props&#125;-$&#123;eureka.environment&#125; 对应的配置文件。若有相同属性，进行覆盖。 ConfigurationManager.loadCascadedPropertiesFromResources(eurekaPropsFile); &#125; catch (IOException e) &#123; logger.warn( "Cannot find the properties specified : &#123;&#125;. This may be okay if there are other environment " + "specific properties or the configuration is installed with a different mechanism.", eurekaPropsFile); &#125; return configInstance; &#125;&#125; 其他实现方法基本类似，都是从配置文件中获取值，举一个例子： ​ isInstanceEnabledOnit()：从配置文件中获取是否在实例初始化的时候开启，并传一个默认值（这里是父类AbstractInstanceConfig中实现的方法），namespace的属性key都在PropertyBasedInstanceConfigConstants中 MyDataCenterInstanceConfigMyDataCenterInstanceConfig简介所属包：com.netflix.appinfo.MyDataCenterInstanceConfig，Eureka应用实例配置实现类 MyDataCenterInstanceConfig源码123456789101112131415161718public class MyDataCenterInstanceConfig extends PropertiesInstanceConfig implements EurekaInstanceConfig &#123; /** * 无参构造方法 */ public MyDataCenterInstanceConfig() &#123; &#125; public MyDataCenterInstanceConfig(String namespace) &#123; //调用父类含有namespace参数的构造函数进行初始化 super(namespace); &#125; public MyDataCenterInstanceConfig(String namespace, DataCenterInfo dataCenterInfo) &#123; //调用父类含有namespace和dataCenterInfo参数的构造函数进行初始化 super(namespace, dataCenterInfo); &#125;&#125; InstanceInfoInstanceInfo简介所属包：com.netflix.appinfo.InstanceInfo，应用实例信息。Eureka-Client 向 Eureka-Server 注册该对象信息。注册成功后，可以被其他 Eureka-Client 发现。Eureka通过com.netflix.appinfo.providers.EurekaConfigBasedInstanceInfoProvider基于EurekaInstanceConfig创建InstanceInfo。 EurekaConfigBasedInstanceInfoProvider源码博主已添加中文注释，点击查看。 EurekaConfigBasedInstanceInfoProvider重要属性或者重要方法 基本上每个属性和每个方法都添加了注释 其中vip地址解析器源码如下： 12345678910public interface VipAddressResolver &#123; /** * Convert &lt;code&gt;VIPAddress&lt;/code&gt; by substituting environment variables if necessary. * * @param vipAddressMacro the macro for which the interpolation needs to be made. * @return a string representing the final &lt;code&gt;VIPAddress&lt;/code&gt; after substitution. */ String resolveDeploymentContextBasedVipAddresses(String vipAddressMacro);&#125; 实现类源码（Archaius1实现，Archaius2还在开发中）： 1234567891011121314151617181920212223242526272829303132public class Archaius1VipAddressResolver implements VipAddressResolver &#123; private static final Logger logger = LoggerFactory.getLogger(Archaius1VipAddressResolver.class); private static final Pattern VIP_ATTRIBUTES_PATTERN = Pattern.compile("\\$\\&#123;(.*?)\\&#125;"); @Override public String resolveDeploymentContextBasedVipAddresses(String vipAddressMacro) &#123; if (vipAddressMacro == null) &#123; return null; &#125; String result = vipAddressMacro; //匹配$&#123;(.*?)&#125; Matcher matcher = VIP_ATTRIBUTES_PATTERN.matcher(result); while (matcher.find()) &#123; String key = matcher.group(1); String value = DynamicPropertyFactory.getInstance().getStringProperty(key, "").get(); logger.debug("att:&#123;&#125;", matcher.group()); logger.debug(", att key:&#123;&#125;", key); logger.debug(", att value:&#123;&#125;", value); logger.debug(""); //将$&#123;(.*?)&#125;替换为配置文件中对应的value result = result.replaceAll("\\$\\&#123;" + key + "\\&#125;", value); matcher = VIP_ATTRIBUTES_PATTERN.matcher(result); &#125; return result; &#125;&#125; ApplicationInfoManagerApplicationInfoManager简介所属包：com.netflix.appinfo.ApplicationInfoManager，应用信息管理类，由InstanceInfo和EurekaInstanceConfig生成。 ApplicationInfoManager源码博主已添加中文注释，点击查看。 EurekaClientConfigEurekaClientConfig简介所属包：com.netflix.discovery.EurekaClientConfig，Eureka-Client 配置接口，获取连接的 Eureka-Server 的地址、获取服务提供者列表的频率、注册自身为服务提供者的频率等等。 EurekaClientConfig源码博主已添加中文注释，点击查看。 EurekaClientConfig重要属性或者重要方法 getRegion()，getAvailabilityZones()：region和zone（或者Availability Zone）均是AWS的概念。在非AWS环境下，我们可以简单地将region理解为Eureka集群，zone理解成机房。Spring Cloud中默认的region是us-east-1 。具体可查看《周立 —— Region、Zone解析》。 getEurekaServerServiceUrls()：获取Eureka-Server的Url集合 从Eureka-Server获取注册信息的相关方法： getRegistryFetchIntervalSeconds()：获取注册信息的时间间隔，单位为秒。默认为30s getEurekaServiceUrlPollIntervalSeconds()：向Eureka-Server获取Eureka服务地址的变化时间间隔，单位为秒。默认为 5 * 60 * 1000 s getEurekaServerReadTimeoutSeconds()：获取Eureka-Server读取超时时间，单位为秒。默认为8s getBackupRegistryImpl()：获取备份注册中心实现类。默认为null shouldPreferSameZoneEureka()：相同Zone的Eureka是否优先。默认为true shouldDisableDelta()：是否使用增量形式获取注册信息。默认为false fetchRegistryForRemoteRegions()：获取远程区域的注册信息。默认为null shouldFilterOnlyUpInstances()：是否只获取Up（启动）状态的实例。默认为true shouldFetchRegistry()：是否从Eureka-Server获取注册信息。默认为true getRegistryRefreshSingleVipAddress()：获取单个vip地址（虚拟IP地址）的注册信息。默认为null getCacheRefreshExecutorThreadPoolSize()：获取注册信息缓存刷新的线程池大小。默认为5 getCacheRefreshExecutorExponentialBackOffBound()：获取注册信息缓存刷新执行超时后的延迟重试时间的最大倍数。默认为10 向Eureka-Server注册自身服务的相关方法： getInstanceInfoReplicationIntervalSeconds()：获取向Eureka-Server同步实例信息的时间间隔，单位为秒。默认为30s getInitialInstanceInfoReplicationIntervalSeconds()：获取最初向Eureka-Server同步实例信息的时间间隔，单位为秒。默认为40s getEurekaServerConnectTimeoutSeconds()：获取Eureka-Server连接超时时间，单位为秒。默认为5s shouldRegisterWithEureka()：是否向Eureka-Server注册自身服务。默认为true shouldUnregisterOnShutdown()：当Eureka-Server关闭的时候，是否注销自己的服务。默认为true getHeartbeatExecutorThreadPoolSize()：获取心跳检测执行的线程池大小。默认为5 getHeartbeatExecutorExponentialBackOffBound()：获取心跳检测执行超时后的延迟重试时间的最大倍数。默认为10 shouldEnforceRegistrationAtInit()：是否在实例初始化的时候进行注册。默认为false DefaultEurekaClientConfigDefaultEurekaClientConfig简介所属包：com.netflix.discovery.DefaultEurekaClientConfig，基于配置文件的Eureka-Client配置实现类。 DefaultEurekaClientConfig源码博主已添加中文注释，点击查看。 DefaultEurekaClientConfig重要属性或者重要方法 其中属性和构造方法基本上都加了中文注释。 其他实现方法基本类似，都是从配置文件中获取值，举一个例子： `getRegistryFetchIntervalSeconds()`：从配置文件中获取读取注册信息的时间间隔，并传一个默认值（这里是30），namespace后面的属性key都在PropertyBasedClientConfigConstants中。 DefaultEurekaClientConfigProviderDefaultEurekaClientConfigProvider简介所属包：com.netflix.discovery.providers.DefaultEurekaClientConfigProvider，创建 DefaultEurekaClientConfig 的工厂 。 DefaultEurekaClientConfigProvider源码1234567891011121314151617181920212223public class DefaultEurekaClientConfigProvider implements Provider&lt;EurekaClientConfig&gt; &#123; @Inject(optional = true) @EurekaNamespace private String namespace; private DefaultEurekaClientConfig config; @Override public synchronized EurekaClientConfig get() &#123; if (config == null) &#123; //根据命名空间是否为空来判断调用哪一个构造方法创建DefaultEurekaClientConfigProvider config = (namespace == null) ? new DefaultEurekaClientConfig() : new DefaultEurekaClientConfig(namespace); // TODO: Remove this when DiscoveryManager is finally no longer used DiscoveryManager.getInstance().setEurekaClientConfig(config); &#125; return config; &#125;&#125; 很简单的一个类，不做过多的分析。 EurekaTransportConfigEurekaTransportConfig简介所属包：com.netflix.discovery.shared.transport.EurekaTransportConfig，Eureka网络传输配置接口。 EurekaTransportConfig源码博主已添加中文注释，点击查看。 EurekaTransportConfig重要属性或者重要方法 getSessionedClientReconnectIntervalSeconds()：Eureka-Client 会话重新连接的时间间隔，单位为秒，默认为20 * 60s。 getRetryableClientQuarantineRefreshPercentage()：请求失败的Eureka-Client隔离集合占Eureka-Client总数的占比，超过该比例会进行清空，默认为0.66。 Endpoint相关： getAsyncResolverRefreshIntervalMs()：异步解析 EndPoint 集群频率，单位为毫秒。默认为5 * 60 * 1000ms。 getAsyncResolverWarmUpTimeoutMs()：异步解析器预热解析 EndPoint 集群超时时间，单位为毫秒。默认为5000s。 getAsyncExecutorThreadPoolSize()：异步线程池大小，默认为5。 DefaultEurekaTransportConfigDefaultEurekaTransportConfig简介所属包：com.netflix.discovery.shared.transport.DefaultEurekaTransportConfig，基于配置文件的网络传输配置实现类 。 DefaultEurekaTransportConfig源码博主已添加中文注释，点击查看。 DefaultEurekaTransportConfig重要属性或者重要方法 其他实现方法基本类似，都是从配置文件中获取值，举一个例子： getSessionedClientReconnectIntervalSeconds()：Eureka-Client 会话重新连接的时间间隔，并传一个默认值（这里是20 * 60），namespace的属性key都在PropertyBasedTransportConfigConstants中。 LookupServiceLookupService简介所属包：com.netflix.discovery.shared.LookupService，查找服务接口，可以获取应用集合和应用实例集合。 在 Eureka-Client 里，EurekaClient 继承该接口。 在 Eureka-Server 里，com.netflix.eureka.registry.InstanceRegistry 继承该接口。 LookupService源码 博主已添加中文注释，点击查看。 EurekaClientEurekaClient简介所属包：com.netflix.discovery.EurekaClient，Eureka-Client接口 。 EurekaClient源码博主已添加中文注释，点击查看。 EurkeaClient重要属性或者重要方法 获取应用集合： getApplicationsForARegion(@Nullable String region)：获取指定区域中的Applications。 getApplications(String serviceUrl)：获取指定的Eureka服务地址中注册的应用集合。 获取应用实例集合： getInstancesByVipAddress(String vipAddress, boolean secure)：获取指定VIP地址的实例列表。 getInstancesByVipAddress(String vipAddress, boolean secure, @Nullable String region)：获取指定VIP地址和区域的实例信息列表。 getInstancesByVipAddressAndAppName(String vipAddress, String appName, boolean secure)：获取指定VIP地址和appName的实例信息列表。 getAllKnownRegions()：获取所有已知的区域。 getInstanceRemoteStatus()：获取实例状态。 registerHealthCheck()：Eureka-Client注册健康检查。 getHealthCheckHandler()：获取健康监测处理器。 registerEventListener()：Eureka-Client注册事件监听。 unregisterEventListener()：Eureka-Client取消事件监听注册。 getEurekaClientConfig()：获取Eureka-Client配置。 getApplicationInfoManager()：获取应用信息管理器。 DiscoveryClient DiscoveryClient简介所属包：com.netflix.discovery.DiscoveryClient，EurekaClient接口的实现类，用于与 Eureka-Server 交互。包含方法： 向 Eureka-Server 注册自身服务 向 Eureka-Server 续约自身服务 向 Eureka-Server 取消自身服务，当关闭时 从 Eureka-Server 查询应用集合和应用实例信息 本文主要介绍DiscoveryClient的初始化，其他方法后续文章会有介绍 DiscoveryClient源码博主已添加中文注释，点击查看。 DiscoveryClient重要属性或者重要方法构造函数： 12345@InjectDiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args, Provider&lt;BackupRegistry&gt; backupRegistryProvider) &#123; //省略具体代码&#125; 参数： ApplicationInfoManager：应用信息管理类，具体可查看ApplicationInfoManager小结。 EurekaClientConfig：Eureka-Client 配置接口，获取连接的 Eureka-Server 的地址、获取服务提供者列表的频率、注册自身为服务提供者的频率等等，具体可查看EurekaClientConfig小结。 AbstractDiscoveryClientOptionalArgs：DiscoveryClient 可选参数抽象基类。该参数是选填参数，实际生产中很少使用，源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public abstract class AbstractDiscoveryClientOptionalArgs&lt;T&gt; &#123; /** * 健康检查回调的工厂 */ Provider&lt;HealthCheckCallback&gt; healthCheckCallbackProvider; /** * 健康检查处理器的工厂 */ Provider&lt;HealthCheckHandler&gt; healthCheckHandlerProvider; /** * 向Eureka-Server注册之前的处理器 */ PreRegistrationHandler preRegistrationHandler; /** * Jersey 过滤器集合 */ Collection&lt;T&gt; additionalFilters; /** * Jersey 客户端 */ EurekaJerseyClient eurekaJerseyClient; /** * 生成 Jersey 客户端工厂 */ TransportClientFactory transportClientFactory; /** * 生成 Jersey 客户端工厂 */ TransportClientFactories transportClientFactories; /** * Eureka 事件监听集合 */ private Set&lt;EurekaEventListener&gt; eventListeners; /** * ssl */ private Optional&lt;SSLContext&gt; sslContext = Optional.empty(); /** * 主机认证 */ private Optional&lt;HostnameVerifier&gt; hostnameVerifier = Optional.empty(); //省略set方法&#125; Provider&lt;BackupRegistry&gt;：备份注册中心接口，当 Eureka-Client 启动时，无法从 Eureka-Server 读取注册信息，就从备份注册中心读取注册信息 ，源码如下： 1234567@ImplementedBy(NotImplementedRegistryImpl.class)public interface BackupRegistry &#123; Applications fetchRegistry(); Applications fetchRegistry(String[] includeRemoteRegions);&#125; 实现类源码如下（可以看出暂未提供合适的实现）： 123456789101112131415161718192021222324@Singletonpublic class NotImplementedRegistryImpl implements BackupRegistry &#123; /** * 获取应用注册信息 * * @return 应用列表对象 （默认为null） */ @Override public Applications fetchRegistry() &#123; return null; &#125; /** * 获取应用注册信息 * * @param includeRemoteRegions 远程区域列表 * @return 应用列表对象（默认为null） */ @Override public Applications fetchRegistry(String[] includeRemoteRegions) &#123; return null; &#125;&#125; 具体逻辑可查看源码，博主已添加中文注释 总结我们可以看到 EurekaClient 的创建，先是通过 EurekaInstanceConfig 生成 InstanceInfo，再通过 EurekaInstanceConfig 和 InstanceInfo 生成 ApplicationInfoManager，最后 EurekaClientConfig 和 ApplicationInfoManager 生成 EurekaClient。 欢迎关注博主其他的文章。]]></content>
      <categories>
        <category>SpringCloud</category>
        <category>Eureka</category>
      </categories>
      <tags>
        <tag>Eureka</tag>
        <tag>SpringCloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eureka源码系列简介]]></title>
    <url>%2F2018%2F03%2F18%2FEureka%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[前言最近关于微服务的话题很火热，本系列文章主要是从源码去解读Eureka。 PS： 什么是微服务，本文不做具体介绍，可以自行上网查找。 如果没有使用过SpringCloud，博主建议先自行搭建一套服务之后，再进行源码的解读。 该系列文章很枯燥也很耗时，请合理安排时间。 博主是参考了芋艿大佬的路线进行源码解读的，其中有部分问题借鉴了芋艿大佬的解读。点击访问芋艿大佬的博客 Eureka项目结构简介 eureka-client com.netflix.appinfo : Eureka-Client 的应用配置 com.netflix.discovery : Eureka-Client 的注册和发现功能 eureka-client-archaius2Archaius是 Netflix 开源的配置管理组件。Eureka 使用 1.x 版本，2.x 版本仍然在开发中，2.x只兼容jdk1.8以上的版本。 eureka-client-jersey2Jersey 框架实现Eureka的 RESTful HTTP接口。Eureka 使用 1.x 版本，2.x 版本由社区实现。 eureka-core com.netflix.eureka.aws : 与AWS (Amazon Web Services) 相关，该系列文章暂不涉及AWS的分析 com.netflix.eureka.cluster : 与peer节点复制(replication)相关 com.netflix.eureka.lease : 租约，用来控制注册信息的生命周期(注册、续约、剔除) com.netflix.eureka.registry : 存储、查询服务注册信息 com.netflix.eureka.resources : RESTful中的”R”，即资源。相当于SpringMVC中的Controller com.netflix.eureka.transport : 发送HTTP请求的客户端，如发送心跳 com.netflix.eureka.util : 相关工具包 eureka-core-jersey2Jersey 框架实现Eureka的 RESTful HTTP接口。Eureka 使用 1.x 版本，2.x 版本由社区实现。 eureka-examplesEureka-Client 使用例子。 eureka-resources通过 JSP 实现 Eureka-Server 的运维后台界面。 eureka-server由 eureka-client + eureka-core + eureka-resources 打包成 Eureka-Server 的war包。 eureka-server-governator使用 Netflix Governator （Google Guice的扩展类库，提供了Classpath扫描及自动绑定、生命周期管理、成员属性验证等功能）管理 Eureka-Server 的生命周期。目前该模块正在测试阶段。 eureka-test-utilsEureka 单元测试工具类。]]></content>
      <categories>
        <category>SpringCloud</category>
        <category>Eureka</category>
      </categories>
      <tags>
        <tag>Eureka</tag>
        <tag>SpringCloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JPA使用Java8的LocalDateTime]]></title>
    <url>%2F2017%2F12%2F02%2FJPA%E4%BD%BF%E7%94%A8Java8%E7%9A%84LocalDateTime%2F</url>
    <content type="text"><![CDATA[前言这篇文章主要介绍JPA如何正确使用LocalDateTime与数据库datetime属性进行映射。 对应的JPA版本是2.1以下的，由于JPA2.1发布时间早于Java8，所以不能直接支持Java8的新特新。Oracle最新发布的JPA2.2版本是支持新的时间API以及查询结果流等。 MyBatis请查看MyBatis使用Java8的LocalDateTime。 解决方法spring-boot-starter-data-jpa的版本为1.5.9.RELEASE，对应的hibernate-core版本为5.0.12.Final 将数据保存到数据库 添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-java8&lt;/artifactId&gt; &lt;version&gt;5.0.12.Final&lt;/version&gt;&lt;/dependency&gt; 添加注解，在获取LocalDateTime时，指定时间格式 12345678910public class User &#123; @Id @Column(name = "id", nullable = false, length = 20) private Long id; @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", locale = "zh", timezone = "GMT+8") @Column(name = "gmt_create") private LocalDateTime gmtCreate; //省略get，set方法&#125; 总结博主一开始遇到了一个坑，我用的hibernate-java8版本为5.2.8.Final，结果报错了。后来发现这个版本的hibernate-core是5.2.8.Final。后来改成对应的5.0.12.Final就正确了。 欢迎关注博主其他的文章。]]></content>
      <categories>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>Java8</tag>
        <tag>JPA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis使用Java8的LocalDateTime]]></title>
    <url>%2F2017%2F12%2F01%2FMyBatis%E4%BD%BF%E7%94%A8Java8%E7%9A%84LocalDateTime%2F</url>
    <content type="text"><![CDATA[前言众所周知，Java8之前的时间API有很多问题，比如：非线程安全，设计很差。时区处理麻烦。新的时间API（java.time包）解决了这些问题，所以我们在平时开发尽可能的使用新的时间API。但是MyBatis使用LocalDataTime映射到数据库的datetime属性时，会报错。 解决方法mybatis-spring-boot-starter的版本为1.3.1，对应的MyBatis版本为3.4.5（版本低于3.4.0还需要特殊配置） 将数据保存到数据库 添加依赖 12345678910111213&lt;!-- LocalDateTime映射到数据库需要的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-typehandlers-jsr310&lt;/artifactId&gt; &lt;version&gt;1.0.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 格式化LocalDateTime需要的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt; &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt; 添加注解，设置时间格式 1234567public class User &#123; private Integer id; @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", locale = "zh", timezone = "GMT+8") private LocalDateTime gmtCreate; //省略get，set方法&#125; 总结关于MyBatis使用LocalDateTime的内容就是上面这些了，如果使用的ORM框架式JPA，请点击JPA使用Java8的LocalDateTime。 欢迎关注博主其他的文章。]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>Java8</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8新特性—Lambda表达式]]></title>
    <url>%2F2017%2F08%2F05%2FJava8%E6%96%B0%E7%89%B9%E6%80%A7%E2%80%94Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言JDK1.8是自JDK1.5以来最具革命性的版本。JDK1.8为Java语言、编译器、类库、开发工具与JVM（Java虚拟机）带来了大量新特性。所做的改变，在许多方面比Java历史上任何一次改变都深远。它们会让你编起程来更容易。本文主要介绍JDK1.8最重要的新特性之一：Lambda表达式。 ps：博主的公司也切换为JDK1.8了，CTO让我进行一次JDK1.8的分享，本文也是记录一下。 什么是Lambda表达式Lambda表达式可以理解为简洁地表示可传递的匿名函数的一种方式。 是不是很抽象的一句话？那让我们看一下它长什么样。 1(String s) -&gt; s. isEmpty() 什么鬼，长得也这么抽象。 我们看一下表达式结构中最特别的是-&gt;，而这个箭头的左边是Lambda的参数列表，右边是Lambda的函数主体。所以Lambda表达式的结构表示为：(parameters) -&gt; expression 或 (parameters) -&gt;{ statements; }。 如下： 12Comparator&lt;String&gt; sort = (String s1, String s2) -&gt; (s1.compareTo(s2));Runnable runnable = () -&gt; System.out.println("Hello world !"); 这样看来是不是有所明白了？ 如何使用Lambda表达式 我们使用以前的方法创建一个新的线程，代码如下： 123456Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("匿名内部类实现Runnable"); &#125;&#125;); 接下来使用Lambda表达式创建一个新的线程，代码如下： 1Thread thread = new Thread(() -&gt; System.out.println("Lambda实现Runnable" )); 通过上面代码的对比，我们看到Lambda表达式实现了Runnable接口。 那所有的接口都可以用Lambda表达式来实现吗？ 答案当然是不行的，只有函数式接口才能使用Lambda表达式。什么是函数式接口？让我们继续看下一节。 函数式接口所谓的函数式接口，就是接口中只定义了一个抽象方法（SAM：Single Abstract Method）。Java8接口中的默认方法和静态方法，都不算是抽象方法。接口默认继承Object，所以如果接口显示声明覆盖了Object中方法，那么也不算抽象方法。 在Java8中，使用@FunctionalInterface标记一个函数式接口 。该注解不是必须的，如果一个接口符合函数式接口的定义，那么加上该注解能够更好地让编译器进行检查。如果不是函数式接口，但是加上了@FunctionalInterface，那么编译器会报错。 Java8中新增的函数式接口 Predicate&lt;T&gt; Consumer&lt;T&gt; Supplier&lt;T&gt; Function&lt;T,R&gt; BinaryOperator&lt;T&gt; UnaryOperator&lt;T&gt; 还有很多是通过上面六个衍化出来的，具体可以查看JDK1.8的API 类型推断这一节，我们说一下类型推断~ 看一下下面的代码： 12Callable&lt;String&gt; c = () -&gt; "done";PrivilegedAction&lt;String&gt; p = () -&gt; "done"; 同一个Lambda表达式() -&gt; &quot;done&quot;，但是表示了不同的类型。 当且仅当下面所有条件均满足时，Lambda 表达式才可以被赋给目标类型 T： T 是一个函数式接口 Lambda 表达式的参数和 T 的方法参数在数量和类型上一一对应 Lambda 表达式的返回值和 T 的方法返回值相兼容（Compatible） Lambda 表达式内所抛出的异常和 T 的方法 throws 类型相兼容 而类型推断可以通过如下的规则进行推断： 变量声明 赋值 返回语句 数组初始化器 方法和构造方法的参数 Lambda 表达式函数体 条件表达式（? :） 转型（Cast）表达式 特殊的void兼容规则：如果一个Lambda的主体是一个语句表达式，它就和一个返回void的函数描述符兼容（当然需要参数列表也兼容）。例如，以下两行都是合法的： 12Predicate&lt;String&gt; p = list::add;Consumer&lt;String&gt; c = list::add; 默认方法和静态方法上一节说到，接口的默认方法和静态方法并不是抽象方法。这好像跟我们平时认识的接口，有所不同，接口里面的方法都是没有具体实现的。怎么还会有不是抽象方法的方法？ 默认方法我们先看一下默认方法，代码如下： 123default Stream&lt;E&gt; stream() &#123; return StreamSupport.stream(spliterator(), false);&#125; 在接口的方法名前面加个default关键字即可实现默认方法 。 ps：default关键字，博主之前还是在用switch的时候用到了。 引入默认方法最主要的作用是：为了解决接口的修改与现有的实现不兼容的问题，不需要逐个修改实现类。因为实现类默认携带接口的默认方法。 说到这里，有细心的读者就会想到：Java语言中一个类只能继承一个父类，但是一个类可以实现多个接口。随着默认方法在Java 8中引入，有可能出现一个类继承了多个方法而它们使用的却是同样的函数签名。这种情况下，类会选择使用哪一个函数？ 解决该问题的规则如下： 类中的方法优先级最高。 类或父类中显式声明的方法，其优先级高于所有的默认方法 如果无法依据第一条进行判断，那么子接口的优先级更高 如果2规则也失效，则需要显式指定接口，X.super.m(…) 静态方法Java 8 的另一个特性是接口可以声明（并且可以提供实现）静态方法 ，代码如下： 1234567public static &lt;T, U extends Comparable&lt;? super U&gt;&gt; Comparator&lt;T&gt; comparing( Function&lt;? super T, ? extends U&gt; keyExtractor) &#123; Objects.requireNonNull(keyExtractor); return (Comparator&lt;T&gt; &amp; Serializable) (c1, c2) -&gt; keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2)); &#125; Java8之后的接口和抽象类对比从上面可以看到Java8之后，抽象类和接口越来越接近了，是接口向抽象类靠近，剥夺抽象类的生存空间。 与抽象类相比，接口不能搞定的： 抽象类能够定义非 static final 的属性(field) ，而接口不能。接口的属性都是static final的。 抽象类能够定义非public方法，而接口不能。接口的方法都是public的。 与接口相比，抽象类不能搞定的： 接口可以多继承(实现)，而抽象类不能。抽象类只能单继承。 方法引用类型推断这一节的最后，我们看到了Lambda表达式的结构变了。它的-&gt;不见了，取而代之的是::，::左右两边也不是参数列表和方法主体，其实这是用了方法引用。 什么是方法引用？ 方法引用简单地说,就是一个Lambda表达式 。方法引用的标准形式是：类名::方法名。 为什么会有方法引用？ 因为，我们有时使用Lambda表达式可能仅仅调用一个已存在的方法，而不做任何其它事。对于这种情况，通过一个方法名字来引用这个已存在的方法会更加清晰。 怎么使用方法引用？ 首先，我们定义一个list： 1List&lt;String&gt; list = Arrays.asList("c", "A", "C"); 然后使用Lambda表达式进行排序： 1list.sort((s1, s2) -&gt; s1.compareTo(s2)); 这里的compareTo方法是已存在的方法，所以我们可以用方法引用代替它： 1list.sort(String::compareTo); 是不是看上去很简洁？ 下面说一下方法引用的种类： 方法引用种类 示例 静态方法引用：ClassName::methodName IntBinaryOperator staticMethod = Integer::sum; 实例上的实例方法引用：instanceReference::methodName Predicate predicate = new ArrayList&lt;&gt;()::contains; 类型上的实例方法引用：ClassName::methodNam Function&lt;String, String&gt; function = String::toString; 构造方法引用：Class::new Supplier supplier = ArrayList::new; 变量捕获这一节，我们说一下初学者比较常见的错误。代码如下： 123List&lt;Integer&gt; list = new ArrayList&lt;&gt;();int sum = 0;list.forEach(e -&gt; sum += e); 可能有一部分初学者会用这样的代码进行累加，但是这段代码是报编译错误的。 这是什么原因呐？ 由于Java只允许在其中捕获那些符合有效只读（Effectively final）的局部变量。 有效只读是指：如果一个局部变量在初始化后从未被修改过，那么它就符合有效只读的要求，换句话说，加上 final后也不会导致编译错误的局部变量就是有效只读变量。 序列化Lambda表达式我们看一下序列化的接口，代码如下： 12public interface Serializable &#123;&#125; 序列化接口被称为ZAM（Zero Abstract Method），即该接口中没有声明任何方法 。Serializable接口一般认为是标记性的接口。 为了能序列化，java8引入了所谓的类型关联（TypeIntersection）。 序列化Lambda表达式的具体代码如下： 12Runnable r1 = () -&gt; System.out.println(this);Runnable r2 = (Runnable &amp; Serializable) () -&gt; System.out.println(this); Lambda实现原理最后，我们来看一下Lambda表达式的实现原理。 由于Lambda表达式提供了函数式接口中抽象方法的实现，这让人有一种感觉，似乎在编译过程中让Java编译器直接将Lambda表达式转换为匿名类更直观。那jvm是不是直接把Lambda编译成匿名内部类？ 并不是，匿名类有着种种不尽如人意的特性，会对应用程序的性能带来负面影响： 编译器会为每个匿名类生成一个新的.class文件。这些新生成的类文件的文件名通常以 ClassName$1这种形式呈现，其中ClassName是匿名类出现的类的名字，紧跟着一个美元符号和一个数字。生成大量的类文件是不利的，因为每个类文件在使用之前都需要加载和验证，这会直接影响应用的启动性能。如果将Lambda表达式转换为匿名类，每个 Lambda表达式都会产生一个新的类文件，这是我们不期望发生的。 每个新的匿名类都会为类或者接口产生一个新的子类型。如果你为了实现一个比较器，使用了一百多个不同的Lambda表达式，这意味着该比较器会有一百多个不同的子类型。 这种情况下，JVM的运行时性能调优会变得更加困难。 我们看一下下面这段代码： 123456Function&lt;Object, String&gt; f = new Function&lt;Object, String&gt;() &#123; @Override public String apply(Object o) &#123; return o.toString(); &#125;&#125;; 这段代码的对应的字节码： 可以看到，通过字节码操作new，一个TestFunction$1类型的对象被实例化了。与此同时，一个指向新创建对象的引用会被压入栈。 dup操作会复制栈上的引用。 接着这个值会被invokespecial指令处理，该指令会初始化对象。 栈顶现在包含了指向对象的引用，该值通过putfield指令保存到了LambdaBytecode类 的f1字段。 我们将这段代码使用Lambda表达式实现： 1Function&lt;Object, String&gt; f = Object::toString; 对应的字节码： 通过两段字节码的对比，我们可以看到，Lambda表达式是通过invokedynamic字节码指令创建额外的类。 invokedynamic最初被JDK7引入，用于支持运行于JVM上的动态类型语言。执行方法调用时，invokedynamic添加了更高层的抽象，使得一部分逻辑可以依据动态语言的特征来决定调用目标。 使用invokedynamic，可以将实现Lambda表达式的这部分代码的字节码生成 推迟到运行时。这种设计选择带来了一系列好结果 ： Lambda表达式的代码块到字节码的转换由高层的策略变成了纯粹的实现细节。它现在可以动态地改变，或者在未来版本中得到优化和修改，并且保持了字节码的后向兼容性。 没有带来额外的开销，没有额外的字段，也不需要进行静态初始化，而这些如果不使用Lambda，就不会实现。 对无状态非捕获型Lambda，我们可以创建一个Lambda对象的实例，对其进行缓存，之后对同一对象的访问都返回同样的内容。 没有额外的性能开销，因为这些转换都是必须的，并且结果也进行了链接，仅在Lambda 首次被调用时需要转换。其后所有的调用都能直接跳过这一步，直接调用之前链接的实现。 总结Lambda表达式，语法简单，有更灵活的语义。它是Java8最重要的新特新之一，大家可以多尝试一下，毕竟Java8已经发布四年多了。不要落后咯~ 欢迎关注博主其他的文章。 参考资料《Java8 实战》]]></content>
      <categories>
        <category>Java</category>
        <category>Java8新特性</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkedHashMap源码了解一下~]]></title>
    <url>%2F2017%2F01%2F24%2FLinkedHashMap%E6%BA%90%E7%A0%81%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B~%2F</url>
    <content type="text"><![CDATA[前言LinkedHashMap是面试中比较容易问到的集合之一。本篇文章主要通过分析LinkedHashMap的源码，更深入的了解LinkedHashMap，以及对比LinkedHashMap在JDK1.8和JDK1.7的不同。 LinkedHashMap简介LinkedHashMap类结构 可以从上图看出，LinkedHashMap继承HashMap，实现了Map接口。 LinkedHashMap特点 LinkedHashMap非线程安全，在多线程中保证线程安全的解决方法：使用Map map = Collections.synchronizedMap(new LinkedHashMap());。 LinkedHashMap底层是数组和双向链表组成的。 LinkedHashMap的key和value都允许为null。 LinkedHashMap的数据存储是有序的。 LinkedHashMap继承自HashMap，所以HashMap的特点，除了输出无序，其他LinkedHashMap都有。 LinkedHashMap源码成员变量12345678/** * */transient LinkedHashMap.Entry&lt;K,V&gt; head;transient LinkedHashMap.Entry&lt;K,V&gt; tail;final boolean accessOrder;]]></content>
      <categories>
        <category>Java</category>
        <category>Map</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap源码了解一下~]]></title>
    <url>%2F2017%2F01%2F22%2FHashMap%E6%BA%90%E7%A0%81%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[前言HashMap是我们最常使用的数据类型之一，也是面试中最容易问到的集合之一。本篇文章主要通过分析HashMap的源码，更深入的了解HashMap，以及对比HashMap在JDK1.8和JDK1.7的不同。 本文基于jdk1.8 HashMap简介HashMap是一个散列表，属于java.util包，它存储的内容是键值对(key-value)映射 ，根据键的hashCode值存储数据。 HashMap类结构 可以从上图看出，HashMap继承AbstractMap抽象类，实现了Cloneable，Serializable和Map接口。 ps：为什么HashMap继承了AbstractMap抽象类，还要实现Map接口？ ​ Java集合框架的编写者Josh Bloch说这是一个错误。。在java集合框架中，类似这样的写法很多。 JDK的维护者，后来不认为这个小小的失误值得去修改。所以就这样存在下来了。 HashMap特点 HashMap非线程安全，在多线程中保证线程安全的解决方法：使用ConcurrentHashMap，Map map = Collections.synchronizedMap(new HashMap());。 HashMap底层是由数组和链表组成的，JDK1.8之后添加了红黑树，文章后续有介绍。 HashMap的key和value都允许为null。 HashMap的数据存储是无序的。 如果需要put的key为自定义的对象，需要重写该对象的equals方法和hashCode方法。注意如果对象是可变的，那你就有可能get不到你保存在HashMap中的数据了，所以重写hashCode的时候需要小心哦~ HashMap源码HashMap常量属性123456789101112131415161718192021222324252627282930/** * 初始容量为16，必须为2的幂次（这个后续会讲解） */static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16/** * 最大容量，2的30次，如果初始化的大小大于这个值，就会被这个最大容量代替 */static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;/** * 默认加载因子 * 如果加载因子太大，空间利用率高，hash碰撞概率也越高；反之则hash碰撞概率低，空间利用率也越低 */static final float DEFAULT_LOAD_FACTOR = 0.75f;/** * 如果哈希桶（Node）中的节点数达到8，链表就会被转换为红黑树 */static final int TREEIFY_THRESHOLD = 8;/** * 与上面的属性相反，是将红黑树转换为链表的阈值 */static final int UNTREEIFY_THRESHOLD = 6;/** * 哈希桶（Node）转换为树（TreeNode）的最小容量 */static final int MIN_TREEIFY_CAPACITY = 64; HashMap成员变量1234567891011121314151617181920212223242526272829/** * 哈希桶，在第一次使用时初始化，并调整为必要的大小。长度总是2的幂。 */transient Node&lt;K,V&gt;[] table;/** * 哈希桶，在第一次使用时初始化，并调整为必要的大小。长度总是2的幂。 */transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;/** * HashMap中k-v数据的数量 */transient int size;/** * HashMap结构被修改的次数 */transient int modCount;/** * HashMap下一次扩容的大小 (capacity * load factor) */int threshold;/** * 加载因子 */final float loadFactor; HashMap内部类Node123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; /** * 定位数据在数组中的位置 */ final int hash; /** * HashMap中保存的数据的key */ final K key; /** * HashMap中保存的数据的value */ V value; /** * 链表的下一个node */ Node&lt;K,V&gt; next; /** * 构造函数，设置hash，key，value，next */ Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + "=" + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125;&#125; TreeNodeTODO HashMap构造函数HashMap一共有四个构造函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 指定初始容量和加载因子的构造函数 */public HashMap(int initialCapacity, float loadFactor) &#123; // 判断初始容量是否小于0，是的话抛出参数非法的异常 if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); // 判断初始容量是否超过最大值，超过的话用最大值代替初始容量 if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; // 判断加载因子是否小于0或者是否是数字，小于0或者非数字就抛出参数非法的异常 if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); // 设置加载因子 this.loadFactor = loadFactor; // 将初始容量设置为最接近的2的幂次大小 this.threshold = tableSizeFor(initialCapacity);&#125;/** * 指定初始容量的构造函数 */public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;/** * 使用默认值的构造函数 */public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted&#125;/** * 通过一个Map创建HashMap的构造函数 */public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false);&#125; HashMap静态工具方法hash(Object key)1234567static final int hash(Object key) &#123; int h; // key为null的话返回0 // h = key.hashCode()：获取key的hashCode值 // h ^ (h &gt;&gt;&gt; 16)：利用hashCode的高16位与低16位进行异或，防止两个hashCode的高位不同，低位相同，导致hash碰撞 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; tab[i = (n - 1) &amp; hash]) 这是定位数组下标位置的一小段代码，其中n是数组的长度，hash是调用hash(Object key)方法返回的值。我们可以看到，这里使用数组长度减1然后与hash相与，获取数组下标。为什么要这么操作？ 当n始终是2的幂次时，(n - 1) &amp; hash相当于hash % n，即对hash取模。这也是hash算法中的除留余数法。 我们试一下数组长度为15和16，hashCode为4和5的情况下，计算数组下标的结果： 很明显，假设数组长度为15，hashCode为4和5的时候，会发生hash碰撞，会降低查询效率和空间利用率。 ps：这也是为什么HashMap容量必须是2的幂次的原因。 仔细想一下，如果hashCode二进制为0001 0001 0001 0001 0000 0000 0010 1011和0000 0000 0000 0000 0000 0000 0010 1011的情况时，进行(n - 1) &amp; hash，这样出来的下标是相同的。为了解决这个问题，HashMap使用hash(Object key)方法，进行高位异或运算，使得只有相同hash值的两个值才会被放到数组中的同一个位置上形成链表。 我们可以看一下下面的图： 综上所述：HashMap的hash过程是：获取key的hashCode -&gt; 高位异或运算 -&gt; 取模运算。 tableSizeFor(int cap)12345678910111213141516static final int tableSizeFor(int cap) &#123; // 防止cap已经是2的幂次，如果cap是2的幂次，不进行减1的话，最后的值会变成两倍的cap int n = cap - 1; // 使最高的1右边也确定为1，即有连续的两个1 n |= n &gt;&gt;&gt; 1; // 使最高的两个1右边也确定为两个1，即有连续的四个1 n |= n &gt;&gt;&gt; 2; // 使最高的四个1右边也确定为四个1，即有连续的八个1 n |= n &gt;&gt;&gt; 4; // 使最高的八个1右边也确定为八个1，即有连续的十六个1 n |= n &gt;&gt;&gt; 8; // 使最高的十六个1右边也确定为十六个1，即有连续的三十二个1 n |= n &gt;&gt;&gt; 16; // 加1，确保为2的幂次 return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125; 代码里的描述可能有点抽象，不容易理解，让我们举个例子看一下： 假设我们传入的cap为33，然后tableSizeFor方法的流程如下： HashMap提供的API方法： 方法名 方法解释 clear() 从HashMap中移除所有映射。 clone() 返回HashMap实例的浅表副本：key和value本身未被克隆。 compute( K key, BiFunction &lt;? super K,? super V,? extends V&gt; remappingFunction ) 根据key获取映射，如果存在将BiFunction的返回值设置为新的value，并返回新的value。如果获取不到映射，就设置新的映射。如果BiFunction的返回值为null，就删除该节点。 computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction) computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) 根据key获取映射，如果存在将BiFunction的返回值设置为新的value，并返回新的value。如果获取不到映射，就返回null。如果BiFunction的返回值为null，就删除该节点。 containsKey(Object key) 如果HashMap中包含指定key的映射，则返回true。 containsValue(Object value) 如果HashMap中包含指定value的一个或者多个映射，则返回true。 entrySet() 返回此HashMap中包含的映射的Set。 forEach(BiConsumer&lt;? super K, ? super V&gt; action) 对HashMap中的每个数据执行给定操作，直到处理完所有数据或操作抛出异常为止。 get(Object key) 返回指定key映射到的值;如果HashMap中不包含key的映射，则返回null。 getOrDefault(Object key, V defaultValue) 返回指定key映射到的值;如果HashMap中不包含key的映射，则返回defaultValue。 isEmpty() 判断HashMap是否为空。 keySet() 返回HashMap中包含的key的Set。 merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) 功能大部分与compute相同，不同之处在于BiFunction中apply的参数，入参为oldValue、value，调用merge时根据两个value进行处理并返回value。 put(K key, V value) 将key和value添加到HashMap。 putAll(Map&lt;? extends K, ? extends V&gt; m) 将指定Map中的所有映射复制到此HashMap。 putIfAbsent(K key, V value) 如果HashMap中key不存在，就保存key-value映射，并返回null；反之就返回已存在的value，并不覆盖为value。 remove(Object key) 从HashMap中删除指定key的映射，并返回value。 remove(Object key, Object value) 只有在指定key映射到指定value时，才删除该数据。 replace(K key, V value) 替换key映射的value。 replace(K key, V oldValue, V newValue) 只有在指定key映射到指定oldValue时，才替换成newValue。 replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) 对HashMap调用给定函数的结果替换每个数据的value，直到处理完所有数据或者该函数抛出异常。 size() 获取HashMap中的映射数量。 values() 返回HashMap中包含的value的集合。 HashMap重要方法put(K key, V value)123public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) onlyIfAbsent：如果为true，就不改变已存在的key对应的value，只有key不存在才会put。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 如果数组为空，进行扩容（设置数组tab和数组长度n） if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 定位数组下标，判断该位置是否null，如果为null，直接插入新节点（设置节点p和数组下标i） if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; // 如果定位到的节点hash和key与put的相同，后面会进行value覆盖（记录键k和节点e） if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 如果是红黑树节点，调用红黑树的putvalue方法 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 如果是链表节点 else &#123; // 遍历链表节点进行插入 for (int binCount = 0; ; ++binCount) &#123; // 如果定位到的节点的下一个节点为null，将该节点插入到定位到的节点之后 if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); // 判断是否达到转换为红黑树的长度，如果达到了就进行转换 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; // 如果定位到的节点hash和key与put的相同，后面会进行value覆盖（记录键k和节点e） if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; // 如果相同key的节点存在，就覆盖value，并返回旧值，操作次数不需要加1 if (e != null) &#123; // existing mapping for key V oldValue = e.value; // onlyIfAbsent为false或者旧值为null，进行覆盖 if (!onlyIfAbsent || oldValue == null) e.value = value; // HashMap定义了该方法，LinkedHashMap有实现 afterNodeAccess(e); return oldValue; &#125; &#125; // 操作次数加1 ++modCount; // k-v映射数量加1，如果超过扩容阈值，就进行扩容 if (++size &gt; threshold) resize(); // HashMap定义了该方法，LinkedHashMap有实现 afterNodeInsertion(evict); return null;&#125; resize() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102final Node&lt;K,V&gt;[] resize() &#123; // 获取旧数组 Node&lt;K,V&gt;[] oldTab = table; // 获取旧数组的长度 int oldCap = (oldTab == null) ? 0 : oldTab.length; // 获取旧的扩容阈值 int oldThr = threshold; int newCap, newThr = 0; // 如果旧数组不为null if (oldCap &gt; 0) &#123; // 如果旧数组的长度达到了最大值，就设置扩容阈值为Integer最大值，返回旧数组，不进行扩容 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 如果旧数组的长度没有达到最大值，并且将新的数组长度设置为旧数组的2倍没有超过最大值，以及旧数组长度大于默认值16 // 将新的扩容阈值设置为旧的2倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; // 如果旧数组为null，但是扩容阈值大于0（即new HashMap(int initialCapacity)后第一次put），将旧的扩容阈值设置为新数组的长度 else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; // 如果旧数组为null，且扩容阈值不大于0 else &#123; // zero initial threshold signifies using defaults // 设置默认长度和计算扩容阈值 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 只有前面else if的条件满足下面的判断，设置新的扩容阈值 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; // 设置扩容阈值 threshold = newThr; // 用新的数组长度初始化新的数组 @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; // 设置数组 table = newTab; // 如果旧数组不为null，将旧数组复制到新数组 if (oldTab != null) &#123; // 循环遍历 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; // 如果数组中的节点不为null，进行复制操作 if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; // 如果只是单一节点，计算在新数组中的下标，并进行赋值 if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; // 如果节点是红黑树，进行红黑树的操作，可能会触发红黑树转为链表的操作 else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); // 链表操作 else &#123; // preserve order // 将链表分为两组， // 扩容之后在原位置的节点列表 Node&lt;K,V&gt; loHead = null, loTail = null; // 扩容之后在原位置加上原数组长度位置的列表节点 Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; // 判断扩容之后hash新增的1bit是否是0 // 是的话添加到原位置节点列表 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; // 判断扩容之后hash新增的1bit是否是1 // 是的话添加到原位置加上原数组长度位置节点列表 else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 将列表复制到新数组 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; // 返回新数组 return newTab;&#125; 这样做的好处： TODO treeifyBin(Node&lt;K,V&gt;[] tab, int hash) 1234567891011121314151617181920212223242526final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123; int n, index; Node&lt;K,V&gt; e; // 判断数组是否为空，或者数组长度是否小于哈希桶（Node）转换为树（TreeNode）的最小容量，满足的话进行扩容，即还没达到转换为红黑树的大小 if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) resize(); // 达到了转为红黑树的大小，计算需要转换为红黑树的链表的数组下标 else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123; TreeNode&lt;K,V&gt; hd = null, tl = null; do &#123; //新建一个树形节点，内容和当前链表节点e一致 TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null); if (tl == null) //确定树头节点 hd = p; else &#123; p.prev = tl; tl.next = p; &#125; tl = p; &#125; while ((e = e.next) != null); //让数组的第一个元素指向新建的红黑树头结点，之后这个桶里的元素就是红黑树了 if ((tab[index] = hd) != null) // 塑造红黑树，前面的只是创建了一个二叉树，并没有设置颜色值 hd.treeify(tab); &#125;&#125; 红黑树相关操作 TODO put(K key, V value)流程： 如果数组为空，进行第一次扩容。 计算key的hash 定位数组的下标：hash &amp; (length – 1)。 如果该位置为null，插入新节点，操作计数，size+1，判断是否需要扩容，并返回null。 如果4不满足，判断该位置第一个节点的key是否与put的相符。 如果相符，就记录该节点。 如果不相符，判断该节点是否为红黑树。 如果该节点是红黑树，通过红黑树的方法进行put，记录返回节点。 如果该节点不是红黑树，就遍历列表，如果有key相符的节点，就记录该节点，如果没有就新增节点，并判断是否要转为红黑树。 判断记录节点是否为null 如果不为null，进行旧值覆盖，并返回旧值。 如果为null，操作计数，size+1，判断是否需要扩容，并返回null。 putIfAbsent(K key, V value)123public V putIfAbsent(K key, V value) &#123; return putVal(hash(key), key, value, true, true);&#125; onlyIfAbsent：为true，就不改变已存在的key对应的value，只有key不存在才会put。 putAll(Map&lt;? extends K, ? extends V&gt; m)123public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123; putMapEntries(m, true);&#125; putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) 12345678910111213141516171819202122final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123; int s = m.size(); if (s &gt; 0) &#123; // 如果HashMap数组为null，进行初始化扩容阈值 if (table == null) &#123; // pre-size float ft = ((float)s / loadFactor) + 1.0F; int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); if (t &gt; threshold) threshold = tableSizeFor(t); &#125; // 如果传入的Map的size大于扩容阈值，就进行扩容 else if (s &gt; threshold) resize(); // 遍历传入的Map，调用putVal进行添加k-v映射 for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123; K key = e.getKey(); V value = e.getValue(); putVal(hash(key), key, value, false, evict); &#125; &#125;&#125; HashMap(Map&lt;? extends K, ? extends V&gt; m)也调用了putMapEntries方法。 get(Object key)1234public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125; getNode(int hash, Object key) 12345678910111213141516171819202122232425final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; // 数组不为空，定位到的数组下标对应的节点不为空（设置数组tab，设置数组长度n，设置定位到的第一个节点first） if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; // 判断第一个节点与需要获取的key是否相同（包括hash值），是的话就返回第一个节点（设置k） if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; // 没满足上面的判断，并且第一个节点的下一个节点不为null if ((e = first.next) != null) &#123; // 如果是红黑树，通过红黑树的获取节点方式返回节点 if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); // 遍历链表，获取对应的节点并返回 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; // 查找不到返回null return null;&#125; 红黑树相关操作 TODO get(Object key)流程： 计算key的hash值。 定位数组的下标：hash &amp; (length – 1)。 返回key对应的值。其中查找节点流程： 如果定位到的数组下标的第一个节点与key相符，就返回该节点。 如果1没满足，判断是否是红黑树，如果是，则根据红黑树查找节点的方法返回节点。 如果2没满足，遍历链表，返回与key相符的节点。 如果3没满足，返回null。 getOrDefault(Object key, V defaultValue)12345public V getOrDefault(Object key, V defaultValue) &#123; Node&lt;K,V&gt; e; // 如果key不存在就返回默认值 return (e = getNode(hash(key), key)) == null ? defaultValue : e.value;&#125; remove(Object key)12345public V remove(Object key) &#123; Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;&#125; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; // 数组不为空，定位到的数组下标对应的节点不为空（设置数组tab，设置数组长度n，设置定位到的节点p） if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K,V&gt; node = null, e; K k; V v; // 如果p节点与需要remove的节点key相符，就记录为node if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; // p节点与需要remove的节点key不相符，并且p的下一个节点不为null else if ((e = p.next) != null) &#123; // 如果是红黑树，根据红黑树的获取节点方法，获取节点记录为node if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else &#123; // 遍历链表，查找key相符的节点，并记录为node do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; // 如果记录的node不为null，并且matchValue为false或记录的node的value与传入的value相符，就进行remove if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; // 如果记录的node为红黑树，就调用红黑树的remove方法，移除节点，可能会触发红黑树转为链表的操作 if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); // 如果记录的node是链表的第一个节点，将链表的第一个节点指向该节点的下一个节点 else if (node == p) tab[index] = node.next; else p.next = node.next; // 操作次数加1 ++modCount; // HashMap中的映射数减1 --size; // HashMap定义了该方法，LinkedHashMap有实现 afterNodeRemoval(node); // 返回移除的节点 return node; &#125; &#125; // 数组为空，返回null return null;&#125; 红黑树相关操作 TODO remove(Object key, Object value)123public boolean remove(Object key, Object value) &#123; return removeNode(hash(key), key, value, true, true) != null;&#125; replace(K key, V value)12345678910111213141516public V replace(K key, V value) &#123; Node&lt;K,V&gt; e; // 获取key对应的节点，如果不为null就进行替换 if ((e = getNode(hash(key), key)) != null) &#123; // 记录旧值 V oldValue = e.value; // 替换旧值 e.value = value; // HashMap定义了该方法，LinkedHashMap有实现 afterNodeAccess(e); // 返回旧值 return oldValue; &#125; // 如果不存在就返回null return null;&#125; replace(K key, V oldValue, V newValue)12345678910111213public boolean replace(K key, V oldValue, V newValue) &#123; Node&lt;K,V&gt; e; V v; // 获取key对应的节点，判断value是否相符，如果满足就进行替换 if ((e = getNode(hash(key), key)) != null &amp;&amp; ((v = e.value) == oldValue || (v != null &amp;&amp; v.equals(oldValue)))) &#123; // 替换旧值 e.value = newValue; // HashMap定义了该方法，LinkedHashMap有实现 afterNodeAccess(e); return true; &#125; return false;&#125; compute相关方法和mergeTODO HashMap引发死循环的情况HashMap在JDK1.8和JDK1.7中的对比总结通过这篇文章，我们可以知道一下几个点： HashMap是线程不安全的，所以如果我们在多线程下，需要使用Collections.synchronizedMap或者ConCurrentHashMap。 HashMap在JDK1.8中进行了很多优化，具体可以看HashMap在JDK1.8和JDK1.7中的对比这一节。 HashMap中链表转为红黑树，需要满足两个条件，一是链表长度&gt;=8，二是数组长度&gt;=64。 ps：有一些TODO的内容，后续有空了再进行添加。 欢迎关注博主其他的文章。]]></content>
      <categories>
        <category>Java</category>
        <category>Map</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内部类了解一下~]]></title>
    <url>%2F2017%2F01%2F21%2FJava%E5%86%85%E9%83%A8%E7%B1%BB%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[前言Java有四种内部类：成员内部类，局部内部类，静态内部类和匿名内部类。这篇文章主要分别说一下这四种内部类的特点。 内部类《Think in java》 中提到过，使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。 ps：利用匿名内部类，可以实现Java多继承；另一种是接口的多实现。 内部类是一个编译时的概念，一旦编译成功，就会成为完全不同的两类。对于一个名为OuterClass的外部类和其内部定义的InnerClass内部类。编译完成后出现OuterClass.class和OuterClass$InnerClass.class两个类文件。 关于内部类的new和this123456789101112131415161718192021public class OuterClass &#123; private String name; private class InnerClass &#123; private InnerClass(String name) &#123; // OuterClass.this 获取外部类的引用 OuterClass.this.name = name; &#125; private void print() &#123; System.out.println("name：" + name); &#125; &#125; public static void main(String[] args) &#123; OuterClass outerClass = new OuterClass(); // outerClass.new 创建内部类对象 OuterClass.InnerClass innerClass = outerClass.new InnerClass("yoga"); innerClass.print(); &#125;&#125; 上面这段代码的注释已经很清楚了，我们可以通过OuterClass.this获取外部类的引用，外部类对象通过.new来创建内部类。 成员内部类成员内部类是外部类的一个成员，与外部类的属性和方法的等级是一样的。它可以任意的访问外部类的属性和方法（包括private修饰的）；而外部类需要通过内部类实例来访问内部类的属性和方法。 特点 成员内部类不能包含任何static修饰的变量和方法。 成员内部类依附于外部类，所以需要先创建外部类再创建内部类。 代码示例12345678910111213141516171819public class MemberOuterClass &#123; private String name; private class MemberInnerClass &#123; private MemberInnerClass(String name) &#123; MemberOuterClass.this.name = name; &#125; private void print() &#123; System.out.println("name：" + name); &#125; &#125; public static void main(String[] args) &#123; MemberOuterClass memberOuterClass = new MemberOuterClass(); MemberOuterClass.MemberInnerClass memberInnerClass = memberOuterClass.new MemberInnerClass("yoga"); memberInnerClass.print(); &#125;&#125; 局部内部类局部内部类定义在方法中的内部类，与局部变量有点类似。局部内部类前面不加private，public修饰符。 特点 作用域为定义该局部内部类的代码块。 局部内部类不可以定义静态变量。 如果在静态方法中：可以访问外部类中所有静态成员，包含私有；如果在实例方法中：可以访问外部类中所有的成员，包含私有。 局部内部类可以访问所在方法中定义的局部变量，但是要求局部变量必须使用final修饰 。 代码示例123456789101112131415161718192021222324252627282930313233public class LocalOuterClass &#123; private String name = "yoga"; private static int age = 2; private void test1() &#123; final String sex = "male"; class LocalInner &#123; private void print() &#123; System.out.println("name : " + name); System.out.println("age : " + age); System.out.println("sex : " + sex); &#125; &#125; new LocalInner().print(); &#125; static private void test2() &#123; final String address = "HangZhou"; class LocalInner &#123; private void print() &#123; // System.out.println("name : " + name); 无法访问private属性 System.out.println("age : " + age); System.out.println("address : " + address); &#125; &#125; new LocalInner().print(); &#125; public static void main(String[] args) &#123; LocalOuterClass.test2(); new LocalOuterClass().test1(); &#125;&#125; 匿名内部类匿名内部类是没有名字的局部内部类。没有修饰符。 特点 没有构造器。 代码示例12345678910public class OuterClass &#123; public static void main(String[] args) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("匿名内部类"); &#125; &#125;).start(); &#125;&#125; 静态内部类静态内部类是声明在外部类内，方法体外，并且使用static修饰的内部类 。 特点 它的创建是不需要依赖于外围类的： 在外部类的外部构建内部类的实例：new Outer.Inner()； 在外部类的内部构建内部类的实例：new Inner(); 它不能使用任何外围类的非static成员变量和方法。 代码示例1234567891011121314151617181920212223public class StaticOuterClass &#123; private static String name = "yoga"; private int age; /** * 静态内部类 */ static class StaticInnerClass &#123; /** * 定义在静态内部类中的静态属性 */ public static String sex = "male"; public static void print() &#123; System.out.println("name：" + name); &#125; &#125; public static void main(String[] args) &#123; StaticOuterClass staticOuterClass = new StaticOuterClass(); StaticInnerClass.print(); &#125;&#125; 欢迎关注博主其他的文章。]]></content>
      <categories>
        <category>Java</category>
        <category>内部类</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkedList源码了解一下~]]></title>
    <url>%2F2017%2F01%2F20%2FLinkedList%E6%BA%90%E7%A0%81%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[前言LinkedList是我们比较常用的数据类型之一，也是面试中比较容易问到的集合之一。本篇文章主要通过分析LinkedList的源码。 LinkedList简介LinkedList是基于双向循环链表实现的，它的头结点不存放数据。 LinkedList类结构 可以从上图看出，LinkedList继承AbstractSequentialList抽象类，实现了List，Deque，Cloneable，Serializable接口。 LinkedList特点 LinkedList非线程安全。 LinkedList允许插入null。 LinkedList中的数据存储是有序的。 LinkedList中的数据可以重复。 LinkedList源码LinkedList成员变量1234567891011121314/** * LinkedList大小 */transient int size = 0;/** * LinkedList链表的头节点 */transient Node&lt;E&gt; first;/** * LinkedList链表的尾节点 */transient Node&lt;E&gt; last; LinkedList内部类Node1234567891011121314private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; // 当前节点的值 this.item = element; // 后一个节点 this.next = next; // 前一个节点 this.prev = prev; &#125;&#125; LinkedList构造函数LinkedList一共有两个构造函数 1234567891011121314/** * 无参构造函数。 */public LinkedList() &#123;&#125;/** * 通过Collection创建LinkedList。 */public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); // 调用addAll方法，将集合添加到LinkedList中 addAll(c);&#125; LinkedList提供的API 方法名 方法解释 add(E e) add(int index, E element) LinkedList重要方法add(E e)123456public boolean add(E e) &#123; // 将节点链接到LinkedList最后 linkLast(e); // 返回添加成功的结果 return true;&#125; linkLast(E e) 123456789101112131415161718void linkLast(E e) &#123; // 获取之前的尾节点 final Node&lt;E&gt; l = last; // 根据e创建新的节点，该节点的前一个节点为之前的尾节点，后一个节点为null final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); // 将新的节点设置为尾节点 last = newNode; // 如果之前的尾节点为null，则新增的节点也是头节点 if (l == null) first = newNode; // 如果之前的尾节点不为null，将之前的尾节点的下一个节点设置为新的节点 else l.next = newNode; // LinkedList大小加1 size++; // 操作次数加1 modCount++;&#125; add(E e)流程： 保存原来的尾节点 将需要插入的元素包装成新的节点，该节点的前一个节点为原来的尾节点，后一个节点为null 将新的节点设置为尾节点 如果原来的尾节点为null，则设置新的节点为头节点 如果原来的尾节点不为null，将原来节点的下一个节点设置为新的节点 LinkedList大小加1，操作次数加1，并返回成功 add(int index, E element)1234567891011public void add(int index, E element) &#123; // 检查定位是否越界 checkPositionIndex(index); // 如果定位是最后一个节点，就将节点链接到最后 if (index == size) linkLast(element); // else linkBefore(element, node(index));&#125; checkPositionIndex(int index) 12345private void checkPositionIndex(int index) &#123; // 如果定位越界，抛出越界异常 if (!isPositionIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125; isPositionIndex(int index) 1234private boolean isPositionIndex(int index) &#123; // 返回定位是否越界 return index &gt;= 0 &amp;&amp; index &lt;= size;&#125; node(int index) 12345678910111213141516Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); // 判断定位是否小于LinkedList大小的一半，是的话，从头节点开始遍历，不是话从尾节点开始遍历 if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; linkBefore(E e, Node succ) 12345678910111213141516171819void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; // 记录定位到的节点的前一个节点 final Node&lt;E&gt; pred = succ.prev; // 根据e创建新的节点，新节点的前一个节点为定位到的节点的前一个节点，后一个节点为定位到的节点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); // 设置定位到的节点前一个节点为新的节点 succ.prev = newNode; // 如果定位到的节点的前一个节点为null，则新的节点为头节点 if (pred == null) first = newNode; // 如果定位到的节点的前一个节点不为null，将前一个节点的下一个节点设置为新的节点 else pred.next = newNode; // LinkedList大小加1 size++; // 操作次数加1 modCount++;&#125; addAll(Collection&lt;? extends E&gt; c)123public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c);&#125; addAll(int index, Collection&lt;? extends E&gt; c)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; // 判断定位是否越界 checkPositionIndex(index); // 将c转换为数组 Object[] a = c.toArray(); // 获取数组长度 int numNew = a.length; // 如果数组为0，返回false if (numNew == 0) return false; Node&lt;E&gt; pred, succ; // 如果插入的位置为尾部，succ为null，前一个节点为之前的尾节点 if (index == size) &#123; succ = null; pred = last; &#125; else &#123; // 如果插入的位置不是尾部，succ为定位的节点，前一个节点为定位到的节点的前一个节点 succ = node(index); pred = succ.prev; &#125; // 遍历数组进行添加 for (Object o : a) &#123; @SuppressWarnings("unchecked") E e = (E) o; // 根据e创建新的节点，新节点的前一个节点为前面获取的pred节点，后一个节点为null Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); // 如果前一个节点null，则新节点为头节点 if (pred == null) first = newNode; // 如果前一个节点不为null，设置前一个节点的后一个节点为新节点 else pred.next = newNode; // 将新节点设置为pred节点 pred = newNode; &#125; // 如果succ节点为null，前面循环添加的最后一个节点为尾节点 if (succ == null) &#123; last = pred; &#125; else &#123; // 如果succ节点不为null，设置前面循环添加的最后一个节点的后一个节点为succ节点，succ节点的前一个节点为pred节点 pred.next = succ; succ.prev = pred; &#125; // 增加LinkedList的大小 size += numNew; // 操作次数加1 modCount++; // 返回true return true;&#125; contains(Object o)1234public boolean contains(Object o) &#123; // 根据匹配方法返回的元素下标判断是否存在该对象 return indexOf(o) != -1;&#125; indexOf(Object o) 12345678910111213141516171819public int indexOf(Object o) &#123; int index = 0; // 如果匹配对象为null，遍历LinkedList，使用==进行匹配，并返回位置；如果匹配对象不为null，遍历LinkedList，使用equals进行匹配，并返回位置 if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; index++; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; index++; &#125; &#125; // 匹配不到，返回-1 return -1;&#125; get(int index)123456public E get(int index) &#123; // 判断定位是否越界 checkElementIndex(index); // 获取节点中的内容 return node(index).item;&#125; get(int index)流程： 判断定位是否越界 调用node方法，获取节点 返回节点的内容 remove(int index)123456public E remove(int index) &#123; // 判断定位是否越界 checkElementIndex(index); // 删除节点 return unlink(node(index));&#125; unlink(Node x) 1234567891011121314151617181920212223242526272829303132333435363738E unlink(Node&lt;E&gt; x) &#123; // assert x != null; // 获取节点的内容 final E element = x.item; // 获取定位到的节点的后一个节点 final Node&lt;E&gt; next = x.next; // 获取定位到的节点的前一个节点 final Node&lt;E&gt; prev = x.prev; // 如果前一个节点为null，将头节点设置为后一个节点 if (prev == null) &#123; first = next; &#125; else &#123; // 如果前一个节点不为null，将前一个节点的下一个节点设置为定位到的节点的下一个节点 prev.next = next; // 将定位到的节点的前一个节点设置为null x.prev = null; &#125; // 如果后一个节点为null，将尾节点设置为前一个节点 if (next == null) &#123; last = prev; &#125; else &#123; // 如果后一个节点不为null，将后一个节点的前一个节点设置为定位到的节点的前一个节点 next.prev = prev; // 将定位到的节点的后一个节点设置为null x.next = null; &#125; // 将定位到的节点的内容设置null x.item = null; // LinkedList大小减1 size--; // 操作次数加1 modCount++; // 返回定位到的节点的原内容 return element;&#125; remove(Object o)123456789101112131415161718public boolean remove(Object o) &#123; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false;&#125; fastRemove(int index) 123456789101112private void fastRemove(int index) &#123; // 操作加1 modCount++; // 计算需要向左移动的元素数量 int numMoved = size - index - 1; // 如果要移动的数量大于0，进行相关的复制 if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); // 将数组最后一位元素置为null，并且大小减1 elementData[--size] = null; // clear to let GC do its work&#125; removeAll(Collection&lt;?&gt; c)123456public boolean removeAll(Collection&lt;?&gt; c) &#123; // 判断是否为null，如果为null，抛出空指针异常 Objects.requireNonNull(c); // 批量删除 return batchRemove(c, false);&#125; batchRemove(Collection&lt;?&gt; c, boolean complement) 12345678910111213141516171819202122232425262728private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; final Object[] elementData = this.elementData; int r = 0, w = 0; boolean modified = false; try &#123; for (; r &lt; size; r++) if (c.contains(elementData[r]) == complement) elementData[w++] = elementData[r]; &#125; finally &#123; // Preserve behavioral compatibility with AbstractCollection, // even if c.contains() throws. if (r != size) &#123; System.arraycopy(elementData, r, elementData, w, size - r); w += size - r; &#125; if (w != size) &#123; // clear to let GC do its work for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w; size = w; modified = true; &#125; &#125; return modified;&#125; 总结]]></content>
      <categories>
        <category>Java</category>
        <category>Collection</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList源码解析了解一下~]]></title>
    <url>%2F2017%2F01%2F19%2FArrayList%E6%BA%90%E7%A0%81%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[前言ArrayList是我们最常使用的数据类型之一，也是面试中最容易问到的集合之一。本篇文章主要通过分析ArrayList的源码，更深入的了解ArrayList，ArrayList在JDK1.8中添加了一些新的方法。 本文基于jdk1.8 ArrayList简介ArrayList底层是一个数组，它的容量可以动态增长。 ArrayList类结构 可以从上图看出，ArrayList继承AbstractList抽象类，实现了List，Cloneable，Serializable，RandomAccess接口。 ArrayList特点 ArrayList非线程安全，在多线程中保证线程安全的解决方法：使用CopyOnWriteArrayList，Vector，List list = Collections.synchronizedList(new ArrayList());。 ArrayList允许插入null。 ArrayList中的数据存储是有序的。 ArrayList中的数据可以重复。 ArrayList源码ArrayList常量属性12345678910111213141516171819/** * 初始化容量为10 */private static final int DEFAULT_CAPACITY = 10;/** * ArrayList容量指定为0时，返回该空数组 */private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;/** * 默认返回的空数组，用户调用无参构造函数，刚创建一个ArrayList时，内部大小为0，返回的是该空数组 */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;/** * ArrayList数组的最大值，-8是因为有些版本的虚拟机会保留8个字节长度的header */private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; ArrayList成员变量123456789/** * ArrayList元素保存的数组 */transient Object[] elementData;/** * ArrayList大小 */private int size; ArrayList内部类ArrayListSpliteratorTODO ArrayList构造函数ArrayList一共有三个构造函数 12345678910111213141516171819202122232425262728293031323334353637383940/** * 指定一个初始容量的构造函数。 */public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; // 指定了初始容量为0，数组就是EMPTY_ELEMENTDATA this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125;&#125;/** * 无参构造函数，构造一个初始容量为默认值10的ArrayList。 */public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;/** * 通过Collection创建ArrayList。 */public ArrayList(Collection&lt;? extends E&gt; c) &#123; // 将参数c转为数组 elementData = c.toArray(); // 判断数组是否为空，并且设置ArrayList的大小 if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) // 判断数组的类型是否是Object if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. // 空的数组 this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; ArrayList提供的API 方法名 方法解释 add(E e) add(int index, E element) ArrayList重要方法arraycopy(Object src, int srcPos, Object dest, int destPos, int length)123public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); 该方法是native修饰的，由C/C++来编写的。 参数解释： 参数名 参数解释 src 源数组，即被复制的数组 srcPos 源数组被复制的起始位置 dest 目标数组，即源数组的元素会被复制到该数组 destPos 元素放置在目标数组的起始位置 length 复制的长度 add(E e)12345678public boolean add(E e) &#123; // 尝试容量加1，计算需要的最小容量 ensureCapacityInternal(size + 1); // Increments modCount!! // 向数组中添加元素，大小加1 elementData[size++] = e; // 返回成功 return true;&#125; ensureCapacityInternal(int minCapacity) 123private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125; calculateCapacity(Object[] elementData, int minCapacity) 12345678private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; // 判断是否为空数组 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; // 获取最小的容量 return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity;&#125; ensureExplicitCapacity(int minCapacity) 123456789private void ensureExplicitCapacity(int minCapacity) &#123; // 操作次数加1 modCount++; // overflow-conscious code // 需要的最小容量比数组的长度大，就调用grow()进行扩容 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125; grow(int minCapacity) 12345678910111213141516private void grow(int minCapacity) &#123; // overflow-conscious code // 获取原数组长度 int oldCapacity = elementData.length; // 新的大小为原数组的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 如果新的大小还是小于需要的容量大小，将需要的容量大小设置为新的大小 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; // 设置最大值 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: // 扩容之后进行复制 elementData = Arrays.copyOf(elementData, newCapacity);&#125; hugeCapacity(int minCapacity) 1234567private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; copyOf(T[] original, int newLength) 123public static &lt;T&gt; T[] copyOf(T[] original, int newLength) &#123; return (T[]) copyOf(original, newLength, original.getClass());&#125; copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) 12345678910public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; // 获取目标数组 @SuppressWarnings("unchecked") T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy;&#125; add(E e)流程： 计算需要最小的数组容量 操作次数加1 判断计算出来的容量是否大于原数组的长度 如果计算出来的容量大，就进行扩容 扩容是将原数组扩大到1.5倍 最后进行添加元素操作，ArrayList大小加1，并返回成功 add(int index, E element)1234567891011121314public void add(int index, E element) &#123; // 判断下标是否越界 rangeCheckForAdd(index); // 尝试容量加1，计算需要的最小容量 ensureCapacityInternal(size + 1); // Increments modCount!! // 将下标之后的数据都往右移动一位 System.arraycopy(elementData, index, elementData, index + 1, size - index); // 添加元素 elementData[index] = element; // 大小加1 size++;&#125; rangeCheckForAdd(int index) 12345private void rangeCheckForAdd(int index) &#123; // 判断下标是否越界 if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125; addAll(Collection&lt;? extends E&gt; c)1234567891011121314public boolean addAll(Collection&lt;? extends E&gt; c) &#123; // 将集合转换为数组 Object[] a = c.toArray(); // 集合转换为的数组的长度 int numNew = a.length; // 尝试容量加1，计算需要的最小容量 ensureCapacityInternal(size + numNew); // Increments modCount // 将转换为的数组添加到ArrayList数组的后面 System.arraycopy(a, 0, elementData, size, numNew); // 增加数组大小 size += numNew; // 返回结果 return numNew != 0;&#125; addAll(int index, Collection&lt;? extends E&gt; c)12345678910111213141516171819202122232425public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; // 判断下标是否越界 rangeCheckForAdd(index); // 将集合转换为数组 Object[] a = c.toArray(); // 集合转换为的数组的长度 int numNew = a.length; // 尝试容量加1，计算需要的最小容量 ensureCapacityInternal(size + numNew); // Increments modCount // 计算需要向右移动的元素数量 int numMoved = size - index; // 如果需要移动的数量大于0，进行相关的移动 if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); // 将集合转换的数组添加到ArrayList中 System.arraycopy(a, 0, elementData, index, numNew); // 增加ArrayList大小 size += numNew; // 返回结果 return numNew != 0;&#125; contains(Object o)1234public boolean contains(Object o) &#123; // 根据匹配方法返回的元素下标判断是否存在该对象 return indexOf(o) &gt;= 0;&#125; indexOf(Object o) 123456789101112131415public int indexOf(Object o) &#123; if (o == null) &#123; // 判断的对象为null，遍历数组，返回匹配到的下标 for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; // 判断的对象不为null，遍历数组，返回匹配到的下标 for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; // 没有匹配到返回-1 return -1;&#125; get(int index)1234567public E get(int index) &#123; // 判断下标是否越界 rangeCheck(index); // 返回查找的元素 return elementData(index);&#125; elementData(int index) 1234E elementData(int index) &#123; // 返回数组中的元素 return (E) elementData[index];&#125; get(int index)流程： 判断数组下标是否越界 根据下标获取数组中的元素 remove(int index)12345678910111213141516171819202122public E remove(int index) &#123; // 判断下标是否越界 rangeCheck(index); // 操作次数加1 modCount++; // 获取下标匹配的数组元素 E oldValue = elementData(index); // 计算需要移动的元素数量 int numMoved = size - index - 1; // 如果需要向左移动的数量大于0，就进行相关的移动 if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); // 将数组最后一位元素置为null，并且大小减1 elementData[--size] = null; // clear to let GC do its work // 返回原来的元素 return oldValue;&#125; remove(Object o)1234567891011121314151617181920public boolean remove(Object o) &#123; // 如果需要移除的元素为null if (o == null) &#123; // 遍历数组进行匹配，并删除，返回true for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; // 遍历数组进行匹配，并删除，返回true for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; // 返回false return false;&#125; fastRemove(int index) 123456789101112private void fastRemove(int index) &#123; // 操作加1 modCount++; // 计算需要向左移动的元素数量 int numMoved = size - index - 1; // 如果要移动的数量大于0，进行相关的复制 if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); // 将数组最后一位元素置为null，并且大小减1 elementData[--size] = null; // clear to let GC do its work&#125; removeAll(Collection&lt;?&gt; c)123456public boolean removeAll(Collection&lt;?&gt; c) &#123; // 判断是否为null，如果为null，抛出空指针异常 Objects.requireNonNull(c); // 批量删除 return batchRemove(c, false);&#125; batchRemove(Collection&lt;?&gt; c, boolean complement) 1234567891011121314151617181920212223242526272829private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; // 获取ArrayList数组 final Object[] elementData = this.elementData; int r = 0, w = 0; boolean modified = false; try &#123; for (; r &lt; size; r++) if (c.contains(elementData[r]) == complement) elementData[w++] = elementData[r]; &#125; finally &#123; // Preserve behavioral compatibility with AbstractCollection, // even if c.contains() throws. if (r != size) &#123; System.arraycopy(elementData, r, elementData, w, size - r); w += size - r; &#125; if (w != size) &#123; // clear to let GC do its work for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w; size = w; modified = true; &#125; &#125; return modified;&#125; removeIf(Predicate&lt;? super E&gt; filter)TODO replaceAll(UnaryOperator operator)123456789101112131415161718public void replaceAll(UnaryOperator&lt;E&gt; operator) &#123; // 判断操作方法是否为null Objects.requireNonNull(operator); // 设置预期操作次数 final int expectedModCount = modCount; // 设置大小 final int size = this.size; // 遍历ArrayList，对每一个元素进行操作 for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; elementData[i] = operator.apply((E) elementData[i]); &#125; // 在调用该方法的时候，ArrayList的操作次数改变了，就抛出并发异常 if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; // 操作次数加1 modCount++;&#125; set(int index, E element)1234567891011public E set(int index, E element) &#123; // 判断下标是否越界 rangeCheck(index); // 获取下标对应的元素 E oldValue = elementData(index); // 将新的元素设置到下标位置 elementData[index] = element; // 返回旧的值 return oldValue;&#125; sort(Comparator&lt;? super E&gt; c)123456789101112public void sort(Comparator&lt;? super E&gt; c) &#123; // 设置预期操作次数 final int expectedModCount = modCount; // 调用Arrays的排序 Arrays.sort((E[]) elementData, 0, size, c); // 在调用该方法的时候，ArrayList的操作次数改变了，就抛出并发异常 if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; // 操作次数加1 modCount++;&#125; trimToSize()12345678910public void trimToSize() &#123; // 操作次数加1 modCount++; // 判断ArrayList大小是否小于数组的长度，是的话就去除数组中空的值 if (size &lt; elementData.length) &#123; elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125;&#125; 为什么ArrayList不能在for-each循环中删除元素for-each循环时，会调用ArrayList的内部类Itr的hashNext方法进行判断是否还有下一个元素需要遍历。 hasNext()1234public boolean hasNext() &#123; // 判断元素下标是否与ArrayList大小相同 return cursor != size;&#125; 可以看出若删除前面的元素，此处就会为true ps：删除倒数第二个元素，cursor就是最后一个索引值size()-1 ，size也-1了，此处会返回false，不会调用next方法了（即不存在操作次数的判断）。所以可以删除倒数第二个元素。 如果hashNext方法返回true，就会继续调用next方法获取下一个元素。 next()1234567891011121314151617public E next() &#123; // 判断操作次数与预期的是否相同 checkForComodification(); // 获取元素下标 int i = cursor; // 判断元素下标是否越界 if (i &gt;= size) throw new NoSuchElementException(); // 获取ArrayList元素 Object[] elementData = ArrayList.this.elementData; // 判断是否有删除操作 if (i &gt;= elementData.length) throw new ConcurrentModificationException(); // 获取元素 cursor = i + 1; return (E) elementData[lastRet = i];&#125; 我们看一下checkForComodification方法： 1234final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException();&#125; 这里的modCount经过remove之后，已经+1了，所以这里的modCount和expectModCount肯定不相等，所以会抛出ConcurrentModificationException异常。 总结通过这篇文章，我们对ArrayList进行了更深入的了解，这有利于我们之后使用ArrayList。可以避免遇到一些坑。 ps：有一些TODO的内容，后续有空了再进行添加。 欢迎关注博主其他的文章。]]></content>
      <categories>
        <category>Java</category>
        <category>Collection</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
