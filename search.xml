<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[漏桶算法与令牌桶算法简介]]></title>
    <url>%2F2018%2F03%2F26%2F%E6%BC%8F%E6%A1%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[前言我们项目中的API接口都是有访问上限的，当访问频率或者并发量超过其承受范围时，我们就必须考虑限流来保证接口的可用性。防止非预期的请求对系统压力过大而引起的系统瘫痪。本篇文章会介绍限流算法中比较常见的漏桶算法和令牌桶算法。 漏桶算法]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>限流算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eureka源码—EurekaServer]]></title>
    <url>%2F2018%2F03%2F23%2FEureka%E6%BA%90%E7%A0%81%E2%80%94EurekaServer%2F</url>
    <content type="text"><![CDATA[前言本篇文章主要解读Eureka-Server初始化的相关源码，文章较长，请谨慎点击！ EurekaServerConfigEurekaServerConfig简介所属包：com.netflix.eureka.EurekaSeverConfig，Eureka-Server配置接口。 EurekaServerConfig源码博主已添加中文注释，点击查看。 EurekaServerConfig重要属性或者重要方法 自我保护相关： shouldEnableSelfPreservation()：是否开启自我保护机制，默认为true。 getRenewalPercentThreshold()：自我保护百分比阈值，超过这个值就会开启自我保护模式。默认为0.85。 getRenewalThresholdUpdateIntervalMs（）:自我保护阈值更新的时间间隔，单位为毫秒（ms）。默认为 15 * 60 * 1000 ms。 注册信息相关： getWaitTimeInMsWhenSyncEmpty()：如果eureka在启动的时候，获取不到注册信息，就等待。单位为毫秒（ms）。默认为 1000 * 60 * 5 ms。 getPeerNodeConnectTimeoutMs()：eureka集群节点之间请求连接超时的时间（进行复制信息操作），单位为毫秒（ms）。默认为 1000 ms。 getPeerNodeReadTimeoutMs()：eureka集群节点之间请求读取超时的时间（进行复制信息操作），单位为毫秒（ms），默认为 5000 ms。 getRetentionTimeInMSInDeltaQueue()：获取增量信息缓存的时间，以避免客户端检索的时候丢失，单位为毫秒。默认为 30 * 60 * 1000 ms。 getDeltaRetentionTimerIntervalInMs()：获取清理过期的增量信息任务应唤醒的时间间隔，单位为毫秒。默认为 30 * 1000 ms。 shouldDisableDelta()：是否可以将增量信息提供给客户端，默认为false。 shouldSyncWhenTimestampDiffers()：否同步应用实例信息，当应用实例信息最后更新时间戳( lastDirtyTimestamp )发生改变。默认为true。 getRegistrySyncRetries()：获取eureka服务器启动时，从远程 Eureka-Server 读取失败重试次数。默认为5。 getRegistrySyncRetryWaitMs()：Eureka-Server 启动时，从远程 Eureka-Server 读取注册信息失败，再次尝试获取的等待( sleep )间隔，单位为毫秒，默认为30 * 1000 ms。 shouldDisableDeltaForRemoteRegions()：是否将增量信息提供给客户端或远程区域，默认为false。 getRemoteRegionConnectTimeoutMs()：获取连接到远程Eureka-Server的超时时间，单位为毫秒，默认为2000ms。 getRemoteRegionReadTimeoutMs()：获取读取远程Eureka-Server的超时时间，单位为毫秒，默认为5000ms。 getRemoteRegionUrlsWithName()：获取远程Eureka-Server的地址，key为Eureka-server名，value为Eureka-Server地址。 getRemoteRegionAppWhitelist(@Nullable String regionName)：获取远程Eureka-Server获取注册的Applications集合。 getRemoteRegionRegistryFetchInterval()：获取从远程Eureka-Server获取注册信息的时间间隔，单位为秒，默认为30s。 限流相关： isRateLimiterEnabled()：是否开启请求限流，默认为false。 isRateLimiterThrottleStandardClients()：是否限制非标准客户端的访问，默认为false。标准客户端通过请求头的 DiscoveryIdentity-Name 来判断，是否在标准客户端名集合里。 getRateLimiterPrivilegedClients()：获取标准客户端名集合。标准客户端名集合。默认包含DefaultClient 和 DefaultServer 。 getRateLimiterBurstSize()：速率限制的burst size，默认为10。令牌桶算法。 getRateLimiterRegistryFetchAverageRate()：指定增量获取注册信息的平均执行注册请求速率，默认为500。 getRateLimiterFullFetchAverageRate()：指定全量获取注册信息的平均执行注册请求速率，默认为100。 getEvictionIntervalTimerInMs()：租约过期定时任务执行频率，单位为毫秒。默认为 60 * 1000 ms。 DefaultEurekaServerConfigDefaultEurekaServerConfig所属包：com.netflic.eureka.DefaultEurekaServerConfig，基于配置文件的Eureka-Server配置实现类。 DefaultEurekaServerConfig源码博主已添加中文注释，点击查看。 DefaultEurekaServerConfig重要属性或者重要方法 其他实现方法基本类似，都是从配置文件中获取值，举一个例子： shouldEnableSelfPreservation()：是否开启自我保护模式，并传一个默认值（这里是true）。 EurekaBootStrap EurekaBootStrap简介所属包：com.netflix.eureka.EurekaBootStrap，Eureka-Server启动入口。EurekaBootStrap 实现了 javax.servlet.ServletContextListener 接口，在 Servlet 容器( 例如 Tomcat、Jetty )启动时，调用 contextInitialized() 方法，初始化 Eureka-Server 。源码如下： 12345678910111213141516171819public class EurekaBootStrap implements ServletContextListener &#123; // 省略部分代码 @Override public void contextInitialized(ServletContextEvent event) &#123; try &#123; // 初始化Eureka配置环境 initEurekaEnvironment(); // 初始化Eureka-Server上下文 initEurekaServerContext(); ServletContext sc = event.getServletContext(); sc.setAttribute(EurekaServerContext.class.getName(), serverContext); &#125; catch (Throwable e) &#123; logger.error("Cannot bootstrap eureka server :", e); throw new RuntimeException("Cannot bootstrap eureka server :", e); &#125; &#125; // 省略部分代码&#125; EurekaBootStrap源码博主已添加中文注释，点击查看。 EurekaBootStrap重要属性或者重要方法 Eureka-Server上下文相关： com.netflix.eureka.EurekaServerContext：Eureka-Server上下文接口，包含了初始化，关闭，获取EurekaServer配置对象，获取集群节点集合，获取编解码器，获取应用实例注册表，获取应用信息管理器这些方法。源码如下： 1234567891011121314151617public interface EurekaServerContext &#123; void initialize() throws Exception; void shutdown() throws Exception; EurekaServerConfig getServerConfig(); PeerEurekaNodes getPeerEurekaNodes(); ServerCodecs getServerCodecs(); PeerAwareInstanceRegistry getRegistry(); ApplicationInfoManager getApplicationInfoManager();&#125; com.netflix.eureka.DefaultEurekaServerContext：Eureka-Server上下文默认实现类，源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586@Singletonpublic class DefaultEurekaServerContext implements EurekaServerContext &#123; private static final Logger logger = LoggerFactory.getLogger(DefaultEurekaServerContext.class); /** * Eureka-Server配置对象 */ private final EurekaServerConfig serverConfig; /** * 编解码器 */ private final ServerCodecs serverCodecs; /** * 应用实例信息注册表 */ private final PeerAwareInstanceRegistry registry; /** * Eureka-Server集群节点集合 */ private final PeerEurekaNodes peerEurekaNodes; /** * 应用信息管理器 */ private final ApplicationInfoManager applicationInfoManager; @Inject public DefaultEurekaServerContext(EurekaServerConfig serverConfig, ServerCodecs serverCodecs, PeerAwareInstanceRegistry registry, PeerEurekaNodes peerEurekaNodes, ApplicationInfoManager applicationInfoManager) &#123; this.serverConfig = serverConfig; this.serverCodecs = serverCodecs; this.registry = registry; this.peerEurekaNodes = peerEurekaNodes; this.applicationInfoManager = applicationInfoManager; &#125; @PostConstruct @Override public void initialize() throws Exception &#123; logger.info("Initializing ..."); // 启动Eureka-Server集群节点集合 peerEurekaNodes.start(); // 初始化应用实例信息注册表 registry.init(peerEurekaNodes); logger.info("Initialized"); &#125; @PreDestroy @Override public void shutdown() throws Exception &#123; logger.info("Shutting down ..."); // 关闭应用实例信息注册表 registry.shutdown(); // 关闭Eureka-Server集群节点集合 peerEurekaNodes.shutdown(); logger.info("Shut down"); &#125; @Override public EurekaServerConfig getServerConfig() &#123; return serverConfig; &#125; @Override public PeerEurekaNodes getPeerEurekaNodes() &#123; return peerEurekaNodes; &#125; @Override public ServerCodecs getServerCodecs() &#123; return serverCodecs; &#125; @Override public PeerAwareInstanceRegistry getRegistry() &#123; return registry; &#125; @Override public ApplicationInfoManager getApplicationInfoManager() &#123; return applicationInfoManager; &#125;&#125; com.netflix.eureka.EurekaServerContextHolder：Eureka-Server上下文持有者，可以通过它获取上下文，源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class EurekaServerContextHolder &#123; /** * Eureka-Server上下文 */ private final EurekaServerContext serverContext; private EurekaServerContextHolder(EurekaServerContext serverContext) &#123; this.serverContext = serverContext; &#125; /** * 获取Eureka-Server上下文 * * @return Eureka-Server上下文 */ public EurekaServerContext getServerContext() &#123; return this.serverContext; &#125; /** * Eureka-Server上下文持有者 */ private static EurekaServerContextHolder holder; /** * 初始化 * * @param serverContext Eureka-Server上下文 */ public static synchronized void initialize(EurekaServerContext serverContext) &#123; holder = new EurekaServerContextHolder(serverContext); &#125; /** * 获取Eureka-Server上下文持有者 * * @return Eureka-Server上下文持有者 */ public static EurekaServerContextHolder getInstance() &#123; return holder; &#125;&#125; StatusFilterStatusFilter简介所属包：com.netflix.eureka.StatusFilter，根据InstanceStatus过滤Eureka-Server。当 Eureka-Server 未处于开启( InstanceStatus.UP )状态，返回 HTTP 状态码 307 重定向 。 StatusFilter源码123456789101112public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; InstanceInfo myInfo = ApplicationInfoManager.getInstance().getInfo(); InstanceStatus status = myInfo.getStatus(); if (status != InstanceStatus.UP &amp;&amp; response instanceof HttpServletResponse) &#123; HttpServletResponse httpRespone = (HttpServletResponse) response; httpRespone.sendError(SC_TEMPORARY_REDIRECT, "Current node is currently not ready to serve requests -- current status: " + status + " - try another DS node: "); &#125; chain.doFilter(request, response);&#125; ServerRequestAuthFilterServerRequestAuthFilter简介所属包：com.netflix.eureka.ServerRequestAuthFilter，用于客户端请求的身份验证过滤器。目前，它只记录来自标题信息的支持的客户端标识数据。 ServerRequestAuthFilter源码1234567891011121314151617protected void logAuth(ServletRequest request) &#123; if (serverConfig.shouldLogIdentityHeaders()) &#123; if (request instanceof HttpServletRequest) &#123; HttpServletRequest httpRequest = (HttpServletRequest) request; String clientName = getHeader(httpRequest, AbstractEurekaIdentity.AUTH_NAME_HEADER_KEY); String clientVersion = getHeader(httpRequest, AbstractEurekaIdentity.AUTH_VERSION_HEADER_KEY); DynamicCounter.increment(MonitorConfig.builder(NAME_PREFIX + clientName + "-" + clientVersion).build()); &#125; &#125;&#125;protected String getHeader(HttpServletRequest request, String headerKey) &#123; String value = request.getHeader(headerKey); return Strings.isNullOrEmpty(value) ? UNKNOWN : value;&#125; RateLimitingFilterRateLimitingFilter简介所属包：com.netflix.eureka.RateLimitingFilter，请求速率限制过滤器。 GzipEncodingEnforcingFilterGzipEncodingEnforcingFilter简介所属包：com.netflix.eureka.GzipEncodingEnforcingFilter，gzip编码。最初Eureka仅支持非压缩响应, 对于大型注册管理机构来说，它非常低效，因此增加了gzip编码。如今，所有现代HTTP客户端都透明地支持gzip HTTP响应，因此不再需要维护未压缩的内容。 通过添加此过滤器，Eureka 服务器将只接受明确支持gzip编码回复的GET请求。, 在即将到来的次要版本中，非压缩回复将完全丢弃，因此此过滤器将成为必需。 GzipEncodingEnforcingFilter源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273@Overridepublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest httpRequest = (HttpServletRequest) request; if ("GET".equals(httpRequest.getMethod())) &#123; String acceptEncoding = httpRequest.getHeader(HttpHeaders.ACCEPT_ENCODING); if (acceptEncoding == null) &#123; chain.doFilter(addGzipAcceptEncoding(httpRequest), response); return; &#125; if (!acceptEncoding.contains("gzip")) &#123; ((HttpServletResponse) response).setStatus(HttpServletResponse.SC_NOT_ACCEPTABLE); return; &#125; &#125; chain.doFilter(request, response);&#125;private static HttpServletRequest addGzipAcceptEncoding(HttpServletRequest request) &#123; return new HttpServletRequestWrapper(request) &#123; @Override public Enumeration&lt;String&gt; getHeaders(String name) &#123; if (HttpHeaders.ACCEPT_ENCODING.equals(name)) &#123; return new EnumWrapper&lt;String&gt;("gzip"); &#125; return new EnumWrapper&lt;String&gt;(super.getHeaders(name), HttpHeaders.ACCEPT_ENCODING); &#125; @Override public Enumeration&lt;String&gt; getHeaderNames() &#123; return new EnumWrapper&lt;String&gt;(super.getHeaderNames(), HttpHeaders.ACCEPT_ENCODING); &#125; @Override public String getHeader(String name) &#123; if (HttpHeaders.ACCEPT_ENCODING.equals(name)) &#123; return "gzip"; &#125; return super.getHeader(name); &#125; &#125;;&#125;private static class EnumWrapper&lt;E&gt; implements Enumeration&lt;E&gt; &#123; private final Enumeration&lt;E&gt; delegate; private final AtomicReference&lt;E&gt; extraElementRef; private EnumWrapper(E extraElement) &#123; this(null, extraElement); &#125; private EnumWrapper(Enumeration&lt;E&gt; delegate, E extraElement) &#123; this.delegate = delegate; this.extraElementRef = new AtomicReference&lt;&gt;(extraElement); &#125; @Override public boolean hasMoreElements() &#123; return extraElementRef.get() != null || delegate != null &amp;&amp; delegate.hasMoreElements(); &#125; @Override public E nextElement() &#123; E extra = extraElementRef.getAndSet(null); if (extra != null) &#123; return extra; &#125; if (delegate == null) &#123; throw new NoSuchElementException(); &#125; return delegate.nextElement(); &#125;&#125; ServletContainerServletContainer简介所属包：com.sun.jersey.spi.container.servlet.ServletContainer，Jersey MVC 请求过滤器。 总结我们可以看到Eureka-Server的生成，是EurekaBootStrap实现了 javax.servlet.ServletContextListener 接口，在 Servlet 容器( 例如 Tomcat、Jetty )启动时，调用 contextInitialized() 方法初始化Eureka-Server。Eureka-Server内嵌 Eureka-Client，用于和Eureka-Server集群里其他节点通信交互。 欢迎关注博主其他的文章。]]></content>
      <categories>
        <category>SpringCloud</category>
        <category>Eureka</category>
      </categories>
      <tags>
        <tag>Eureka</tag>
        <tag>SpringCloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eureka源码—EurekaClient]]></title>
    <url>%2F2018%2F03%2F21%2FEureka%E6%BA%90%E7%A0%81%E2%80%94EurekaClient%2F</url>
    <content type="text"><![CDATA[前言本篇文章主要解读Eureka-Client初始化的相关源码，文章较长，请谨慎点击！ EurekaInstanceConfig EurekaInstanceConfig简介所属包：com.netflix.appinfo.EurekaInstanceConfig，Eureka 应用实例配置接口（Application Provider，Application Consumer）。 EurekaInstanceConfig源码博主已添加中文注释，点击查看。 EurekaInstanceConfig重要属性或者重要方法 getInstanceId()获取实例id，组成结构为${spring.application.name}:${spring.application.instance_id:${random.value}}默认为null。 geAppName()获取应用名，默认为”unknown”。 getLeaseRenewalIntervalInSeconds()获取租约续约频率，单位为秒。默认为30s。应用发送心跳给Eureka-Server进行续约（告诉Eureka-Server自己还活着）。 getLeaseExpirationDurationInSeconds() 获取租约过期时间，单位为秒。默认为90s。如果超过该时间，应用还没有向Eureka-Server发送心跳，那该租约就过期了，Eureka-Serever会进行应用移除。 getMetadataMap()获取实例的元数据。如果你想自定义一些数据，在各服务之间使用，就需要该方法。 getHealthCheckUrlPath(),getHealthCheckUrl(),getSecureHealthCheckUrl()健康检查相关的几个方法。 getNamespace()获取命名空间，已配置对应的eureka属性，默认为eureka。 ​ AbstractInstanceConfigAbstractInstanceConfig简介所属包：com.netflix.appinfo.AbstractInstanceConfig，Eureka 应用实例配置抽象基类，主要实现一些相对通用的配置 AbstractInstanceConfig源码博主已添加中文注释，点击查看。 AbstractInstanceConfig重要属性或者重要方法 主要设置一些基础的属性，以及对应的get/set方法 getHostInfo()获取本地服务器的主机名和主机IP地址 PropertiesInstanceConfigPropertiesInstanceConfig简介所属包：com.netflix.appinfo.PropertiesInstanceConfig，通过配置文件进行Eureka实例配置的抽象基类 PropertiesInstanceConfig源码博主已添加中文注释，点击查看。 PropertiesInstanceConfig重要属性或者重要方法 namespace命名空间。 configInstance配置文件，基于Netflix Archaius 1.x 实现读取配置文件。基于Netflix Archaius 2.x 的还在开发中。 appGrpNameFromEnv从环境变量中获取应用分组，ConfigurationManager.getConfigInstance获取当前的系统范围配置。 Archaius1Utils.initConfig(CommonConstants.CONFIG_FILE_NAME)，CommonConstants.CONFIG_FILE_NAME为eureka-client，Archaius1Utils.initConfig方法源码如下： 12345678910111213141516171819202122232425262728293031323334public final class Archaius1Utils &#123; private static final Logger logger = LoggerFactory.getLogger(Archaius1Utils.class); private static final String ARCHAIUS_DEPLOYMENT_ENVIRONMENT = "archaius.deployment.environment"; private static final String EUREKA_ENVIRONMENT = "eureka.environment"; public static DynamicPropertyFactory initConfig(String configName) &#123; // 配置文件对象 DynamicPropertyFactory configInstance = DynamicPropertyFactory.getInstance(); // 配置文件名，如果configName没有配置，即为CommonConstants.CONFIG_FILE_NAME（"eureka-client"） DynamicStringProperty EUREKA_PROPS_FILE = configInstance.getStringProperty("eureka.client.props", configName); // 配置文件环境 String env = ConfigurationManager.getConfigInstance().getString(EUREKA_ENVIRONMENT, "test"); // 将配置文件加载到环境变量 ConfigurationManager.getConfigInstance().setProperty(ARCHAIUS_DEPLOYMENT_ENVIRONMENT, env); String eurekaPropsFile = EUREKA_PROPS_FILE.get(); try &#123; //读取配置文件到环境变量，首先读取 $&#123;eureka.client.props&#125; 对应的配置文件；然后读取 $&#123;eureka.client.props&#125;-$&#123;eureka.environment&#125; 对应的配置文件。若有相同属性，进行覆盖。 ConfigurationManager.loadCascadedPropertiesFromResources(eurekaPropsFile); &#125; catch (IOException e) &#123; logger.warn( "Cannot find the properties specified : &#123;&#125;. This may be okay if there are other environment " + "specific properties or the configuration is installed with a different mechanism.", eurekaPropsFile); &#125; return configInstance; &#125;&#125; 其他实现方法基本类似，都是从配置文件中获取值，举一个例子： ​ isInstanceEnabledOnit()：从配置文件中获取是否在实例初始化的时候开启，并传一个默认值（这里是父类AbstractInstanceConfig中实现的方法），namespace的属性key都在PropertyBasedInstanceConfigConstants中 MyDataCenterInstanceConfigMyDataCenterInstanceConfig简介所属包：com.netflix.appinfo.MyDataCenterInstanceConfig，Eureka应用实例配置实现类 MyDataCenterInstanceConfig源码123456789101112131415161718public class MyDataCenterInstanceConfig extends PropertiesInstanceConfig implements EurekaInstanceConfig &#123; /** * 无参构造方法 */ public MyDataCenterInstanceConfig() &#123; &#125; public MyDataCenterInstanceConfig(String namespace) &#123; //调用父类含有namespace参数的构造函数进行初始化 super(namespace); &#125; public MyDataCenterInstanceConfig(String namespace, DataCenterInfo dataCenterInfo) &#123; //调用父类含有namespace和dataCenterInfo参数的构造函数进行初始化 super(namespace, dataCenterInfo); &#125;&#125; InstanceInfoInstanceInfo简介所属包：com.netflix.appinfo.InstanceInfo，应用实例信息。Eureka-Client 向 Eureka-Server 注册该对象信息。注册成功后，可以被其他 Eureka-Client 发现。Eureka通过com.netflix.appinfo.providers.EurekaConfigBasedInstanceInfoProvider基于EurekaInstanceConfig创建InstanceInfo。 EurekaConfigBasedInstanceInfoProvider源码博主已添加中文注释，点击查看。 EurekaConfigBasedInstanceInfoProvider重要属性或者重要方法 基本上每个属性和每个方法都添加了注释 其中vip地址解析器源码如下： 12345678910public interface VipAddressResolver &#123; /** * Convert &lt;code&gt;VIPAddress&lt;/code&gt; by substituting environment variables if necessary. * * @param vipAddressMacro the macro for which the interpolation needs to be made. * @return a string representing the final &lt;code&gt;VIPAddress&lt;/code&gt; after substitution. */ String resolveDeploymentContextBasedVipAddresses(String vipAddressMacro);&#125; 实现类源码（Archaius1实现，Archaius2还在开发中）： 1234567891011121314151617181920212223242526272829303132public class Archaius1VipAddressResolver implements VipAddressResolver &#123; private static final Logger logger = LoggerFactory.getLogger(Archaius1VipAddressResolver.class); private static final Pattern VIP_ATTRIBUTES_PATTERN = Pattern.compile("\\$\\&#123;(.*?)\\&#125;"); @Override public String resolveDeploymentContextBasedVipAddresses(String vipAddressMacro) &#123; if (vipAddressMacro == null) &#123; return null; &#125; String result = vipAddressMacro; //匹配$&#123;(.*?)&#125; Matcher matcher = VIP_ATTRIBUTES_PATTERN.matcher(result); while (matcher.find()) &#123; String key = matcher.group(1); String value = DynamicPropertyFactory.getInstance().getStringProperty(key, "").get(); logger.debug("att:&#123;&#125;", matcher.group()); logger.debug(", att key:&#123;&#125;", key); logger.debug(", att value:&#123;&#125;", value); logger.debug(""); //将$&#123;(.*?)&#125;替换为配置文件中对应的value result = result.replaceAll("\\$\\&#123;" + key + "\\&#125;", value); matcher = VIP_ATTRIBUTES_PATTERN.matcher(result); &#125; return result; &#125;&#125; ApplicationInfoManagerApplicationInfoManager简介所属包：com.netflix.appinfo.ApplicationInfoManager，应用信息管理类，由InstanceInfo和EurekaInstanceConfig生成。 ApplicationInfoManager源码博主已添加中文注释，点击查看。 EurekaClientConfigEurekaClientConfig简介所属包：com.netflix.discovery.EurekaClientConfig，Eureka-Client 配置接口，获取连接的 Eureka-Server 的地址、获取服务提供者列表的频率、注册自身为服务提供者的频率等等。 EurekaClientConfig源码博主已添加中文注释，点击查看。 EurekaClientConfig重要属性或者重要方法 getRegion()，getAvailabilityZones()：region和zone（或者Availability Zone）均是AWS的概念。在非AWS环境下，我们可以简单地将region理解为Eureka集群，zone理解成机房。Spring Cloud中默认的region是us-east-1 。具体可查看《周立 —— Region、Zone解析》。 getEurekaServerServiceUrls()：获取Eureka-Server的Url集合 从Eureka-Server获取注册信息的相关方法： getRegistryFetchIntervalSeconds()：获取注册信息的时间间隔，单位为秒。默认为30s getEurekaServiceUrlPollIntervalSeconds()：向Eureka-Server获取Eureka服务地址的变化时间间隔，单位为秒。默认为 5 * 60 * 1000 s getEurekaServerReadTimeoutSeconds()：获取Eureka-Server读取超时时间，单位为秒。默认为8s getBackupRegistryImpl()：获取备份注册中心实现类。默认为null shouldPreferSameZoneEureka()：相同Zone的Eureka是否优先。默认为true shouldDisableDelta()：是否使用增量形式获取注册信息。默认为false fetchRegistryForRemoteRegions()：获取远程区域的注册信息。默认为null shouldFilterOnlyUpInstances()：是否只获取Up（启动）状态的实例。默认为true shouldFetchRegistry()：是否从Eureka-Server获取注册信息。默认为true getRegistryRefreshSingleVipAddress()：获取单个vip地址（虚拟IP地址）的注册信息。默认为null getCacheRefreshExecutorThreadPoolSize()：获取注册信息缓存刷新的线程池大小。默认为5 getCacheRefreshExecutorExponentialBackOffBound()：获取注册信息缓存刷新执行超时后的延迟重试时间的最大倍数。默认为10 向Eureka-Server注册自身服务的相关方法： getInstanceInfoReplicationIntervalSeconds()：获取向Eureka-Server同步实例信息的时间间隔，单位为秒。默认为30s getInitialInstanceInfoReplicationIntervalSeconds()：获取最初向Eureka-Server同步实例信息的时间间隔，单位为秒。默认为40s getEurekaServerConnectTimeoutSeconds()：获取Eureka-Server连接超时时间，单位为秒。默认为5s shouldRegisterWithEureka()：是否向Eureka-Server注册自身服务。默认为true shouldUnregisterOnShutdown()：当Eureka-Server关闭的时候，是否注销自己的服务。默认为true getHeartbeatExecutorThreadPoolSize()：获取心跳检测执行的线程池大小。默认为5 getHeartbeatExecutorExponentialBackOffBound()：获取心跳检测执行超时后的延迟重试时间的最大倍数。默认为10 shouldEnforceRegistrationAtInit()：是否在实例初始化的时候进行注册。默认为false DefaultEurekaClientConfigDefaultEurekaClientConfig简介所属包：com.netflix.discovery.DefaultEurekaClientConfig，基于配置文件的Eureka-Client配置实现类。 DefaultEurekaClientConfig源码博主已添加中文注释，点击查看。 DefaultEurekaClientConfig重要属性或者重要方法 其中属性和构造方法基本上都加了中文注释。 其他实现方法基本类似，都是从配置文件中获取值，举一个例子： `getRegistryFetchIntervalSeconds()`：从配置文件中获取读取注册信息的时间间隔，并传一个默认值（这里是30），namespace后面的属性key都在PropertyBasedClientConfigConstants中。 DefaultEurekaClientConfigProviderDefaultEurekaClientConfigProvider简介所属包：com.netflix.discovery.providers.DefaultEurekaClientConfigProvider，创建 DefaultEurekaClientConfig 的工厂 。 DefaultEurekaClientConfigProvider源码1234567891011121314151617181920212223public class DefaultEurekaClientConfigProvider implements Provider&lt;EurekaClientConfig&gt; &#123; @Inject(optional = true) @EurekaNamespace private String namespace; private DefaultEurekaClientConfig config; @Override public synchronized EurekaClientConfig get() &#123; if (config == null) &#123; //根据命名空间是否为空来判断调用哪一个构造方法创建DefaultEurekaClientConfigProvider config = (namespace == null) ? new DefaultEurekaClientConfig() : new DefaultEurekaClientConfig(namespace); // TODO: Remove this when DiscoveryManager is finally no longer used DiscoveryManager.getInstance().setEurekaClientConfig(config); &#125; return config; &#125;&#125; 很简单的一个类，不做过多的分析。 EurekaTransportConfigEurekaTransportConfig简介所属包：com.netflix.discovery.shared.transport.EurekaTransportConfig，Eureka网络传输配置接口。 EurekaTransportConfig源码博主已添加中文注释，点击查看。 EurekaTransportConfig重要属性或者重要方法 getSessionedClientReconnectIntervalSeconds()：Eureka-Client 会话重新连接的时间间隔，单位为秒，默认为20 * 60s。 getRetryableClientQuarantineRefreshPercentage()：请求失败的Eureka-Client隔离集合占Eureka-Client总数的占比，超过该比例会进行清空，默认为0.66。 Endpoint相关： getAsyncResolverRefreshIntervalMs()：异步解析 EndPoint 集群频率，单位为毫秒。默认为5 * 60 * 1000ms。 getAsyncResolverWarmUpTimeoutMs()：异步解析器预热解析 EndPoint 集群超时时间，单位为毫秒。默认为5000s。 getAsyncExecutorThreadPoolSize()：异步线程池大小，默认为5。 DefaultEurekaTransportConfigDefaultEurekaTransportConfig简介所属包：com.netflix.discovery.shared.transport.DefaultEurekaTransportConfig，基于配置文件的网络传输配置实现类 。 DefaultEurekaTransportConfig源码博主已添加中文注释，点击查看。 DefaultEurekaTransportConfig重要属性或者重要方法 其他实现方法基本类似，都是从配置文件中获取值，举一个例子： getSessionedClientReconnectIntervalSeconds()：Eureka-Client 会话重新连接的时间间隔，并传一个默认值（这里是20 * 60），namespace的属性key都在PropertyBasedTransportConfigConstants中。 LookupServiceLookupService简介所属包：com.netflix.discovery.shared.LookupService，查找服务接口，可以获取应用集合和应用实例集合。 在 Eureka-Client 里，EurekaClient 继承该接口。 在 Eureka-Server 里，com.netflix.eureka.registry.InstanceRegistry 继承该接口。 LookupService源码 博主已添加中文注释，点击查看。 EurekaClientEurekaClient简介所属包：com.netflix.discovery.EurekaClient，Eureka-Client接口 。 EurekaClient源码博主已添加中文注释，点击查看。 EurkeaClient重要属性或者重要方法 获取应用集合： getApplicationsForARegion(@Nullable String region)：获取指定区域中的Applications。 getApplications(String serviceUrl)：获取指定的Eureka服务地址中注册的应用集合。 获取应用实例集合： getInstancesByVipAddress(String vipAddress, boolean secure)：获取指定VIP地址的实例列表。 getInstancesByVipAddress(String vipAddress, boolean secure, @Nullable String region)：获取指定VIP地址和区域的实例信息列表。 getInstancesByVipAddressAndAppName(String vipAddress, String appName, boolean secure)：获取指定VIP地址和appName的实例信息列表。 getAllKnownRegions()：获取所有已知的区域。 getInstanceRemoteStatus()：获取实例状态。 registerHealthCheck()：Eureka-Client注册健康检查。 getHealthCheckHandler()：获取健康监测处理器。 registerEventListener()：Eureka-Client注册事件监听。 unregisterEventListener()：Eureka-Client取消事件监听注册。 getEurekaClientConfig()：获取Eureka-Client配置。 getApplicationInfoManager()：获取应用信息管理器。 DiscoveryClient DiscoveryClient简介所属包：com.netflix.discovery.DiscoveryClient，EurekaClient接口的实现类，用于与 Eureka-Server 交互。包含方法： 向 Eureka-Server 注册自身服务 向 Eureka-Server 续约自身服务 向 Eureka-Server 取消自身服务，当关闭时 从 Eureka-Server 查询应用集合和应用实例信息 本文主要介绍DiscoveryClient的初始化，其他方法后续文章会有介绍 DiscoveryClient源码博主已添加中文注释，点击查看。 DiscoveryClient重要属性或者重要方法构造函数： 12345@InjectDiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args, Provider&lt;BackupRegistry&gt; backupRegistryProvider) &#123; //省略具体代码&#125; 参数： ApplicationInfoManager：应用信息管理类，具体可查看ApplicationInfoManager小结。 EurekaClientConfig：Eureka-Client 配置接口，获取连接的 Eureka-Server 的地址、获取服务提供者列表的频率、注册自身为服务提供者的频率等等，具体可查看EurekaClientConfig小结。 AbstractDiscoveryClientOptionalArgs：DiscoveryClient 可选参数抽象基类。该参数是选填参数，实际生产中很少使用，源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public abstract class AbstractDiscoveryClientOptionalArgs&lt;T&gt; &#123; /** * 健康检查回调的工厂 */ Provider&lt;HealthCheckCallback&gt; healthCheckCallbackProvider; /** * 健康检查处理器的工厂 */ Provider&lt;HealthCheckHandler&gt; healthCheckHandlerProvider; /** * 向Eureka-Server注册之前的处理器 */ PreRegistrationHandler preRegistrationHandler; /** * Jersey 过滤器集合 */ Collection&lt;T&gt; additionalFilters; /** * Jersey 客户端 */ EurekaJerseyClient eurekaJerseyClient; /** * 生成 Jersey 客户端工厂 */ TransportClientFactory transportClientFactory; /** * 生成 Jersey 客户端工厂 */ TransportClientFactories transportClientFactories; /** * Eureka 事件监听集合 */ private Set&lt;EurekaEventListener&gt; eventListeners; /** * ssl */ private Optional&lt;SSLContext&gt; sslContext = Optional.empty(); /** * 主机认证 */ private Optional&lt;HostnameVerifier&gt; hostnameVerifier = Optional.empty(); //省略set方法&#125; Provider&lt;BackupRegistry&gt;：备份注册中心接口，当 Eureka-Client 启动时，无法从 Eureka-Server 读取注册信息，就从备份注册中心读取注册信息 ，源码如下： 1234567@ImplementedBy(NotImplementedRegistryImpl.class)public interface BackupRegistry &#123; Applications fetchRegistry(); Applications fetchRegistry(String[] includeRemoteRegions);&#125; 实现类源码如下（可以看出暂未提供合适的实现）： 123456789101112131415161718192021222324@Singletonpublic class NotImplementedRegistryImpl implements BackupRegistry &#123; /** * 获取应用注册信息 * * @return 应用列表对象 （默认为null） */ @Override public Applications fetchRegistry() &#123; return null; &#125; /** * 获取应用注册信息 * * @param includeRemoteRegions 远程区域列表 * @return 应用列表对象（默认为null） */ @Override public Applications fetchRegistry(String[] includeRemoteRegions) &#123; return null; &#125;&#125; 具体逻辑可查看源码，博主已添加中文注释 总结我们可以看到 EurekaClient 的创建，先是通过 EurekaInstanceConfig 生成 InstanceInfo，再通过 EurekaInstanceConfig 和 InstanceInfo 生成 ApplicationInfoManager，最后 EurekaClientConfig 和 ApplicationInfoManager 生成 EurekaClient。 欢迎关注博主其他的文章。]]></content>
      <categories>
        <category>SpringCloud</category>
        <category>Eureka</category>
      </categories>
      <tags>
        <tag>Eureka</tag>
        <tag>SpringCloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eureka源码系列简介]]></title>
    <url>%2F2018%2F03%2F18%2FEureka%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[前言最近关于微服务的话题很火热，本系列文章主要是从源码去解读Eureka。 PS： 什么是微服务，本文不做具体介绍，可以自行上网查找。 如果没有使用过SpringCloud，博主建议先自行搭建一套服务之后，再进行源码的解读。 该系列文章很枯燥也很耗时，请合理安排时间。 博主是参考了芋艿大佬的路线进行源码解读的，其中有部分问题借鉴了芋艿大佬的解读。点击访问芋艿大佬的博客 Eureka项目结构简介 eureka-client com.netflix.appinfo : Eureka-Client 的应用配置 com.netflix.discovery : Eureka-Client 的注册和发现功能 eureka-client-archaius2Archaius是 Netflix 开源的配置管理组件。Eureka 使用 1.x 版本，2.x 版本仍然在开发中，2.x只兼容jdk1.8以上的版本。 eureka-client-jersey2Jersey 框架实现Eureka的 RESTful HTTP接口。Eureka 使用 1.x 版本，2.x 版本由社区实现。 eureka-core com.netflix.eureka.aws : 与AWS (Amazon Web Services) 相关，该系列文章暂不涉及AWS的分析 com.netflix.eureka.cluster : 与peer节点复制(replication)相关 com.netflix.eureka.lease : 租约，用来控制注册信息的生命周期(注册、续约、剔除) com.netflix.eureka.registry : 存储、查询服务注册信息 com.netflix.eureka.resources : RESTful中的”R”，即资源。相当于SpringMVC中的Controller com.netflix.eureka.transport : 发送HTTP请求的客户端，如发送心跳 com.netflix.eureka.util : 相关工具包 eureka-core-jersey2Jersey 框架实现Eureka的 RESTful HTTP接口。Eureka 使用 1.x 版本，2.x 版本由社区实现。 eureka-examplesEureka-Client 使用例子。 eureka-resources通过 JSP 实现 Eureka-Server 的运维后台界面。 eureka-server由 eureka-client + eureka-core + eureka-resources 打包成 Eureka-Server 的war包。 eureka-server-governator使用 Netflix Governator （Google Guice的扩展类库，提供了Classpath扫描及自动绑定、生命周期管理、成员属性验证等功能）管理 Eureka-Server 的生命周期。目前该模块正在测试阶段。 eureka-test-utilsEureka 单元测试工具类。]]></content>
      <categories>
        <category>SpringCloud</category>
        <category>Eureka</category>
      </categories>
      <tags>
        <tag>Eureka</tag>
        <tag>SpringCloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JPA使用Java8的LocalDateTime]]></title>
    <url>%2F2017%2F12%2F02%2FJPA%E4%BD%BF%E7%94%A8Java8%E7%9A%84LocalDateTime%2F</url>
    <content type="text"><![CDATA[前言这篇文章主要介绍JPA如何正确使用LocalDateTime与数据库datetime属性进行映射。 对应的JPA版本是2.1以下的，由于JPA2.1发布时间早于Java8，所以不能直接支持Java8的新特新。Oracle最新发布的JPA2.2版本是支持新的时间API以及查询结果流等。 MyBatis请查看MyBatis使用Java8的LocalDateTime。 解决方法spring-boot-starter-data-jpa的版本为1.5.9.RELEASE，对应的hibernate-core版本为5.0.12.Final 将数据保存到数据库 添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-java8&lt;/artifactId&gt; &lt;version&gt;5.0.12.Final&lt;/version&gt;&lt;/dependency&gt; 添加注解，在获取LocalDateTime时，指定时间格式 12345678910public class User &#123; @Id @Column(name = "id", nullable = false, length = 20) private Long id; @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", locale = "zh", timezone = "GMT+8") @Column(name = "gmt_create") private LocalDateTime gmtCreate; //省略get，set方法&#125; 总结博主一开始遇到了一个坑，我用的hibernate-java8版本为5.2.8.Final，结果报错了。后来发现这个版本的hibernate-core是5.2.8.Final。后来改成对应的5.0.12.Final就正确了。 欢迎关注博主其他的文章。]]></content>
      <categories>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>JPA</tag>
        <tag>Java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis使用Java8的LocalDateTime]]></title>
    <url>%2F2017%2F12%2F01%2FMyBatis%E4%BD%BF%E7%94%A8Java8%E7%9A%84LocalDateTime%2F</url>
    <content type="text"><![CDATA[前言众所周知，Java8之前的时间API有很多问题，比如：非线程安全，设计很差。时区处理麻烦。新的时间API（java.time包）解决了这些问题，所以我们在平时开发尽可能的使用新的时间API。但是MyBatis使用LocalDataTime映射到数据库的datetime属性时，会报错。 解决方法mybatis-spring-boot-starter的版本为1.3.1，对应的MyBatis版本为3.4.5（版本低于3.4.0还需要特殊配置） 将数据保存到数据库 添加依赖 12345678910111213&lt;!-- LocalDateTime映射到数据库需要的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-typehandlers-jsr310&lt;/artifactId&gt; &lt;version&gt;1.0.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 格式化LocalDateTime需要的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt; &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt; 添加注解，设置时间格式 1234567public class User &#123; private Integer id; @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", locale = "zh", timezone = "GMT+8") private LocalDateTime gmtCreate; //省略get，set方法&#125; 总结关于MyBatis使用LocalDateTime的内容就是上面这些了，如果使用的ORM框架式JPA，请点击JPA使用Java8的LocalDateTime。 欢迎关注博主其他的文章。]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>Java8</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8新特性—Lambda表达式]]></title>
    <url>%2F2017%2F08%2F05%2FJava8%E6%96%B0%E7%89%B9%E6%80%A7%E2%80%94Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言JDK1.8是自JDK1.5以来最具革命性的版本。JDK1.8为Java语言、编译器、类库、开发工具与JVM（Java虚拟机）带来了大量新特性。所做的改变，在许多方面比Java历史上任何一次改变都深远。它们会让你编起程来更容易。本文主要介绍JDK1.8最重要的新特性之一：Lambda表达式。 PS：博主的公司也切换为JDK1.8了，CTO让我进行一次JDK1.8的分享，本文也是记录一下。 什么是Lambda表达式Lambda表达式可以理解为简洁地表示可传递的匿名函数的一种方式。 是不是很抽象的一句话？那让我们看一下它长什么样。 1(String s) -&gt; s. isEmpty() 什么鬼，长得也这么抽象。 我们看一下表达式结构中最特别的是-&gt;，而这个箭头的左边是Lambda的参数列表，右边是Lambda的函数主体。所以Lambda表达式的结构表示为：(parameters) -&gt; expression 或 (parameters) -&gt;{ statements; }。 如下： 12Comparator&lt;String&gt; sort = (String s1, String s2) -&gt; (s1.compareTo(s2));Runnable runnable = () -&gt; System.out.println("Hello world !"); 这样看来是不是有所明白了？ 如何使用Lambda表达式 我们使用以前的方法创建一个新的线程，代码如下： 123456Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("匿名内部类实现Runnable"); &#125;&#125;); 接下来使用Lambda表达式创建一个新的线程，代码如下： 1Thread thread = new Thread(() -&gt; System.out.println("Lambda实现Runnable" )); 通过上面代码的对比，我们看到Lambda表达式实现了Runnable接口。 那所有的接口都可以用Lambda表达式来实现吗？ 答案当然是不行的，只有函数式接口才能使用Lambda表达式。什么是函数式接口？让我们继续看下一节。 函数式接口所谓的函数式接口，就是接口中只定义了一个抽象方法（SAM：Single Abstract Method）。Java8接口中的默认方法和静态方法，都不算是抽象方法。接口默认继承Object，所以如果接口显示声明覆盖了Object中方法，那么也不算抽象方法。 在Java8中，使用@FunctionalInterface标记一个函数式接口 。该注解不是必须的，如果一个接口符合函数式接口的定义，那么加上该注解能够更好地让编译器进行检查。如果不是函数式接口，但是加上了@FunctionalInterface，那么编译器会报错。 Java8中新增的函数式接口 Predicate&lt;T&gt; Consumer&lt;T&gt; Supplier&lt;T&gt; Function&lt;T,R&gt; BinaryOperator&lt;T&gt; UnaryOperator&lt;T&gt; 还有很多是通过上面六个衍化出来的，具体可以查看JDK1.8的API 类型推断这一节，我们说一下类型推断~ 看一下下面的代码： 12Callable&lt;String&gt; c = () -&gt; "done";PrivilegedAction&lt;String&gt; p = () -&gt; "done"; 同一个Lambda表达式() -&gt; &quot;done&quot;，但是表示了不同的类型。 当且仅当下面所有条件均满足时，Lambda 表达式才可以被赋给目标类型 T： T 是一个函数式接口 Lambda 表达式的参数和 T 的方法参数在数量和类型上一一对应 Lambda 表达式的返回值和 T 的方法返回值相兼容（Compatible） Lambda 表达式内所抛出的异常和 T 的方法 throws 类型相兼容 而类型推断可以通过如下的规则进行推断： 变量声明 赋值 返回语句 数组初始化器 方法和构造方法的参数 Lambda 表达式函数体 条件表达式（? :） 转型（Cast）表达式 特殊的void兼容规则：如果一个Lambda的主体是一个语句表达式，它就和一个返回void的函数描述符兼容（当然需要参数列表也兼容）。例如，以下两行都是合法的： 12Predicate&lt;String&gt; p = list::add;Consumer&lt;String&gt; c = list::add; 默认方法和静态方法上一节说到，接口的默认方法和静态方法并不是抽象方法。这好像跟我们平时认识的接口，有所不同，接口里面的方法都是没有具体实现的。怎么还会有不是抽象方法的方法？ 默认方法我们先看一下默认方法，代码如下： 123default Stream&lt;E&gt; stream() &#123; return StreamSupport.stream(spliterator(), false);&#125; 在接口的方法名前面加个default关键字即可实现默认方法 。 ps：default关键字，博主之前还是在用switch的时候用到了。 引入默认方法最主要的作用是：为了解决接口的修改与现有的实现不兼容的问题，不需要逐个修改实现类。因为实现类默认携带接口的默认方法。 说到这里，有细心的读者就会想到：Java语言中一个类只能继承一个父类，但是一个类可以实现多个接口。随着默认方法在Java 8中引入，有可能出现一个类继承了多个方法而它们使用的却是同样的函数签名。这种情况下，类会选择使用哪一个函数？ 解决该问题的规则如下： 类中的方法优先级最高。 类或父类中显式声明的方法，其优先级高于所有的默认方法 如果无法依据第一条进行判断，那么子接口的优先级更高 如果2规则也失效，则需要显式指定接口，X.super.m(…) 静态方法Java 8 的另一个特性是接口可以声明（并且可以提供实现）静态方法 ，代码如下： 1234567public static &lt;T, U extends Comparable&lt;? super U&gt;&gt; Comparator&lt;T&gt; comparing( Function&lt;? super T, ? extends U&gt; keyExtractor) &#123; Objects.requireNonNull(keyExtractor); return (Comparator&lt;T&gt; &amp; Serializable) (c1, c2) -&gt; keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2)); &#125; Java8之后的接口和抽象类对比从上面可以看到Java8之后，抽象类和接口越来越接近了，是接口向抽象类靠近，剥夺抽象类的生存空间。 与抽象类相比，接口不能搞定的： 抽象类能够定义非 static final 的属性(field) ，而接口不能。接口的属性都是static final的。 抽象类能够定义非public方法，而接口不能。接口的方法都是public的。 与接口相比，抽象类不能搞定的： 接口可以多继承(实现)，而抽象类不能。抽象类只能单继承。 方法引用类型推断这一节的最后，我们看到了Lambda表达式的结构变了。它的-&gt;不见了，取而代之的是::，::左右两边也不是参数列表和方法主体，其实这是用了方法引用。 什么是方法引用？ 方法引用简单地说,就是一个Lambda表达式 。方法引用的标准形式是：类名::方法名。 为什么会有方法引用？ 因为，我们有时使用Lambda表达式可能仅仅调用一个已存在的方法，而不做任何其它事。对于这种情况，通过一个方法名字来引用这个已存在的方法会更加清晰。 怎么使用方法引用？ 首先，我们定义一个list： 1List&lt;String&gt; list = Arrays.asList("c", "A", "C"); 然后使用Lambda表达式进行排序： 1list.sort((s1, s2) -&gt; s1.compareTo(s2)); 这里的compareTo方法是已存在的方法，所以我们可以用方法引用代替它： 1list.sort(String::compareTo); 是不是看上去很简洁？ 下面说一下方法引用的种类： 方法引用种类 示例 静态方法引用：ClassName::methodName IntBinaryOperator staticMethod = Integer::sum; 实例上的实例方法引用：instanceReference::methodName Predicate predicate = new ArrayList&lt;&gt;()::contains; 类型上的实例方法引用：ClassName::methodNam Function&lt;String, String&gt; function = String::toString; 构造方法引用：Class::new Supplier supplier = ArrayList::new; 变量捕获这一节，我们说一下初学者比较常见的错误。代码如下： 123List&lt;Integer&gt; list = new ArrayList&lt;&gt;();int sum = 0;list.forEach(e -&gt; sum += e); 可能有一部分初学者会用这样的代码进行累加，但是这段代码是报编译错误的。 这是什么原因呐？ 由于Java只允许在其中捕获那些符合有效只读（Effectively final）的局部变量。 有效只读是指：如果一个局部变量在初始化后从未被修改过，那么它就符合有效只读的要求，换句话说，加上 final后也不会导致编译错误的局部变量就是有效只读变量。 序列化Lambda表达式我们看一下序列化的接口，代码如下： 12public interface Serializable &#123;&#125; 序列化接口被称为ZAM（Zero Abstract Method），即该接口中没有声明任何方法 。Serializable接口一般认为是标记性的接口。 为了能序列化，java8引入了所谓的类型关联（TypeIntersection）。 序列化Lambda表达式的具体代码如下： 12Runnable r1 = () -&gt; System.out.println(this);Runnable r2 = (Runnable &amp; Serializable) () -&gt; System.out.println(this); Lambda实现原理最后，我们来看一下Lambda表达式的实现原理。 由于Lambda表达式提供了函数式接口中抽象方法的实现，这让人有一种感觉，似乎在编译过程中让Java编译器直接将Lambda表达式转换为匿名类更直观。那jvm是不是直接把Lambda编译成匿名内部类？ 并不是，匿名类有着种种不尽如人意的特性，会对应用程序的性能带来负面影响： 编译器会为每个匿名类生成一个新的.class文件。这些新生成的类文件的文件名通常以 ClassName$1这种形式呈现，其中ClassName是匿名类出现的类的名字，紧跟着一个美元符号和一个数字。生成大量的类文件是不利的，因为每个类文件在使用之前都需要加载和验证，这会直接影响应用的启动性能。如果将Lambda表达式转换为匿名类，每个 Lambda表达式都会产生一个新的类文件，这是我们不期望发生的。 每个新的匿名类都会为类或者接口产生一个新的子类型。如果你为了实现一个比较器，使用了一百多个不同的Lambda表达式，这意味着该比较器会有一百多个不同的子类型。 这种情况下，JVM的运行时性能调优会变得更加困难。 我们看一下下面这段代码： 123456Function&lt;Object, String&gt; f = new Function&lt;Object, String&gt;() &#123; @Override public String apply(Object o) &#123; return o.toString(); &#125;&#125;; 这段代码的对应的字节码： 可以看到，通过字节码操作new，一个TestFunction$1类型的对象被实例化了。与此同时，一个指向新创建对象的引用会被压入栈。 dup操作会复制栈上的引用。 接着这个值会被invokespecial指令处理，该指令会初始化对象。 栈顶现在包含了指向对象的引用，该值通过putfield指令保存到了LambdaBytecode类 的f1字段。 我们将这段代码使用Lambda表达式实现： 1Function&lt;Object, String&gt; f = Object::toString; 对应的字节码： 通过两段字节码的对比，我们可以看到，Lambda表达式是通过invokedynamic字节码指令创建额外的类。 invokedynamic最初被JDK7引入，用于支持运行于JVM上的动态类型语言。执行方法调用时，invokedynamic添加了更高层的抽象，使得一部分逻辑可以依据动态语言的特征来决定调用目标。 使用invokedynamic，可以将实现Lambda表达式的这部分代码的字节码生成 推迟到运行时。这种设计选择带来了一系列好结果 ： Lambda表达式的代码块到字节码的转换由高层的策略变成了纯粹的实现细节。它现在可以动态地改变，或者在未来版本中得到优化和修改，并且保持了字节码的后向兼容性。 没有带来额外的开销，没有额外的字段，也不需要进行静态初始化，而这些如果不使用Lambda，就不会实现。 对无状态非捕获型Lambda，我们可以创建一个Lambda对象的实例，对其进行缓存，之后对同一对象的访问都返回同样的内容。 没有额外的性能开销，因为这些转换都是必须的，并且结果也进行了链接，仅在Lambda 首次被调用时需要转换。其后所有的调用都能直接跳过这一步，直接调用之前链接的实现。 总结Lambda表达式，语法简单，有更灵活的语义。它是Java8最重要的新特新之一，大家可以多尝试一下，毕竟Java8已经发布四年多了。不要落后咯~ 欢迎关注博主其他的文章。 参考资料《Java8 实战》]]></content>
      <categories>
        <category>Java</category>
        <category>Java8新特性</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
