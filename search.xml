<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[EurekaClient]]></title>
    <url>%2F2018%2F03%2F21%2FEurekaClient%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言本篇文章主要解读Eureka-Client的相关源码，文章较长，请谨慎点击！ EurekaInstanceConfig 1.1 EurekaInstanceConfig简介所属包：com.netflix.appinfo.EurekaInstanceConfig，Eureka 应用实例配置接口（Application Provider，Application Consumer）。 1.2 EurekaInstanceConfig源码博主已添加中文注释，点击查看。 1.3 EurekaInstanceConfig重要属性或者重要方法 getInstanceId()获取实例id，组成结构为${spring.application.name}:${spring.application.instance_id:${random.value}}默认为null。 geAppName()获取应用名，默认为”unknown”。 getLeaseRenewalIntervalInSeconds()获取租约续约频率，单位为秒。默认为30s。应用发送心跳给Eureka-Server进行续约（告诉Eureka-Server自己还活着）。 getLeaseExpirationDurationInSeconds() 获取租约过期时间，单位为秒。默认为90s。如果超过该时间，应用还没有向Eureka-Server发送心跳，那该租约就过期了，Eureka-Serever会进行应用移除。 getMetadataMap()获取实例的元数据。如果你想自定义一些数据，在各服务之间使用，就需要该方法。 getHealthCheckUrlPath(),getHealthCheckUrl(),getSecureHealthCheckUrl()健康检查相关的几个方法。 getNamespace()获取命名空间，已配置对应的eureka属性，默认为eureka。 ​ AbstractInstanceConfig2.1 AbstractInstanceConfig简介所属包：com.netflix.appinfo.AbstractInstanceConfig，Eureka 应用实例配置抽象基类，主要实现一些相对通用的配置 2.2 AbstractInstanceConfig源码博主已添加中文注释，点击查看。 2.3 AbstractInstanceConfig重要属性或者重要方法 主要设置一些基础的属性，以及对应的get/set方法 getHostInfo()获取本地服务器的主机名和主机IP地址 PropertiesInstanceConfig3.1 PropertiesInstanceConfig简介所属包：com.netflix.appinfo.PropertiesInstanceConfig，通过配置文件进行Eureka实例配置的抽象基类 3.2 PropertiesInstanceConfig源码博主已添加中文注释，点击查看。 3.3 PropertiesInstanceConfig重要属性或者重要方法 namespace命名空间。 configInstance配置文件，基于Netflix Archaius 1.x 实现读取配置文件。基于Netflix Archaius 2.x 的还在开发中。 appGrpNameFromEnv从环境变量中获取应用分组，ConfigurationManager.getConfigInstance获取当前的系统范围配置。 Archaius1Utils.initConfig(CommonConstants.CONFIG_FILE_NAME)，CommonConstants.CONFIG_FILE_NAME为eureka-client，Archaius1Utils.initConfig方法源码如下： 12345678910111213141516171819202122232425262728293031323334public final class Archaius1Utils &#123; private static final Logger logger = LoggerFactory.getLogger(Archaius1Utils.class); private static final String ARCHAIUS_DEPLOYMENT_ENVIRONMENT = "archaius.deployment.environment"; private static final String EUREKA_ENVIRONMENT = "eureka.environment"; public static DynamicPropertyFactory initConfig(String configName) &#123; // 配置文件对象 DynamicPropertyFactory configInstance = DynamicPropertyFactory.getInstance(); // 配置文件名，如果configName没有配置，即为CommonConstants.CONFIG_FILE_NAME（"eureka-client"） DynamicStringProperty EUREKA_PROPS_FILE = configInstance.getStringProperty("eureka.client.props", configName); // 配置文件环境 String env = ConfigurationManager.getConfigInstance().getString(EUREKA_ENVIRONMENT, "test"); // 将配置文件加载到环境变量 ConfigurationManager.getConfigInstance().setProperty(ARCHAIUS_DEPLOYMENT_ENVIRONMENT, env); String eurekaPropsFile = EUREKA_PROPS_FILE.get(); try &#123; //读取配置文件到环境变量，首先读取 $&#123;eureka.client.props&#125; 对应的配置文件；然后读取 $&#123;eureka.client.props&#125;-$&#123;eureka.environment&#125; 对应的配置文件。若有相同属性，进行覆盖。 ConfigurationManager.loadCascadedPropertiesFromResources(eurekaPropsFile); &#125; catch (IOException e) &#123; logger.warn( "Cannot find the properties specified : &#123;&#125;. This may be okay if there are other environment " + "specific properties or the configuration is installed with a different mechanism.", eurekaPropsFile); &#125; return configInstance; &#125;&#125; ​ MyDataCenterInstanceConfig4.1 MyDataCenterInstanceConfig简介所属包：com.netflix.appinfo.MyDataCenterInstanceConfig，Eureka应用实例配置实现类 4.2 MyDataCenterInstanceConfig源码123456789101112131415161718public class MyDataCenterInstanceConfig extends PropertiesInstanceConfig implements EurekaInstanceConfig &#123; /** * 无参构造方法 */ public MyDataCenterInstanceConfig() &#123; &#125; public MyDataCenterInstanceConfig(String namespace) &#123; //调用父类含有namespace参数的构造函数进行初始化 super(namespace); &#125; public MyDataCenterInstanceConfig(String namespace, DataCenterInfo dataCenterInfo) &#123; //调用父类含有namespace和dataCenterInfo参数的构造函数进行初始化 super(namespace, dataCenterInfo); &#125;&#125; InstanceInfo5.1 InstanceInfo简介所属包：com.netflix.appinfo.InstanceInfo，应用实例信息。Eureka-Client 向 Eureka-Server 注册该对象信息。注册成功后，可以被其他 Eureka-Client 发现。Eureka通过com.netflix.appinfo.providers.EurekaConfigBasedInstanceInfoProvider基于EurekaInstanceConfig创建InstanceInfo。 5.2 EurekaConfigBasedInstanceInfoProvider源码博主已添加中文注释，点击查看。 5.3EurekaConfigBasedInstanceInfoProvider重要属性或者重要方法 基本上每个属性和每个方法都添加了注释 其中vip地址解析器源码如下： 12345678910public interface VipAddressResolver &#123; /** * Convert &lt;code&gt;VIPAddress&lt;/code&gt; by substituting environment variables if necessary. * * @param vipAddressMacro the macro for which the interpolation needs to be made. * @return a string representing the final &lt;code&gt;VIPAddress&lt;/code&gt; after substitution. */ String resolveDeploymentContextBasedVipAddresses(String vipAddressMacro);&#125; 实现类源码（Archaius1实现，Archaius2还在开发中）： 1234567891011121314151617181920212223242526272829303132public class Archaius1VipAddressResolver implements VipAddressResolver &#123; private static final Logger logger = LoggerFactory.getLogger(Archaius1VipAddressResolver.class); private static final Pattern VIP_ATTRIBUTES_PATTERN = Pattern.compile("\\$\\&#123;(.*?)\\&#125;"); @Override public String resolveDeploymentContextBasedVipAddresses(String vipAddressMacro) &#123; if (vipAddressMacro == null) &#123; return null; &#125; String result = vipAddressMacro; //匹配$&#123;(.*?)&#125; Matcher matcher = VIP_ATTRIBUTES_PATTERN.matcher(result); while (matcher.find()) &#123; String key = matcher.group(1); String value = DynamicPropertyFactory.getInstance().getStringProperty(key, "").get(); logger.debug("att:&#123;&#125;", matcher.group()); logger.debug(", att key:&#123;&#125;", key); logger.debug(", att value:&#123;&#125;", value); logger.debug(""); //将$&#123;(.*?)&#125;替换为配置文件中对应的value result = result.replaceAll("\\$\\&#123;" + key + "\\&#125;", value); matcher = VIP_ATTRIBUTES_PATTERN.matcher(result); &#125; return result; &#125;&#125; ApplicationInfoManager6.1 ApplicationInfoManager简介所属包：com.netflix.appinfo.ApplicationInfoManager，应用信息管理类，由InstanceInfo和EurekaInstanceConfig生成。 6.2 ApplicationInfoManager源码博主已添加中文注释，点击查看。 EurekaClientConfig7.1 EurekaClientConfig简介所属包：com.netflix.discovery.EurekaClientConfig，获取连接的 Eureka-Server 的地址、获取服务提供者列表的频率、注册自身为服务提供者的频率等等。 7.2 EurekaClientConfig源码点击查看 7.3 EurekaClientConfig重要属性或者重要方法 getRegion()，getAvailabilityZones()：region和zone（或者Availability Zone）均是AWS的概念。在非AWS环境下，我们可以简单地将region理解为Eureka集群，zone理解成机房。Spring Cloud中默认的region是us-east-1 。具体可查看《周立 —— Region、Zone解析》。 使用DNS获取ServiceUrls Di]]></content>
      <categories>
        <category>SpringCloud</category>
        <category>Eureka</category>
      </categories>
      <tags>
        <tag>Eureka</tag>
        <tag>SpringCloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eureka源码系列简介]]></title>
    <url>%2F2018%2F03%2F18%2FEureka%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[前言最近关于微服务的话题很火热，本系列文章主要是从源码去解读Eureka。 PS： 什么是微服务，本文不做具体介绍，可以自行上网查找。 如果没有使用过SpringCloud，博主建议先自行搭建一套服务之后，再进行源码的解读。 该系列文章很枯燥也很耗时，请合理安排时间。 博主是参考了芋艿大佬的路线进行源码解读的，其中有部分问题借鉴了芋艿大佬的解读。点击访问芋艿大佬的博客 Eureka项目结构简介 eureka-client com.netflix.appinfo : Eureka-Client的应用配置， eureka-core com.netflix.eureka.cluster : 与peer节点复制(replication)相关 com.netflix.eureka.lease : 租约，用来控制注册信息的生命周期(注册、续约、剔除) com.netflix.eureka.registry : 存储、查询服务注册信息 com.netflix.eureka.resources : RESTful中的”R”，即资源。相当于SpringMVC中的Controller com.netflix.eureka.transport : 发送HTTP请求的客户端，如发送心跳 com.netflix.eureka.aws : 与AWS (Amazon Web Services) 相关，这系列文章暂不涉及AWS的分析]]></content>
      <categories>
        <category>SpringCloud</category>
        <category>Eureka</category>
      </categories>
      <tags>
        <tag>Eureka</tag>
        <tag>SpringCloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JPA使用Java8的LocalDateTime]]></title>
    <url>%2F2017%2F12%2F02%2FJPA%E4%BD%BF%E7%94%A8Java8%E7%9A%84LocalDateTime%2F</url>
    <content type="text"><![CDATA[前言这篇文章主要介绍JPA如何正确使用LocalDateTime与数据库datetime属性进行映射。 对应的JPA版本是2.1以下的，由于JPA2.1发布时间早于Java8，所以不能直接支持Java8的新特新。Oracle最新发布的JPA2.2版本是支持新的时间API以及查询结果流等。 MyBatis请查看MyBatis使用Java8的LocalDateTime。 解决方法spring-boot-starter-data-jpa的版本为1.5.9.RELEASE，对应的hibernate-core版本为5.0.12.Final 将数据保存到数据库 添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-java8&lt;/artifactId&gt; &lt;version&gt;5.0.12.Final&lt;/version&gt;&lt;/dependency&gt; 添加注解，在获取LocalDateTime时，指定时间格式 12345678910public class User &#123; @Id @Column(name = "id", nullable = false, length = 20) private Long id; @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", locale = "zh", timezone = "GMT+8") @Column(name = "gmt_create") private LocalDateTime gmtCreate; //省略get，set方法&#125; 总结博主一开始遇到了一个坑，我用的hibernate-java8版本为5.2.8.Final，结果报错了。后来发现这个版本的hibernate-core是5.2.8.Final。后来改成对应的5.0.12.Final就正确了。 欢迎关注博主其他的文章。]]></content>
      <categories>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>Java8</tag>
        <tag>JPA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis使用Java8的LocalDateTime]]></title>
    <url>%2F2017%2F12%2F01%2FMyBatis%E4%BD%BF%E7%94%A8Java8%E7%9A%84LocalDateTime%2F</url>
    <content type="text"><![CDATA[前言众所周知，Java8之前的时间API有很多问题，比如：非线程安全，设计很差。时区处理麻烦。新的时间API（java.time包）解决了这些问题，所以我们在平时开发尽可能的使用新的时间API。但是MyBatis使用LocalDataTime映射到数据库的datetime属性时，会报错。 解决方法mybatis-spring-boot-starter的版本为1.3.1，对应的MyBatis版本为3.4.5（版本低于3.4.0还需要特殊配置） 将数据保存到数据库 添加依赖 12345678910111213&lt;!-- LocalDateTime映射到数据库需要的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-typehandlers-jsr310&lt;/artifactId&gt; &lt;version&gt;1.0.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 格式化LocalDateTime需要的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt; &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt; 添加注解，设置时间格式 1234567public class User &#123; private Integer id; @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", locale = "zh", timezone = "GMT+8") private LocalDateTime gmtCreate; //省略get，set方法&#125; 总结关于MyBatis使用LocalDateTime的内容就是上面这些了，如果使用的ORM框架式JPA，请点击JPA使用Java8的LocalDateTime。 欢迎关注博主其他的文章。]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>Java8</tag>
      </tags>
  </entry>
</search>
