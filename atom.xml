<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yoga&#39;s blog</title>
  
  <subtitle>you do what you love and fuck the rest.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yoga0521.github.io/"/>
  <updated>2018-05-19T05:38:09.008Z</updated>
  <id>https://yoga0521.github.io/</id>
  
  <author>
    <name>yoga</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>漏桶算法与令牌桶算法简介</title>
    <link href="https://yoga0521.github.io/2018/03/26/%E6%BC%8F%E6%A1%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/"/>
    <id>https://yoga0521.github.io/2018/03/26/漏桶算法与令牌桶算法简介/</id>
    <published>2018-03-26T05:05:32.000Z</published>
    <updated>2018-05-19T05:38:09.008Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们项目中的API接口都是有访问上限的，当访问频率或者并发量超过其承受范围时，我们就必须考虑限流来保证接口的可用性。防止非预期的请求对系统压力过大而引起的系统瘫痪。本篇文章会介绍限流算法中比较常见的漏桶算法和令牌桶算法。</p><a id="more"></a><h2 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们项目中的API接口都是有访问上限的，当访问频率或者并发量超过其承受范围时，我们就必须考虑限流来保证接口的可用性。防止非预期的请求对系统压力过大而引起的系统瘫痪。本篇文章会介绍限流算法中比较常见的漏桶算法和令牌桶算法。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://yoga0521.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="限流算法" scheme="https://yoga0521.github.io/tags/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Eureka源码—EurekaServer</title>
    <link href="https://yoga0521.github.io/2018/03/23/Eureka%E6%BA%90%E7%A0%81%E2%80%94EurekaServer/"/>
    <id>https://yoga0521.github.io/2018/03/23/Eureka源码—EurekaServer/</id>
    <published>2018-03-23T12:14:15.000Z</published>
    <updated>2018-05-22T13:25:09.871Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇文章主要解读Eureka-Server初始化的相关源码，文章较长，请谨慎点击！</p><a id="more"></a><h2 id="EurekaServerConfig"><a href="#EurekaServerConfig" class="headerlink" title="EurekaServerConfig"></a>EurekaServerConfig</h2><h3 id="EurekaServerConfig简介"><a href="#EurekaServerConfig简介" class="headerlink" title="EurekaServerConfig简介"></a>EurekaServerConfig简介</h3><p>所属包：<code>com.netflix.eureka.EurekaSeverConfig</code>，<strong>Eureka-Server配置接口</strong>。</p><h3 id="EurekaServerConfig源码"><a href="#EurekaServerConfig源码" class="headerlink" title="EurekaServerConfig源码"></a>EurekaServerConfig源码</h3><p>博主已添加中文注释，<a href="https://github.com/yoga0521/eureka/blob/master/eureka-core/src/main/java/com/netflix/eureka/EurekaServerConfig.java" target="_blank" rel="noopener">点击查看</a>。</p><h3 id="EurekaServerConfig重要属性或者重要方法"><a href="#EurekaServerConfig重要属性或者重要方法" class="headerlink" title="EurekaServerConfig重要属性或者重要方法"></a>EurekaServerConfig重要属性或者重要方法</h3><ul><li>自我保护相关：<ul><li><code>shouldEnableSelfPreservation()</code>：是否开启自我保护机制，默认为true。</li><li><code>getRenewalPercentThreshold()</code>：自我保护百分比阈值，超过这个值就会开启自我保护模式。默认为0.85。</li><li><code>getRenewalThresholdUpdateIntervalMs（）</code>:自我保护阈值更新的时间间隔，单位为毫秒（ms）。默认为 15 * 60 * 1000 ms。</li></ul></li><li>注册信息相关：<ul><li><code>getWaitTimeInMsWhenSyncEmpty()</code>：如果eureka在启动的时候，获取不到注册信息，就等待。单位为毫秒（ms）。默认为 1000 *  60  * 5 ms。</li><li><code>getPeerNodeConnectTimeoutMs()</code>：eureka集群节点之间请求连接超时的时间（进行复制信息操作），单位为毫秒（ms）。默认为 1000 ms。</li><li><code>getPeerNodeReadTimeoutMs()</code>：eureka集群节点之间请求读取超时的时间（进行复制信息操作），单位为毫秒（ms），默认为 5000 ms。</li><li><code>getRetentionTimeInMSInDeltaQueue()</code>：获取增量信息缓存的时间，以避免客户端检索的时候丢失，单位为毫秒。默认为 30 * 60 * 1000 ms。</li><li><code>getDeltaRetentionTimerIntervalInMs()</code>：获取清理过期的增量信息任务应唤醒的时间间隔，单位为毫秒。默认为 30 * 1000 ms。</li><li><code>shouldDisableDelta()</code>：是否可以将增量信息提供给客户端，默认为false。</li><li><code>shouldSyncWhenTimestampDiffers()</code>：否同步应用实例信息，当应用实例信息最后更新时间戳( lastDirtyTimestamp )发生改变。默认为true。</li><li><code>getRegistrySyncRetries()</code>：获取eureka服务器启动时，从远程 Eureka-Server 读取失败重试次数。默认为5。</li><li><code>getRegistrySyncRetryWaitMs()</code>：Eureka-Server 启动时，从远程 Eureka-Server 读取注册信息失败，再次尝试获取的等待( sleep )间隔，单位为毫秒，默认为30 * 1000 ms。</li><li><code>shouldDisableDeltaForRemoteRegions()</code>：是否将增量信息提供给客户端或远程区域，默认为false。</li><li><code>getRemoteRegionConnectTimeoutMs()</code>：获取连接到远程Eureka-Server的超时时间，单位为毫秒，默认为2000ms。</li><li><code>getRemoteRegionReadTimeoutMs()</code>：获取读取远程Eureka-Server的超时时间，单位为毫秒，默认为5000ms。</li><li><code>getRemoteRegionUrlsWithName()</code>：获取远程Eureka-Server的地址，key为Eureka-server名，value为Eureka-Server地址。</li><li><code>getRemoteRegionAppWhitelist(@Nullable String regionName)</code>：获取远程Eureka-Server获取注册的Applications集合。</li><li><code>getRemoteRegionRegistryFetchInterval()</code>：获取从远程Eureka-Server获取注册信息的时间间隔，单位为秒，默认为30s。</li></ul></li><li>限流相关：<ul><li><code>isRateLimiterEnabled()</code>：是否开启请求限流，默认为false。</li><li><code>isRateLimiterThrottleStandardClients()</code>：是否限制非标准客户端的访问，默认为false。标准客户端通过请求头的 <code>DiscoveryIdentity-Name</code> 来判断，是否在标准客户端名集合里。</li><li><code>getRateLimiterPrivilegedClients()</code>：获取标准客户端名集合。标准客户端名集合。默认包含<code>DefaultClient</code> 和 <code>DefaultServer</code> 。</li><li><code>getRateLimiterBurstSize()</code>：速率限制的burst size，默认为10。令牌桶算法。</li><li><code>getRateLimiterRegistryFetchAverageRate()</code>：指定增量获取注册信息的平均执行注册请求速率，默认为500。</li><li><code>getRateLimiterFullFetchAverageRate()</code>：指定全量获取注册信息的平均执行注册请求速率，默认为100。</li></ul></li><li><code>getEvictionIntervalTimerInMs()</code>：租约过期定时任务执行频率，单位为毫秒。默认为 60 * 1000 ms。</li></ul><h2 id="DefaultEurekaServerConfig"><a href="#DefaultEurekaServerConfig" class="headerlink" title="DefaultEurekaServerConfig"></a>DefaultEurekaServerConfig</h2><h3 id="DefaultEurekaServerConfig-1"><a href="#DefaultEurekaServerConfig-1" class="headerlink" title="DefaultEurekaServerConfig"></a>DefaultEurekaServerConfig</h3><p>所属包：<code>com.netflic.eureka.DefaultEurekaServerConfig</code>，<strong>基于配置文件的Eureka-Server配置实现类</strong>。 </p><h3 id="DefaultEurekaServerConfig源码"><a href="#DefaultEurekaServerConfig源码" class="headerlink" title="DefaultEurekaServerConfig源码"></a>DefaultEurekaServerConfig源码</h3><p>博主已添加中文注释，<a href="https://github.com/yoga0521/eureka/blob/master/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java" target="_blank" rel="noopener">点击查看</a>。</p><h3 id="DefaultEurekaServerConfig重要属性或者重要方法"><a href="#DefaultEurekaServerConfig重要属性或者重要方法" class="headerlink" title="DefaultEurekaServerConfig重要属性或者重要方法"></a>DefaultEurekaServerConfig重要属性或者重要方法</h3><ul><li>其他实现方法基本类似，都是从配置文件中获取值，举一个例子：<ul><li><code>shouldEnableSelfPreservation()</code>：是否开启自我保护模式，并传一个默认值（这里是true）。</li></ul></li></ul><h2 id="EurekaBootStrap"><a href="#EurekaBootStrap" class="headerlink" title="EurekaBootStrap"></a>EurekaBootStrap</h2><p><img src="https://raw.githubusercontent.com/yoga0521/picture/master/SpringCloud/Eureka/EurekaBootStrap%E7%B1%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="EurekaBootStrap类结构图"></p><h3 id="EurekaBootStrap简介"><a href="#EurekaBootStrap简介" class="headerlink" title="EurekaBootStrap简介"></a>EurekaBootStrap简介</h3><p>所属包：<code>com.netflix.eureka.EurekaBootStrap</code>，<strong>Eureka-Server启动入口</strong>。EurekaBootStrap 实现了 <code>javax.servlet.ServletContextListener</code> 接口，在 Servlet 容器( 例如 Tomcat、Jetty )启动时，调用 <code>contextInitialized()</code> 方法，初始化 Eureka-Server 。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaBootStrap</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 初始化Eureka配置环境</span></span><br><span class="line">            initEurekaEnvironment();</span><br><span class="line">            <span class="comment">// 初始化Eureka-Server上下文</span></span><br><span class="line">            initEurekaServerContext();</span><br><span class="line"></span><br><span class="line">            ServletContext sc = event.getServletContext();</span><br><span class="line">            sc.setAttribute(EurekaServerContext.class.getName(), serverContext);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            logger.error(<span class="string">"Cannot bootstrap eureka server :"</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot bootstrap eureka server :"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EurekaBootStrap源码"><a href="#EurekaBootStrap源码" class="headerlink" title="EurekaBootStrap源码"></a>EurekaBootStrap源码</h3><p>博主已添加中文注释，<a href="https://github.com/yoga0521/eureka/blob/master/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java" target="_blank" rel="noopener">点击查看</a>。</p><h3 id="EurekaBootStrap重要属性或者重要方法"><a href="#EurekaBootStrap重要属性或者重要方法" class="headerlink" title="EurekaBootStrap重要属性或者重要方法"></a>EurekaBootStrap重要属性或者重要方法</h3><ul><li><p>Eureka-Server上下文相关：</p><ul><li><p><code>com.netflix.eureka.EurekaServerContext</code>：<strong>Eureka-Server上下文接口</strong>，包含了<strong>初始化</strong>，<strong>关闭</strong>，<strong>获取EurekaServer配置对象</strong>，<strong>获取集群节点集合</strong>，<strong>获取编解码器</strong>，<strong>获取应用实例注册表</strong>，<strong>获取应用信息管理器</strong>这些方法。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EurekaServerContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">EurekaServerConfig <span class="title">getServerConfig</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">PeerEurekaNodes <span class="title">getPeerEurekaNodes</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ServerCodecs <span class="title">getServerCodecs</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">PeerAwareInstanceRegistry <span class="title">getRegistry</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ApplicationInfoManager <span class="title">getApplicationInfoManager</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>com.netflix.eureka.DefaultEurekaServerContext</code>：<strong>Eureka-Server上下文默认实现类</strong>，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultEurekaServerContext</span> <span class="keyword">implements</span> <span class="title">EurekaServerContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(DefaultEurekaServerContext.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Eureka-Server配置对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EurekaServerConfig serverConfig;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编解码器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerCodecs serverCodecs;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 应用实例信息注册表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PeerAwareInstanceRegistry registry;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Eureka-Server集群节点集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PeerEurekaNodes peerEurekaNodes;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 应用信息管理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApplicationInfoManager applicationInfoManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultEurekaServerContext</span><span class="params">(EurekaServerConfig serverConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">                               ServerCodecs serverCodecs,</span></span></span><br><span class="line"><span class="function"><span class="params">                               PeerAwareInstanceRegistry registry,</span></span></span><br><span class="line"><span class="function"><span class="params">                               PeerEurekaNodes peerEurekaNodes,</span></span></span><br><span class="line"><span class="function"><span class="params">                               ApplicationInfoManager applicationInfoManager)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serverConfig = serverConfig;</span><br><span class="line">        <span class="keyword">this</span>.serverCodecs = serverCodecs;</span><br><span class="line">        <span class="keyword">this</span>.registry = registry;</span><br><span class="line">        <span class="keyword">this</span>.peerEurekaNodes = peerEurekaNodes;</span><br><span class="line">        <span class="keyword">this</span>.applicationInfoManager = applicationInfoManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Initializing ..."</span>);</span><br><span class="line">        <span class="comment">// 启动Eureka-Server集群节点集合</span></span><br><span class="line">        peerEurekaNodes.start();</span><br><span class="line">        <span class="comment">// 初始化应用实例信息注册表</span></span><br><span class="line">        registry.init(peerEurekaNodes);</span><br><span class="line">        logger.info(<span class="string">"Initialized"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Shutting down ..."</span>);</span><br><span class="line">        <span class="comment">// 关闭应用实例信息注册表</span></span><br><span class="line">        registry.shutdown();</span><br><span class="line">        <span class="comment">// 关闭Eureka-Server集群节点集合</span></span><br><span class="line">        peerEurekaNodes.shutdown();</span><br><span class="line">        logger.info(<span class="string">"Shut down"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EurekaServerConfig <span class="title">getServerConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serverConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PeerEurekaNodes <span class="title">getPeerEurekaNodes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> peerEurekaNodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerCodecs <span class="title">getServerCodecs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serverCodecs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PeerAwareInstanceRegistry <span class="title">getRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> registry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationInfoManager <span class="title">getApplicationInfoManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> applicationInfoManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>com.netflix.eureka.EurekaServerContextHolder</code>：<strong>Eureka-Server上下文持有者</strong>，可以通过它获取上下文，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerContextHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Eureka-Server上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EurekaServerContext serverContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EurekaServerContextHolder</span><span class="params">(EurekaServerContext serverContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serverContext = serverContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取Eureka-Server上下文</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Eureka-Server上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EurekaServerContext <span class="title">getServerContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.serverContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Eureka-Server上下文持有者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> EurekaServerContextHolder holder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serverContext Eureka-Server上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(EurekaServerContext serverContext)</span> </span>&#123;</span><br><span class="line">        holder = <span class="keyword">new</span> EurekaServerContextHolder(serverContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取Eureka-Server上下文持有者</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Eureka-Server上下文持有者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EurekaServerContextHolder <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> holder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="StatusFilter"><a href="#StatusFilter" class="headerlink" title="StatusFilter"></a>StatusFilter</h2><h3 id="StatusFilter简介"><a href="#StatusFilter简介" class="headerlink" title="StatusFilter简介"></a>StatusFilter简介</h3><p>所属包：<code>com.netflix.eureka.StatusFilter</code>，<strong>根据<code>InstanceStatus</code>过滤Eureka-Server</strong>。当 Eureka-Server 未处于开启( <code>InstanceStatus.UP</code> )状态，返回 HTTP 状态码 307 重定向 。</p><h3 id="StatusFilter源码"><a href="#StatusFilter源码" class="headerlink" title="StatusFilter源码"></a>StatusFilter源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                         FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    InstanceInfo myInfo = ApplicationInfoManager.getInstance().getInfo();</span><br><span class="line">    InstanceStatus status = myInfo.getStatus();</span><br><span class="line">    <span class="keyword">if</span> (status != InstanceStatus.UP &amp;&amp; response <span class="keyword">instanceof</span> HttpServletResponse) &#123;</span><br><span class="line">        HttpServletResponse httpRespone = (HttpServletResponse) response;</span><br><span class="line">        httpRespone.sendError(SC_TEMPORARY_REDIRECT,</span><br><span class="line">                              <span class="string">"Current node is currently not ready to serve requests -- current status: "</span></span><br><span class="line">                              + status + <span class="string">" - try another DS node: "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ServerRequestAuthFilter"><a href="#ServerRequestAuthFilter" class="headerlink" title="ServerRequestAuthFilter"></a>ServerRequestAuthFilter</h2><h3 id="ServerRequestAuthFilter简介"><a href="#ServerRequestAuthFilter简介" class="headerlink" title="ServerRequestAuthFilter简介"></a>ServerRequestAuthFilter简介</h3><p>所属包：<code>com.netflix.eureka.ServerRequestAuthFilter</code>，<strong>用于客户端请求的身份验证过滤器</strong>。目前，它只记录来自标题信息的支持的客户端标识数据。</p><h3 id="ServerRequestAuthFilter源码"><a href="#ServerRequestAuthFilter源码" class="headerlink" title="ServerRequestAuthFilter源码"></a>ServerRequestAuthFilter源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">logAuth</span><span class="params">(ServletRequest request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (serverConfig.shouldLogIdentityHeaders()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (request <span class="keyword">instanceof</span> HttpServletRequest) &#123;</span><br><span class="line">            HttpServletRequest httpRequest = (HttpServletRequest) request;</span><br><span class="line"></span><br><span class="line">            String clientName = getHeader(httpRequest, AbstractEurekaIdentity.AUTH_NAME_HEADER_KEY);</span><br><span class="line">            String clientVersion = getHeader(httpRequest, AbstractEurekaIdentity.AUTH_VERSION_HEADER_KEY);</span><br><span class="line"></span><br><span class="line">            DynamicCounter.increment(MonitorConfig.builder(NAME_PREFIX + clientName + <span class="string">"-"</span> + clientVersion).build());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getHeader</span><span class="params">(HttpServletRequest request, String headerKey)</span> </span>&#123;</span><br><span class="line">    String value = request.getHeader(headerKey);</span><br><span class="line">    <span class="keyword">return</span> Strings.isNullOrEmpty(value) ? UNKNOWN : value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RateLimitingFilter"><a href="#RateLimitingFilter" class="headerlink" title="RateLimitingFilter"></a>RateLimitingFilter</h2><h3 id="RateLimitingFilter简介"><a href="#RateLimitingFilter简介" class="headerlink" title="RateLimitingFilter简介"></a>RateLimitingFilter简介</h3><p>所属包：<code>com.netflix.eureka.RateLimitingFilter</code>，<strong>请求速率限制过滤器</strong>。</p><h2 id="GzipEncodingEnforcingFilter"><a href="#GzipEncodingEnforcingFilter" class="headerlink" title="GzipEncodingEnforcingFilter"></a>GzipEncodingEnforcingFilter</h2><h3 id="GzipEncodingEnforcingFilter简介"><a href="#GzipEncodingEnforcingFilter简介" class="headerlink" title="GzipEncodingEnforcingFilter简介"></a>GzipEncodingEnforcingFilter简介</h3><p>所属包：<code>com.netflix.eureka.GzipEncodingEnforcingFilter</code>，<strong>gzip编码</strong>。最初Eureka仅支持非压缩响应, 对于大型注册管理机构来说，它非常低效，因此增加了gzip编码。如今，所有现代HTTP客户端都透明地支持gzip HTTP响应，因此不再需要维护未压缩的内容。 通过添加此过滤器，Eureka 服务器将只接受明确支持gzip编码回复的GET请求。, 在即将到来的次要版本中，非压缩回复将完全丢弃，因此此过滤器将成为必需。</p><h3 id="GzipEncodingEnforcingFilter源码"><a href="#GzipEncodingEnforcingFilter源码" class="headerlink" title="GzipEncodingEnforcingFilter源码"></a>GzipEncodingEnforcingFilter源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    HttpServletRequest httpRequest = (HttpServletRequest) request;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"GET"</span>.equals(httpRequest.getMethod())) &#123;</span><br><span class="line">        String acceptEncoding = httpRequest.getHeader(HttpHeaders.ACCEPT_ENCODING);</span><br><span class="line">        <span class="keyword">if</span> (acceptEncoding == <span class="keyword">null</span>) &#123;</span><br><span class="line">            chain.doFilter(addGzipAcceptEncoding(httpRequest), response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!acceptEncoding.contains(<span class="string">"gzip"</span>)) &#123;</span><br><span class="line">            ((HttpServletResponse) response).setStatus(HttpServletResponse.SC_NOT_ACCEPTABLE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> HttpServletRequest <span class="title">addGzipAcceptEncoding</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HttpServletRequestWrapper(request) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title">getHeaders</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (HttpHeaders.ACCEPT_ENCODING.equals(name)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> EnumWrapper&lt;String&gt;(<span class="string">"gzip"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> EnumWrapper&lt;String&gt;(<span class="keyword">super</span>.getHeaders(name), HttpHeaders.ACCEPT_ENCODING);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title">getHeaderNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> EnumWrapper&lt;String&gt;(<span class="keyword">super</span>.getHeaderNames(), HttpHeaders.ACCEPT_ENCODING);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getHeader</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (HttpHeaders.ACCEPT_ENCODING.equals(name)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"gzip"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.getHeader(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumWrapper</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Enumeration</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Enumeration&lt;E&gt; delegate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;E&gt; extraElementRef;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EnumWrapper</span><span class="params">(E extraElement)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, extraElement);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EnumWrapper</span><span class="params">(Enumeration&lt;E&gt; delegate, E extraElement)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">        <span class="keyword">this</span>.extraElementRef = <span class="keyword">new</span> AtomicReference&lt;&gt;(extraElement);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> extraElementRef.get() != <span class="keyword">null</span> || delegate != <span class="keyword">null</span> &amp;&amp; delegate.hasMoreElements();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">nextElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        E extra = extraElementRef.getAndSet(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (extra != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> extra;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (delegate == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> delegate.nextElement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ServletContainer"><a href="#ServletContainer" class="headerlink" title="ServletContainer"></a>ServletContainer</h2><h3 id="ServletContainer简介"><a href="#ServletContainer简介" class="headerlink" title="ServletContainer简介"></a>ServletContainer简介</h3><p>所属包：<code>com.sun.jersey.spi.container.servlet.ServletContainer</code>，<strong>Jersey MVC 请求过滤器</strong>。 </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们可以看到Eureka-Server的生成，是EurekaBootStrap实现了 <code>javax.servlet.ServletContextListener</code> 接口，在 Servlet 容器( 例如 Tomcat、Jetty )启动时，调用 <code>contextInitialized()</code> 方法初始化Eureka-Server。Eureka-Server内嵌 Eureka-Client，用于和Eureka-Server集群里其他节点通信交互。</p><p>欢迎关注博主其他的文章。 </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本篇文章主要解读Eureka-Server初始化的相关源码，文章较长，请谨慎点击！&lt;/p&gt;
    
    </summary>
    
      <category term="SpringCloud" scheme="https://yoga0521.github.io/categories/SpringCloud/"/>
    
      <category term="Eureka" scheme="https://yoga0521.github.io/categories/SpringCloud/Eureka/"/>
    
    
      <category term="Eureka" scheme="https://yoga0521.github.io/tags/Eureka/"/>
    
      <category term="SpringCloud" scheme="https://yoga0521.github.io/tags/SpringCloud/"/>
    
      <category term="微服务" scheme="https://yoga0521.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Eureka源码—EurekaClient</title>
    <link href="https://yoga0521.github.io/2018/03/21/Eureka%E6%BA%90%E7%A0%81%E2%80%94EurekaClient/"/>
    <id>https://yoga0521.github.io/2018/03/21/Eureka源码—EurekaClient/</id>
    <published>2018-03-21T12:19:14.000Z</published>
    <updated>2018-05-22T13:25:58.604Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇文章主要解读Eureka-Client初始化的相关源码，文章较长，请谨慎点击！</p><a id="more"></a><h2 id="EurekaInstanceConfig"><a href="#EurekaInstanceConfig" class="headerlink" title="EurekaInstanceConfig"></a>EurekaInstanceConfig</h2><p><img src="https://raw.githubusercontent.com/yoga0521/picture/master/SpringCloud/Eureka/MyDataCenterInstanceConfig%E7%B1%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="MyDataCenterInstanceConfig类结构图"></p><h3 id="EurekaInstanceConfig简介"><a href="#EurekaInstanceConfig简介" class="headerlink" title="EurekaInstanceConfig简介"></a>EurekaInstanceConfig简介</h3><p>所属包：<code>com.netflix.appinfo.EurekaInstanceConfig</code>，<strong>Eureka 应用实例配置接口</strong>（Application Provider，Application Consumer）。</p><h3 id="EurekaInstanceConfig源码"><a href="#EurekaInstanceConfig源码" class="headerlink" title="EurekaInstanceConfig源码"></a>EurekaInstanceConfig源码</h3><p>博主已添加中文注释，<a href="https://github.com/yoga0521/eureka/blob/master/eureka-client/src/main/java/com/netflix/appinfo/EurekaInstanceConfig.java" target="_blank" rel="noopener">点击查看</a>。</p><h3 id="EurekaInstanceConfig重要属性或者重要方法"><a href="#EurekaInstanceConfig重要属性或者重要方法" class="headerlink" title="EurekaInstanceConfig重要属性或者重要方法"></a>EurekaInstanceConfig重要属性或者重要方法</h3><ul><li><code>getInstanceId()</code>获取实例id，组成结构为<code>${spring.application.name}:${spring.application.instance_id:${random.value}}</code>默认为null。</li><li><code>geAppName()</code>获取应用名，默认为”unknown”。</li></ul><ul><li><p><code>getLeaseRenewalIntervalInSeconds()</code>获取租约续约频率，单位为秒。默认为30s。应用发送心跳给Eureka-Server进行续约（告诉Eureka-Server自己还活着）。</p></li><li><p><code>getLeaseExpirationDurationInSeconds()</code> 获取租约过期时间，单位为秒。默认为90s。如果超过该时间，应用还没有向Eureka-Server发送心跳，那该租约就过期了，Eureka-Serever会进行应用移除。</p></li><li><p><code>getMetadataMap()</code>获取实例的元数据。如果你想自定义一些数据，在各服务之间使用，就需要该方法。</p></li><li><p><code>getHealthCheckUrlPath()</code>,<code>getHealthCheckUrl()</code>,<code>getSecureHealthCheckUrl()</code>健康检查相关的几个方法。</p></li><li><p><code>getNamespace()</code>获取命名空间，已配置对应的eureka属性，默认为<code>eureka</code>。</p><p>​</p></li></ul><h2 id="AbstractInstanceConfig"><a href="#AbstractInstanceConfig" class="headerlink" title="AbstractInstanceConfig"></a>AbstractInstanceConfig</h2><h3 id="AbstractInstanceConfig简介"><a href="#AbstractInstanceConfig简介" class="headerlink" title="AbstractInstanceConfig简介"></a>AbstractInstanceConfig简介</h3><p>所属包：<code>com.netflix.appinfo.AbstractInstanceConfig</code>，<strong>Eureka 应用实例配置抽象基类，主要实现一些相对通用的配置</strong></p><h3 id="AbstractInstanceConfig源码"><a href="#AbstractInstanceConfig源码" class="headerlink" title="AbstractInstanceConfig源码"></a>AbstractInstanceConfig源码</h3><p>博主已添加中文注释，<a href="https://github.com/yoga0521/eureka/blob/master/eureka-client/src/main/java/com/netflix/appinfo/AbstractInstanceConfig.java" target="_blank" rel="noopener">点击查看</a>。</p><h3 id="AbstractInstanceConfig重要属性或者重要方法"><a href="#AbstractInstanceConfig重要属性或者重要方法" class="headerlink" title="AbstractInstanceConfig重要属性或者重要方法"></a>AbstractInstanceConfig重要属性或者重要方法</h3><ul><li>主要设置一些基础的属性，以及对应的get/set方法</li><li><code>getHostInfo()</code>获取本地服务器的主机名和主机IP地址</li></ul><h2 id="PropertiesInstanceConfig"><a href="#PropertiesInstanceConfig" class="headerlink" title="PropertiesInstanceConfig"></a>PropertiesInstanceConfig</h2><h3 id="PropertiesInstanceConfig简介"><a href="#PropertiesInstanceConfig简介" class="headerlink" title="PropertiesInstanceConfig简介"></a>PropertiesInstanceConfig简介</h3><p>所属包：<code>com.netflix.appinfo.PropertiesInstanceConfig</code>，<strong>通过配置文件进行Eureka实例配置的抽象基类</strong></p><h3 id="PropertiesInstanceConfig源码"><a href="#PropertiesInstanceConfig源码" class="headerlink" title="PropertiesInstanceConfig源码"></a>PropertiesInstanceConfig源码</h3><p>博主已添加中文注释，<a href="https://github.com/yoga0521/eureka/blob/master/eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java" target="_blank" rel="noopener">点击查看</a>。</p><h3 id="PropertiesInstanceConfig重要属性或者重要方法"><a href="#PropertiesInstanceConfig重要属性或者重要方法" class="headerlink" title="PropertiesInstanceConfig重要属性或者重要方法"></a>PropertiesInstanceConfig重要属性或者重要方法</h3><ul><li><p><code>namespace</code>命名空间。</p></li><li><p><code>configInstance</code>配置文件，基于<a href="https://github.com/Netflix/archaius" target="_blank" rel="noopener">Netflix Archaius 1.x</a> 实现读取配置文件。基于<a href="https://github.com/Netflix/archaius/tree/2.x" target="_blank" rel="noopener">Netflix Archaius 2.x</a> 的还在开发中。</p></li><li><p><code>appGrpNameFromEnv</code>从环境变量中获取应用分组，<code>ConfigurationManager.getConfigInstance</code>获取当前的系统范围配置。</p></li><li><p><code>Archaius1Utils.initConfig(CommonConstants.CONFIG_FILE_NAME)</code>，<code>CommonConstants.CONFIG_FILE_NAME</code>为<code>eureka-client</code>，<code>Archaius1Utils.initConfig</code>方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Archaius1Utils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(Archaius1Utils.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ARCHAIUS_DEPLOYMENT_ENVIRONMENT = <span class="string">"archaius.deployment.environment"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EUREKA_ENVIRONMENT = <span class="string">"eureka.environment"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DynamicPropertyFactory <span class="title">initConfig</span><span class="params">(String configName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置文件对象</span></span><br><span class="line">        DynamicPropertyFactory configInstance = DynamicPropertyFactory.getInstance();</span><br><span class="line">        <span class="comment">// 配置文件名，如果configName没有配置，即为CommonConstants.CONFIG_FILE_NAME（"eureka-client"）</span></span><br><span class="line">        DynamicStringProperty EUREKA_PROPS_FILE = configInstance.getStringProperty(<span class="string">"eureka.client.props"</span>, configName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置文件环境</span></span><br><span class="line">        String env = ConfigurationManager.getConfigInstance().getString(EUREKA_ENVIRONMENT, <span class="string">"test"</span>);</span><br><span class="line">        <span class="comment">// 将配置文件加载到环境变量</span></span><br><span class="line">        ConfigurationManager.getConfigInstance().setProperty(ARCHAIUS_DEPLOYMENT_ENVIRONMENT, env);</span><br><span class="line"></span><br><span class="line">        String eurekaPropsFile = EUREKA_PROPS_FILE.get();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//读取配置文件到环境变量，首先读取 $&#123;eureka.client.props&#125; 对应的配置文件；然后读取 $&#123;eureka.client.props&#125;-$&#123;eureka.environment&#125; 对应的配置文件。若有相同属性，进行覆盖。</span></span><br><span class="line">            ConfigurationManager.loadCascadedPropertiesFromResources(eurekaPropsFile);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.warn(</span><br><span class="line">                <span class="string">"Cannot find the properties specified : &#123;&#125;. This may be okay if there are other environment "</span></span><br><span class="line">                + <span class="string">"specific properties or the configuration is installed with a different mechanism."</span>,</span><br><span class="line">                eurekaPropsFile);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> configInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>其他实现方法基本类似，都是从配置文件中获取值，举一个例子：</p><p>​    <code>isInstanceEnabledOnit()</code>：从配置文件中获取是否在实例初始化的时候开启，并传一个默认值（这里是父类AbstractInstanceConfig中实现的方法），namespace的属性key都在PropertyBasedInstanceConfigConstants中</p></li></ul><h2 id="MyDataCenterInstanceConfig"><a href="#MyDataCenterInstanceConfig" class="headerlink" title="MyDataCenterInstanceConfig"></a>MyDataCenterInstanceConfig</h2><h3 id="MyDataCenterInstanceConfig简介"><a href="#MyDataCenterInstanceConfig简介" class="headerlink" title="MyDataCenterInstanceConfig简介"></a>MyDataCenterInstanceConfig简介</h3><p>所属包：<code>com.netflix.appinfo.MyDataCenterInstanceConfig</code>，<strong>Eureka应用实例配置实现类</strong></p><h3 id="MyDataCenterInstanceConfig源码"><a href="#MyDataCenterInstanceConfig源码" class="headerlink" title="MyDataCenterInstanceConfig源码"></a>MyDataCenterInstanceConfig源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDataCenterInstanceConfig</span> <span class="keyword">extends</span> <span class="title">PropertiesInstanceConfig</span> <span class="keyword">implements</span> <span class="title">EurekaInstanceConfig</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyDataCenterInstanceConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyDataCenterInstanceConfig</span><span class="params">(String namespace)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用父类含有namespace参数的构造函数进行初始化</span></span><br><span class="line">        <span class="keyword">super</span>(namespace);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyDataCenterInstanceConfig</span><span class="params">(String namespace, DataCenterInfo dataCenterInfo)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用父类含有namespace和dataCenterInfo参数的构造函数进行初始化</span></span><br><span class="line">        <span class="keyword">super</span>(namespace, dataCenterInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="InstanceInfo"><a href="#InstanceInfo" class="headerlink" title="InstanceInfo"></a>InstanceInfo</h2><h3 id="InstanceInfo简介"><a href="#InstanceInfo简介" class="headerlink" title="InstanceInfo简介"></a>InstanceInfo简介</h3><p>所属包：<code>com.netflix.appinfo.InstanceInfo</code>，<strong>应用实例信息</strong>。Eureka-Client 向 Eureka-Server 注册该对象信息。注册成功后，可以被其他 Eureka-Client 发现。Eureka通过<code>com.netflix.appinfo.providers.EurekaConfigBasedInstanceInfoProvider</code>基于<code>EurekaInstanceConfig</code>创建<code>InstanceInfo</code>。</p><h3 id="EurekaConfigBasedInstanceInfoProvider源码"><a href="#EurekaConfigBasedInstanceInfoProvider源码" class="headerlink" title="EurekaConfigBasedInstanceInfoProvider源码"></a>EurekaConfigBasedInstanceInfoProvider源码</h3><p>博主已添加中文注释，<a href="https://github.com/yoga0521/eureka/blob/master/eureka-client/src/main/java/com/netflix/appinfo/providers/EurekaConfigBasedInstanceInfoProvider.java" target="_blank" rel="noopener">点击查看</a>。</p><h3 id="EurekaConfigBasedInstanceInfoProvider重要属性或者重要方法"><a href="#EurekaConfigBasedInstanceInfoProvider重要属性或者重要方法" class="headerlink" title="EurekaConfigBasedInstanceInfoProvider重要属性或者重要方法"></a>EurekaConfigBasedInstanceInfoProvider重要属性或者重要方法</h3><ul><li><p>基本上每个属性和每个方法都添加了注释</p></li><li><p>其中vip地址解析器源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">VipAddressResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Convert &lt;code&gt;VIPAddress&lt;/code&gt; by substituting environment variables if necessary.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vipAddressMacro the macro for which the interpolation needs to be made.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a string representing the final &lt;code&gt;VIPAddress&lt;/code&gt; after substitution.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">resolveDeploymentContextBasedVipAddresses</span><span class="params">(String vipAddressMacro)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类源码（Archaius1实现，Archaius2还在开发中）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Archaius1VipAddressResolver</span> <span class="keyword">implements</span> <span class="title">VipAddressResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(Archaius1VipAddressResolver.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern VIP_ATTRIBUTES_PATTERN = Pattern.compile(<span class="string">"\\$\\&#123;(.*?)\\&#125;"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">resolveDeploymentContextBasedVipAddresses</span><span class="params">(String vipAddressMacro)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (vipAddressMacro == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String result = vipAddressMacro;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//匹配$&#123;(.*?)&#125;</span></span><br><span class="line">        Matcher matcher = VIP_ATTRIBUTES_PATTERN.matcher(result);</span><br><span class="line">        <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">            String key = matcher.group(<span class="number">1</span>);</span><br><span class="line">            String value = DynamicPropertyFactory.getInstance().getStringProperty(key, <span class="string">""</span>).get();</span><br><span class="line"></span><br><span class="line">            logger.debug(<span class="string">"att:&#123;&#125;"</span>, matcher.group());</span><br><span class="line">            logger.debug(<span class="string">", att key:&#123;&#125;"</span>, key);</span><br><span class="line">            logger.debug(<span class="string">", att value:&#123;&#125;"</span>, value);</span><br><span class="line">            logger.debug(<span class="string">""</span>);</span><br><span class="line">            <span class="comment">//将$&#123;(.*?)&#125;替换为配置文件中对应的value</span></span><br><span class="line">            result = result.replaceAll(<span class="string">"\\$\\&#123;"</span> + key + <span class="string">"\\&#125;"</span>, value);</span><br><span class="line">            matcher = VIP_ATTRIBUTES_PATTERN.matcher(result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="ApplicationInfoManager"><a href="#ApplicationInfoManager" class="headerlink" title="ApplicationInfoManager"></a>ApplicationInfoManager</h2><h3 id="ApplicationInfoManager简介"><a href="#ApplicationInfoManager简介" class="headerlink" title="ApplicationInfoManager简介"></a>ApplicationInfoManager简介</h3><p>所属包：<code>com.netflix.appinfo.ApplicationInfoManager</code>，<strong>应用信息管理类</strong>，由<code>InstanceInfo</code>和<code>EurekaInstanceConfig</code>生成。</p><h3 id="ApplicationInfoManager源码"><a href="#ApplicationInfoManager源码" class="headerlink" title="ApplicationInfoManager源码"></a>ApplicationInfoManager源码</h3><p>博主已添加中文注释，<a href="https://github.com/yoga0521/eureka/blob/master/eureka-client/src/main/java/com/netflix/appinfo/ApplicationInfoManager.java" target="_blank" rel="noopener">点击查看</a>。</p><h2 id="EurekaClientConfig"><a href="#EurekaClientConfig" class="headerlink" title="EurekaClientConfig"></a>EurekaClientConfig</h2><h3 id="EurekaClientConfig简介"><a href="#EurekaClientConfig简介" class="headerlink" title="EurekaClientConfig简介"></a>EurekaClientConfig简介</h3><p>所属包：<code>com.netflix.discovery.EurekaClientConfig</code>，<strong>Eureka-Client 配置接口</strong>，获取连接的 Eureka-Server 的地址、获取服务提供者列表的频率、注册自身为服务提供者的频率等等。</p><h3 id="EurekaClientConfig源码"><a href="#EurekaClientConfig源码" class="headerlink" title="EurekaClientConfig源码"></a>EurekaClientConfig源码</h3><p>博主已添加中文注释，<a href="https://github.com/yoga0521/eureka/blob/master/eureka-client/src/main/java/com/netflix/discovery/EurekaClientConfig.java" target="_blank" rel="noopener">点击查看</a>。</p><h3 id="EurekaClientConfig重要属性或者重要方法"><a href="#EurekaClientConfig重要属性或者重要方法" class="headerlink" title="EurekaClientConfig重要属性或者重要方法"></a>EurekaClientConfig重要属性或者重要方法</h3><ul><li><code>getRegion()</code>，<code>getAvailabilityZones()</code>：region和zone（或者Availability Zone）均是AWS的概念。在非AWS环境下，我们可以简单地将region理解为Eureka集群，zone理解成机房。Spring Cloud中默认的region是us-east-1 。具体可查看<a href="http://www.itmuch.com/spring-cloud-1/?from=www.iocoder.cn" target="_blank" rel="noopener">《周立 —— Region、Zone解析》</a>。</li><li><code>getEurekaServerServiceUrls()</code>：获取Eureka-Server的Url集合</li><li>从Eureka-Server获取注册信息的相关方法：<ul><li><code>getRegistryFetchIntervalSeconds()</code>：获取注册信息的时间间隔，单位为秒。默认为30s</li><li><code>getEurekaServiceUrlPollIntervalSeconds()</code>：向Eureka-Server获取Eureka服务地址的变化时间间隔，单位为秒。默认为 5 * 60 * 1000 s</li><li><code>getEurekaServerReadTimeoutSeconds()</code>：获取Eureka-Server读取超时时间，单位为秒。默认为8s</li><li><code>getBackupRegistryImpl()</code>：获取备份注册中心实现类。默认为null</li><li><code>shouldPreferSameZoneEureka()</code>：相同Zone的Eureka是否优先。默认为true</li><li><code>shouldDisableDelta()</code>：是否使用增量形式获取注册信息。默认为false</li><li><code>fetchRegistryForRemoteRegions()</code>：获取远程区域的注册信息。默认为null</li><li><code>shouldFilterOnlyUpInstances()</code>：是否只获取Up（启动）状态的实例。默认为true</li><li><code>shouldFetchRegistry()</code>：是否从Eureka-Server获取注册信息。默认为true</li><li><code>getRegistryRefreshSingleVipAddress()</code>：获取单个vip地址（虚拟IP地址）的注册信息。默认为null</li><li><code>getCacheRefreshExecutorThreadPoolSize()</code>：获取注册信息缓存刷新的线程池大小。默认为5</li><li><code>getCacheRefreshExecutorExponentialBackOffBound()</code>：获取注册信息缓存刷新执行超时后的延迟重试时间的最大倍数。默认为10</li></ul></li><li>向Eureka-Server注册自身服务的相关方法：<ul><li><code>getInstanceInfoReplicationIntervalSeconds()</code>：获取向Eureka-Server同步实例信息的时间间隔，单位为秒。默认为30s</li><li><code>getInitialInstanceInfoReplicationIntervalSeconds()</code>：获取最初向Eureka-Server同步实例信息的时间间隔，单位为秒。默认为40s</li><li><code>getEurekaServerConnectTimeoutSeconds()</code>：获取Eureka-Server连接超时时间，单位为秒。默认为5s</li><li><code>shouldRegisterWithEureka()</code>：是否向Eureka-Server注册自身服务。默认为true</li><li><code>shouldUnregisterOnShutdown()</code>：当Eureka-Server关闭的时候，是否注销自己的服务。默认为true</li><li><code>getHeartbeatExecutorThreadPoolSize()</code>：获取心跳检测执行的线程池大小。默认为5</li><li><code>getHeartbeatExecutorExponentialBackOffBound()</code>：获取心跳检测执行超时后的延迟重试时间的最大倍数。默认为10</li><li><code>shouldEnforceRegistrationAtInit()</code>：是否在实例初始化的时候进行注册。默认为false</li></ul></li></ul><h2 id="DefaultEurekaClientConfig"><a href="#DefaultEurekaClientConfig" class="headerlink" title="DefaultEurekaClientConfig"></a>DefaultEurekaClientConfig</h2><h3 id="DefaultEurekaClientConfig简介"><a href="#DefaultEurekaClientConfig简介" class="headerlink" title="DefaultEurekaClientConfig简介"></a>DefaultEurekaClientConfig简介</h3><p>所属包：<code>com.netflix.discovery.DefaultEurekaClientConfig</code>，<strong>基于配置文件的Eureka-Client配置实现类</strong>。</p><h3 id="DefaultEurekaClientConfig源码"><a href="#DefaultEurekaClientConfig源码" class="headerlink" title="DefaultEurekaClientConfig源码"></a>DefaultEurekaClientConfig源码</h3><p>博主已添加中文注释，<a href="https://github.com/yoga0521/eureka/blob/master/eureka-client/src/main/java/com/netflix/discovery/DefaultEurekaClientConfig.java" target="_blank" rel="noopener">点击查看</a>。</p><h3 id="DefaultEurekaClientConfig重要属性或者重要方法"><a href="#DefaultEurekaClientConfig重要属性或者重要方法" class="headerlink" title="DefaultEurekaClientConfig重要属性或者重要方法"></a>DefaultEurekaClientConfig重要属性或者重要方法</h3><ul><li>其中属性和构造方法基本上都加了中文注释。</li><li><p>其他实现方法基本类似，都是从配置文件中获取值，举一个例子：</p><pre><code>`getRegistryFetchIntervalSeconds()`：从配置文件中获取读取注册信息的时间间隔，并传一个默认值（这里是30），namespace后面的属性key都在PropertyBasedClientConfigConstants中。</code></pre></li></ul><h2 id="DefaultEurekaClientConfigProvider"><a href="#DefaultEurekaClientConfigProvider" class="headerlink" title="DefaultEurekaClientConfigProvider"></a>DefaultEurekaClientConfigProvider</h2><h3 id="DefaultEurekaClientConfigProvider简介"><a href="#DefaultEurekaClientConfigProvider简介" class="headerlink" title="DefaultEurekaClientConfigProvider简介"></a>DefaultEurekaClientConfigProvider简介</h3><p>所属包：<code>com.netflix.discovery.providers.DefaultEurekaClientConfigProvider</code>，<strong>创建 DefaultEurekaClientConfig 的工厂 </strong>。</p><h3 id="DefaultEurekaClientConfigProvider源码"><a href="#DefaultEurekaClientConfigProvider源码" class="headerlink" title="DefaultEurekaClientConfigProvider源码"></a>DefaultEurekaClientConfigProvider源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultEurekaClientConfigProvider</span> <span class="keyword">implements</span> <span class="title">Provider</span>&lt;<span class="title">EurekaClientConfig</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span>(optional = <span class="keyword">true</span>)</span><br><span class="line">    <span class="meta">@EurekaNamespace</span></span><br><span class="line">    <span class="keyword">private</span> String namespace;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DefaultEurekaClientConfig config;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> EurekaClientConfig <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (config == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//根据命名空间是否为空来判断调用哪一个构造方法创建DefaultEurekaClientConfigProvider</span></span><br><span class="line">            config = (namespace == <span class="keyword">null</span>)</span><br><span class="line">                    ? <span class="keyword">new</span> DefaultEurekaClientConfig()</span><br><span class="line">                    : <span class="keyword">new</span> DefaultEurekaClientConfig(namespace);</span><br><span class="line">                    </span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Remove this when DiscoveryManager is finally no longer used</span></span><br><span class="line">            DiscoveryManager.getInstance().setEurekaClientConfig(config);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单的一个类，不做过多的分析。</p><h2 id="EurekaTransportConfig"><a href="#EurekaTransportConfig" class="headerlink" title="EurekaTransportConfig"></a>EurekaTransportConfig</h2><h3 id="EurekaTransportConfig简介"><a href="#EurekaTransportConfig简介" class="headerlink" title="EurekaTransportConfig简介"></a>EurekaTransportConfig简介</h3><p>所属包：<code>com.netflix.discovery.shared.transport.EurekaTransportConfig</code>，<strong>Eureka网络传输配置接口</strong>。</p><h3 id="EurekaTransportConfig源码"><a href="#EurekaTransportConfig源码" class="headerlink" title="EurekaTransportConfig源码"></a>EurekaTransportConfig源码</h3><p>博主已添加中文注释，<a href="https://github.com/yoga0521/eureka/blob/master/eureka-client/src/main/java/com/netflix/discovery/shared/transport/EurekaTransportConfig.java" target="_blank" rel="noopener">点击查看</a>。</p><h3 id="EurekaTransportConfig重要属性或者重要方法"><a href="#EurekaTransportConfig重要属性或者重要方法" class="headerlink" title="EurekaTransportConfig重要属性或者重要方法"></a>EurekaTransportConfig重要属性或者重要方法</h3><ul><li><code>getSessionedClientReconnectIntervalSeconds()</code>：Eureka-Client 会话重新连接的时间间隔，单位为秒，默认为20 * 60s。</li><li><code>getRetryableClientQuarantineRefreshPercentage()</code>：请求失败的Eureka-Client隔离集合占Eureka-Client总数的占比，超过该比例会进行清空，默认为0.66。</li><li>Endpoint相关：<ul><li><code>getAsyncResolverRefreshIntervalMs()</code>：异步解析 EndPoint 集群频率，单位为毫秒。默认为5 * 60 * 1000ms。</li><li><code>getAsyncResolverWarmUpTimeoutMs()</code>：异步解析器预热解析 EndPoint 集群超时时间，单位为毫秒。默认为5000s。</li><li><code>getAsyncExecutorThreadPoolSize()</code>：异步线程池大小，默认为5。</li></ul></li></ul><h2 id="DefaultEurekaTransportConfig"><a href="#DefaultEurekaTransportConfig" class="headerlink" title="DefaultEurekaTransportConfig"></a>DefaultEurekaTransportConfig</h2><h3 id="DefaultEurekaTransportConfig简介"><a href="#DefaultEurekaTransportConfig简介" class="headerlink" title="DefaultEurekaTransportConfig简介"></a>DefaultEurekaTransportConfig简介</h3><p>所属包：<code>com.netflix.discovery.shared.transport.DefaultEurekaTransportConfig</code>，<strong>基于配置文件的网络传输配置实现类</strong> 。</p><h3 id="DefaultEurekaTransportConfig源码"><a href="#DefaultEurekaTransportConfig源码" class="headerlink" title="DefaultEurekaTransportConfig源码"></a>DefaultEurekaTransportConfig源码</h3><p>博主已添加中文注释，<a href="https://github.com/yoga0521/eureka/blob/master/eureka-client/src/main/java/com/netflix/discovery/shared/transport/DefaultEurekaTransportConfig.java" target="_blank" rel="noopener">点击查看</a>。</p><h3 id="DefaultEurekaTransportConfig重要属性或者重要方法"><a href="#DefaultEurekaTransportConfig重要属性或者重要方法" class="headerlink" title="DefaultEurekaTransportConfig重要属性或者重要方法"></a>DefaultEurekaTransportConfig重要属性或者重要方法</h3><ul><li>其他实现方法基本类似，都是从配置文件中获取值，举一个例子：<ul><li><code>getSessionedClientReconnectIntervalSeconds()</code>：Eureka-Client 会话重新连接的时间间隔，并传一个默认值（这里是20 * 60），namespace的属性key都在PropertyBasedTransportConfigConstants中。</li></ul></li></ul><h2 id="LookupService"><a href="#LookupService" class="headerlink" title="LookupService"></a>LookupService</h2><h3 id="LookupService简介"><a href="#LookupService简介" class="headerlink" title="LookupService简介"></a>LookupService简介</h3><p>所属包：<code>com.netflix.discovery.shared.LookupService</code>，<strong>查找服务接口</strong>，可以获取应用集合和应用实例集合。</p><ul><li>在 Eureka-Client 里，EurekaClient 继承该接口。</li><li>在 Eureka-Server 里，<code>com.netflix.eureka.registry.InstanceRegistry</code> 继承该接口。</li></ul><h3 id="LookupService源码"><a href="#LookupService源码" class="headerlink" title="LookupService源码"></a>LookupService源码</h3><p> 博主已添加中文注释，<a href="https://github.com/yoga0521/eureka/blob/master/eureka-client/src/main/java/com/netflix/discovery/shared/LookupService.java" target="_blank" rel="noopener">点击查看</a>。</p><h2 id="EurekaClient"><a href="#EurekaClient" class="headerlink" title="EurekaClient"></a>EurekaClient</h2><h3 id="EurekaClient简介"><a href="#EurekaClient简介" class="headerlink" title="EurekaClient简介"></a>EurekaClient简介</h3><p>所属包：<code>com.netflix.discovery.EurekaClient</code>，<strong>Eureka-Client接口</strong> 。</p><h3 id="EurekaClient源码"><a href="#EurekaClient源码" class="headerlink" title="EurekaClient源码"></a>EurekaClient源码</h3><p>博主已添加中文注释，<a href="https://github.com/yoga0521/eureka/blob/master/eureka-client/src/main/java/com/netflix/discovery/EurekaClient.java" target="_blank" rel="noopener">点击查看</a>。</p><h3 id="EurkeaClient重要属性或者重要方法"><a href="#EurkeaClient重要属性或者重要方法" class="headerlink" title="EurkeaClient重要属性或者重要方法"></a>EurkeaClient重要属性或者重要方法</h3><ul><li>获取应用集合：<ul><li><code>getApplicationsForARegion(@Nullable String region)</code>：获取指定区域中的Applications。</li><li><code>getApplications(String serviceUrl)</code>：获取指定的Eureka服务地址中注册的应用集合。</li></ul></li><li>获取应用实例集合：<ul><li><code>getInstancesByVipAddress(String vipAddress, boolean secure)</code>：获取指定VIP地址的实例列表。</li><li><code>getInstancesByVipAddress(String vipAddress, boolean secure, @Nullable String region)</code>：获取指定VIP地址和区域的实例信息列表。</li><li><code>getInstancesByVipAddressAndAppName(String vipAddress, String appName, boolean secure)</code>：获取指定VIP地址和appName的实例信息列表。</li></ul></li><li><code>getAllKnownRegions()</code>：获取所有已知的区域。</li><li><code>getInstanceRemoteStatus()</code>：获取实例状态。</li><li><code>registerHealthCheck()</code>：Eureka-Client注册健康检查。</li><li><code>getHealthCheckHandler()</code>：获取健康监测处理器。</li><li><code>registerEventListener()</code>：Eureka-Client注册事件监听。</li><li><code>unregisterEventListener()</code>：Eureka-Client取消事件监听注册。</li><li><code>getEurekaClientConfig()</code>：获取Eureka-Client配置。</li><li><code>getApplicationInfoManager()</code>：获取应用信息管理器。</li></ul><h2 id="DiscoveryClient"><a href="#DiscoveryClient" class="headerlink" title="DiscoveryClient"></a>DiscoveryClient</h2><p><img src="https://raw.githubusercontent.com/yoga0521/picture/master/SpringCloud/Eureka/DiscoveryClient%E7%B1%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="DiscoveryClient类结构图"></p><h3 id="DiscoveryClient简介"><a href="#DiscoveryClient简介" class="headerlink" title="DiscoveryClient简介"></a>DiscoveryClient简介</h3><p>所属包：<code>com.netflix.discovery.DiscoveryClient</code>，<strong>EurekaClient接口的实现类，用于与 Eureka-Server 交互</strong>。包含方法：</p><ul><li>向 Eureka-Server <strong>注册</strong>自身服务</li><li>向 Eureka-Server <strong>续约</strong>自身服务</li><li>向 Eureka-Server <strong>取消</strong>自身服务，当关闭时</li><li>从 Eureka-Server <strong>查询</strong>应用集合和应用实例信息</li><li><strong>本文主要介绍DiscoveryClient的初始化，其他方法后续文章会有介绍</strong></li></ul><h3 id="DiscoveryClient源码"><a href="#DiscoveryClient源码" class="headerlink" title="DiscoveryClient源码"></a>DiscoveryClient源码</h3><p>博主已添加中文注释，<a href="https://github.com/yoga0521/eureka/blob/master/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java" target="_blank" rel="noopener">点击查看</a>。</p><h3 id="DiscoveryClient重要属性或者重要方法"><a href="#DiscoveryClient重要属性或者重要方法" class="headerlink" title="DiscoveryClient重要属性或者重要方法"></a>DiscoveryClient重要属性或者重要方法</h3><p>构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inject</span></span><br><span class="line">DiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args,</span><br><span class="line">                    Provider&lt;BackupRegistry&gt; backupRegistryProvider) &#123;</span><br><span class="line">    <span class="comment">//省略具体代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>参数：</p><ul><li><p><code>ApplicationInfoManager</code>：<strong>应用信息管理类</strong>，具体可查看<code>ApplicationInfoManager</code>小结。</p></li><li><p><code>EurekaClientConfig</code>：<strong>Eureka-Client 配置接口</strong>，获取连接的 Eureka-Server 的地址、获取服务提供者列表的频率、注册自身为服务提供者的频率等等，具体可查看<code>EurekaClientConfig</code>小结。</p></li><li><p><code>AbstractDiscoveryClientOptionalArgs</code>：<strong>DiscoveryClient 可选参数抽象基类</strong>。该参数是选填参数，实际生产中很少使用，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDiscoveryClientOptionalArgs</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 健康检查回调的工厂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Provider&lt;HealthCheckCallback&gt; healthCheckCallbackProvider;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 健康检查处理器的工厂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Provider&lt;HealthCheckHandler&gt; healthCheckHandlerProvider;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向Eureka-Server注册之前的处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PreRegistrationHandler preRegistrationHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Jersey 过滤器集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Collection&lt;T&gt; additionalFilters;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Jersey 客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    EurekaJerseyClient eurekaJerseyClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成 Jersey 客户端工厂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TransportClientFactory transportClientFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成 Jersey 客户端工厂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TransportClientFactories transportClientFactories;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Eureka 事件监听集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;EurekaEventListener&gt; eventListeners;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ssl</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Optional&lt;SSLContext&gt; sslContext = Optional.empty();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主机认证</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Optional&lt;HostnameVerifier&gt; hostnameVerifier = Optional.empty();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>Provider&lt;BackupRegistry&gt;</code>：<strong>备份注册中心接口</strong>，当 Eureka-Client 启动时，无法从 Eureka-Server 读取注册信息，就从备份注册中心读取注册信息 ，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ImplementedBy</span>(NotImplementedRegistryImpl.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BackupRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Applications <span class="title">fetchRegistry</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Applications <span class="title">fetchRegistry</span><span class="params">(String[] includeRemoteRegions)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类源码如下（可以看出暂未提供合适的实现）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotImplementedRegistryImpl</span> <span class="keyword">implements</span> <span class="title">BackupRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取应用注册信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 应用列表对象 （默认为null）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Applications <span class="title">fetchRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取应用注册信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> includeRemoteRegions 远程区域列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 应用列表对象（默认为null）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Applications <span class="title">fetchRegistry</span><span class="params">(String[] includeRemoteRegions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>具体逻辑可查看源码，博主已添加中文注释</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们可以看到 EurekaClient 的创建，先是通过 EurekaInstanceConfig 生成 InstanceInfo，再通过 EurekaInstanceConfig 和 InstanceInfo 生成 ApplicationInfoManager，最后 EurekaClientConfig 和 ApplicationInfoManager 生成 EurekaClient。</p><p>欢迎关注博主其他的文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本篇文章主要解读Eureka-Client初始化的相关源码，文章较长，请谨慎点击！&lt;/p&gt;
    
    </summary>
    
      <category term="SpringCloud" scheme="https://yoga0521.github.io/categories/SpringCloud/"/>
    
      <category term="Eureka" scheme="https://yoga0521.github.io/categories/SpringCloud/Eureka/"/>
    
    
      <category term="Eureka" scheme="https://yoga0521.github.io/tags/Eureka/"/>
    
      <category term="SpringCloud" scheme="https://yoga0521.github.io/tags/SpringCloud/"/>
    
      <category term="微服务" scheme="https://yoga0521.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Eureka源码系列简介</title>
    <link href="https://yoga0521.github.io/2018/03/18/Eureka%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E7%AE%80%E4%BB%8B/"/>
    <id>https://yoga0521.github.io/2018/03/18/Eureka源码系列简介/</id>
    <published>2018-03-18T12:46:22.000Z</published>
    <updated>2018-05-22T13:17:16.024Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近关于微服务的话题很火热，本系列文章主要是从源码去解读Eureka。</p><a id="more"></a><p>PS：</p><ol><li>什么是微服务，本文不做具体介绍，可以自行上网查找。</li><li>如果没有使用过SpringCloud，博主建议先自行搭建一套服务之后，再进行源码的解读。</li><li>该系列文章很枯燥也很耗时，请合理安排时间。</li><li>博主是参考了芋艿大佬的路线进行源码解读的，其中有部分问题借鉴了芋艿大佬的解读。<a href="http://www.iocoder.cn/" target="_blank" rel="noopener">点击访问芋艿大佬的博客</a></li></ol><h2 id="Eureka项目结构简介"><a href="#Eureka项目结构简介" class="headerlink" title="Eureka项目结构简介"></a>Eureka项目结构简介</h2><p><img src="https://raw.githubusercontent.com/yoga0521/picture/master/SpringCloud/Eureka/Eureka%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95.png" alt="Eureka项目结构图"></p><h3 id="eureka-client"><a href="#eureka-client" class="headerlink" title="eureka-client"></a>eureka-client</h3><ol><li><code>com.netflix.appinfo</code> : Eureka-Client 的应用配置</li><li><code>com.netflix.discovery</code> : Eureka-Client 的注册和发现功能</li></ol><h3 id="eureka-client-archaius2"><a href="#eureka-client-archaius2" class="headerlink" title="eureka-client-archaius2"></a>eureka-client-archaius2</h3><p>Archaius是 Netflix 开源的配置管理组件。Eureka 使用 1.x 版本，2.x 版本仍然在开发中，2.x只兼容jdk1.8以上的版本。</p><h3 id="eureka-client-jersey2"><a href="#eureka-client-jersey2" class="headerlink" title="eureka-client-jersey2"></a>eureka-client-jersey2</h3><p>Jersey 框架实现Eureka的 RESTful HTTP接口。Eureka 使用 1.x 版本，2.x 版本由社区实现。</p><h3 id="eureka-core"><a href="#eureka-core" class="headerlink" title="eureka-core"></a>eureka-core</h3><ol><li><code>com.netflix.eureka.aws</code> : 与AWS (Amazon Web Services) 相关，该系列文章暂不涉及AWS的分析</li><li><code>com.netflix.eureka.cluster</code> : 与peer节点复制(replication)相关</li><li><code>com.netflix.eureka.lease</code> : 租约，用来控制注册信息的生命周期(注册、续约、剔除) </li><li><code>com.netflix.eureka.registry</code> : 存储、查询服务注册信息 </li><li><code>com.netflix.eureka.resources</code> : RESTful中的”R”，即资源。相当于SpringMVC中的Controller </li><li><code>com.netflix.eureka.transport</code> : 发送HTTP请求的客户端，如发送心跳 </li><li><code>com.netflix.eureka.util</code> : 相关工具包</li></ol><h3 id="eureka-core-jersey2"><a href="#eureka-core-jersey2" class="headerlink" title="eureka-core-jersey2"></a>eureka-core-jersey2</h3><p>Jersey 框架实现Eureka的 RESTful HTTP接口。Eureka 使用 1.x 版本，2.x 版本由社区实现。</p><h3 id="eureka-examples"><a href="#eureka-examples" class="headerlink" title="eureka-examples"></a>eureka-examples</h3><p>Eureka-Client 使用例子。</p><h3 id="eureka-resources"><a href="#eureka-resources" class="headerlink" title="eureka-resources"></a>eureka-resources</h3><p>通过 JSP 实现 Eureka-Server 的运维后台界面。</p><h3 id="eureka-server"><a href="#eureka-server" class="headerlink" title="eureka-server"></a>eureka-server</h3><p>由 <code>eureka-client</code> + <code>eureka-core</code> + <code>eureka-resources</code> 打包成 Eureka-Server 的war包。</p><h3 id="eureka-server-governator"><a href="#eureka-server-governator" class="headerlink" title="eureka-server-governator"></a>eureka-server-governator</h3><p>使用 Netflix Governator （Google Guice的扩展类库，提供了Classpath扫描及自动绑定、生命周期管理、成员属性验证等功能）管理 Eureka-Server 的生命周期。目前该模块正在测试阶段。</p><h3 id="eureka-test-utils"><a href="#eureka-test-utils" class="headerlink" title="eureka-test-utils"></a>eureka-test-utils</h3><p>Eureka 单元测试工具类。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近关于微服务的话题很火热，本系列文章主要是从源码去解读Eureka。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringCloud" scheme="https://yoga0521.github.io/categories/SpringCloud/"/>
    
      <category term="Eureka" scheme="https://yoga0521.github.io/categories/SpringCloud/Eureka/"/>
    
    
      <category term="Eureka" scheme="https://yoga0521.github.io/tags/Eureka/"/>
    
      <category term="SpringCloud" scheme="https://yoga0521.github.io/tags/SpringCloud/"/>
    
      <category term="微服务" scheme="https://yoga0521.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>JPA使用Java8的LocalDateTime</title>
    <link href="https://yoga0521.github.io/2017/12/02/JPA%E4%BD%BF%E7%94%A8Java8%E7%9A%84LocalDateTime/"/>
    <id>https://yoga0521.github.io/2017/12/02/JPA使用Java8的LocalDateTime/</id>
    <published>2017-12-02T14:49:03.000Z</published>
    <updated>2018-04-29T16:24:23.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章主要介绍JPA如何正确使用<code>LocalDateTime</code>与数据库<code>datetime</code>属性进行映射。</p><a id="more"></a><p>对应的JPA版本是2.1以下的，由于JPA2.1发布时间早于Java8，所以不能直接支持Java8的新特新。<strong>Oracle最新发布的JPA2.2版本是支持新的时间API以及查询结果流等。</strong></p><p><code>MyBatis</code>请查看<a href="https://yoga0521.github.io/2017/12/01/MyBatis%E4%BD%BF%E7%94%A8Java8%E7%9A%84LocalDateTime/">MyBatis使用Java8的LocalDateTime</a>。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p><code>spring-boot-starter-data-jpa</code>的版本为<code>1.5.9.RELEASE</code>，对应的<code>hibernate-core</code>版本为<code>5.0.12.Final</code></p><h3 id="将数据保存到数据库"><a href="#将数据保存到数据库" class="headerlink" title="将数据保存到数据库"></a>将数据保存到数据库</h3><ul><li><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-java8<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.12.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加注解，在获取<code>LocalDateTime</code>时，指定时间格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"id"</span>, nullable = <span class="keyword">false</span>, length = <span class="number">20</span>)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonFormat</span>(pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>, locale = <span class="string">"zh"</span>, timezone = <span class="string">"GMT+8"</span>)</span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"gmt_create"</span>)</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime gmtCreate;</span><br><span class="line">    <span class="comment">//省略get，set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>博主一开始遇到了一个坑，我用的<code>hibernate-java8</code>版本为<code>5.2.8.Final</code>，结果报错了。后来发现这个版本的<code>hibernate-core</code>是<code>5.2.8.Final</code>。后来改成对应的<code>5.0.12.Final</code>就正确了。</p><p>欢迎关注博主其他的文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这篇文章主要介绍JPA如何正确使用&lt;code&gt;LocalDateTime&lt;/code&gt;与数据库&lt;code&gt;datetime&lt;/code&gt;属性进行映射。&lt;/p&gt;
    
    </summary>
    
      <category term="JPA" scheme="https://yoga0521.github.io/categories/JPA/"/>
    
    
      <category term="Java8" scheme="https://yoga0521.github.io/tags/Java8/"/>
    
      <category term="JPA" scheme="https://yoga0521.github.io/tags/JPA/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis使用Java8的LocalDateTime</title>
    <link href="https://yoga0521.github.io/2017/12/01/MyBatis%E4%BD%BF%E7%94%A8Java8%E7%9A%84LocalDateTime/"/>
    <id>https://yoga0521.github.io/2017/12/01/MyBatis使用Java8的LocalDateTime/</id>
    <published>2017-12-01T13:42:15.000Z</published>
    <updated>2018-04-29T16:27:58.893Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>众所周知，Java8之前的时间API有很多问题，比如：<strong>非线程安全</strong>，<strong>设计很差</strong>。<strong>时区处理麻烦</strong>。新的时间API（<code>java.time</code>包）解决了这些问题，所以我们在平时开发尽可能的使用新的时间API。但是MyBatis使用<code>LocalDataTime</code>映射到数据库的<code>datetime</code>属性时，会报错。</p><a id="more"></a><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p><code>mybatis-spring-boot-starter</code>的版本为1.3.1，对应的MyBatis版本为<code>3.4.5</code>（版本低于<code>3.4.0</code>还需要特殊配置）</p><h3 id="将数据保存到数据库"><a href="#将数据保存到数据库" class="headerlink" title="将数据保存到数据库"></a>将数据保存到数据库</h3><ul><li><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- LocalDateTime映射到数据库需要的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-typehandlers-jsr310<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 格式化LocalDateTime需要的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.datatype<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-datatype-jsr310<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加注解，设置时间格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@JsonFormat</span>(pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>, locale = <span class="string">"zh"</span>, timezone = <span class="string">"GMT+8"</span>)</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime gmtCreate;</span><br><span class="line">    <span class="comment">//省略get，set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于MyBatis使用<code>LocalDateTime</code>的内容就是上面这些了，如果使用的ORM框架式JPA，请点击<a href="https://yoga0521.github.io/2017/12/02/JPA%E4%BD%BF%E7%94%A8Java8%E7%9A%84LocalDateTime/">JPA使用Java8的LocalDateTime</a>。</p><p>欢迎关注博主其他的文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;众所周知，Java8之前的时间API有很多问题，比如：&lt;strong&gt;非线程安全&lt;/strong&gt;，&lt;strong&gt;设计很差&lt;/strong&gt;。&lt;strong&gt;时区处理麻烦&lt;/strong&gt;。新的时间API（&lt;code&gt;java.time&lt;/code&gt;包）解决了这些问题，所以我们在平时开发尽可能的使用新的时间API。但是MyBatis使用&lt;code&gt;LocalDataTime&lt;/code&gt;映射到数据库的&lt;code&gt;datetime&lt;/code&gt;属性时，会报错。&lt;/p&gt;
    
    </summary>
    
      <category term="MyBatis" scheme="https://yoga0521.github.io/categories/MyBatis/"/>
    
    
      <category term="Java8" scheme="https://yoga0521.github.io/tags/Java8/"/>
    
      <category term="MyBatis" scheme="https://yoga0521.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>Java8新特性—Lambda表达式</title>
    <link href="https://yoga0521.github.io/2017/08/05/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E2%80%94Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://yoga0521.github.io/2017/08/05/Java8新特性—Lambda表达式/</id>
    <published>2017-08-05T05:41:59.000Z</published>
    <updated>2018-05-22T13:16:21.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JDK1.8是自JDK1.5以来最具革命性的版本。JDK1.8为Java语言、编译器、类库、开发工具与JVM（Java虚拟机）带来了大量新特性。所做的改变，在许多方面比Java历史上任何一次改变都深远。它们会让你编起程来更容易。本文主要介绍JDK1.8最重要的新特性之一：Lambda表达式。</p><a id="more"></a><p>ps：博主的公司也切换为JDK1.8了，CTO让我进行一次JDK1.8的分享，本文也是记录一下。</p><h2 id="什么是Lambda表达式"><a href="#什么是Lambda表达式" class="headerlink" title="什么是Lambda表达式"></a>什么是Lambda表达式</h2><p>Lambda表达式可以理解为简洁地表示可传递的匿名函数的一种方式。 </p><p>是不是很抽象的一句话？那让我们看一下它长什么样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(String s) -&gt; s. isEmpty()</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yoga0521/picture/master/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7/young.jpg" alt="nick young"></p><p>什么鬼，长得也这么抽象。</p><p>我们看一下表达式结构中最特别的是<code>-&gt;</code>，而这个箭头的左边是Lambda的参数列表，右边是Lambda的函数主体。所以Lambda表达式的结构表示为：<code>(parameters) -&gt; expression</code> 或 <code>(parameters) -&gt;{ statements; }</code>。</p><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;String&gt; sort = (String s1, String s2) -&gt; (s1.compareTo(s2));</span><br><span class="line">Runnable runnable = () -&gt; System.out.println(<span class="string">"Hello world !"</span>);</span><br></pre></td></tr></table></figure><p>这样看来是不是有所明白了？</p><h2 id="如何使用Lambda表达式"><a href="#如何使用Lambda表达式" class="headerlink" title="如何使用Lambda表达式"></a>如何使用Lambda表达式</h2><ul><li><p>我们使用以前的方法创建一个新的线程，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"匿名内部类实现Runnable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>接下来使用Lambda表达式创建一个新的线程，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"Lambda实现Runnable"</span> ));</span><br></pre></td></tr></table></figure></li></ul><p>通过上面代码的对比，我们看到Lambda表达式实现了<code>Runnable</code>接口。</p><p>那所有的接口都可以用Lambda表达式来实现吗？</p><p>答案当然是不行的，只有<strong>函数式接口</strong>才能使用Lambda表达式。什么是<strong>函数式接口</strong>？让我们继续看下一节。</p><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>所谓的<strong>函数式接口</strong>，<strong>就是接口中只定义了一个抽象方法（SAM：Single Abstract Method）</strong>。Java8接口中的<strong>默认方法</strong>和<strong>静态方法</strong>，都不算是抽象方法。接口默认继承<code>Object</code>，所以如果接口显示声明覆盖了<code>Object</code>中方法，那么也不算抽象方法。</p><p>在Java8中，使用<code>@FunctionalInterface</code>标记一个<strong>函数式接口</strong> 。该注解不是必须的，如果一个接口符合<strong>函数式接口</strong>的定义，那么加上该注解能够更好地让编译器进行检查。如果不是<strong>函数式接口</strong>，但是加上了<code>@FunctionalInterface</code>，那么编译器会报错。 </p><h3 id="Java8中新增的函数式接口"><a href="#Java8中新增的函数式接口" class="headerlink" title="Java8中新增的函数式接口"></a>Java8中新增的函数式接口</h3><ul><li><code>Predicate&lt;T&gt;</code></li><li><code>Consumer&lt;T&gt;</code></li><li><code>Supplier&lt;T&gt;</code></li><li><code>Function&lt;T,R&gt;</code></li><li><code>BinaryOperator&lt;T&gt;</code></li><li><code>UnaryOperator&lt;T&gt;</code></li><li>还有很多是通过上面六个衍化出来的，具体可以查看JDK1.8的API</li></ul><h2 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h2><p>这一节，我们说一下类型推断~</p><p>看一下下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;String&gt; c = () -&gt; <span class="string">"done"</span>;</span><br><span class="line">PrivilegedAction&lt;String&gt; p = () -&gt; <span class="string">"done"</span>;</span><br></pre></td></tr></table></figure><p>同一个Lambda表达式<code>() -&gt; &quot;done&quot;</code>，但是表示了不同的类型。</p><p>当且仅当下面所有条件均满足时，Lambda 表达式才可以被赋给目标类型 T：</p><ol><li>T 是一个函数式接口</li><li>Lambda 表达式的参数和 T 的方法参数在数量和类型上一一对应</li><li>Lambda 表达式的返回值和 T 的方法返回值相兼容（Compatible）</li><li>Lambda 表达式内所抛出的异常和 T 的方法 throws 类型相兼容</li></ol><p>而类型推断可以通过如下的规则进行推断：</p><ol><li>变量声明</li><li>赋值</li><li>返回语句</li><li>数组初始化器</li><li>方法和构造方法的参数</li><li>Lambda 表达式函数体</li><li>条件表达式（? :）</li><li>转型（Cast）表达式</li></ol><p><strong>特殊的void兼容规则</strong>：如果一个Lambda的主体是一个语句表达式，它就和一个返回void的函数描述符兼容（当然需要参数列表也兼容）。例如，以下两行都是合法的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;String&gt; p = list::add;</span><br><span class="line">Consumer&lt;String&gt; c = list::add;</span><br></pre></td></tr></table></figure><h2 id="默认方法和静态方法"><a href="#默认方法和静态方法" class="headerlink" title="默认方法和静态方法"></a>默认方法和静态方法</h2><p>上一节说到，接口的<strong>默认方法</strong>和<strong>静态方法</strong>并不是抽象方法。这好像跟我们平时认识的接口，有所不同，接口里面的方法都是没有具体实现的。怎么还会有不是抽象方法的方法？</p><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>我们先看一下默认方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在接口的方法名前面加个<code>default</code>关键字即可实现默认方法 。</p><p>ps：<code>default</code>关键字，博主之前还是在用<code>switch</code>的时候用到了。</p><p>引入默认方法最主要的作用是：为了解决接口的修改与现有的实现不兼容的问题，不需要逐个修改实现类。因为实现类默认携带接口的默认方法。</p><p>说到这里，有细心的读者就会想到：Java语言中一个类只能继承一个父类，但是一个类可以实现多个接口。随着默认方法在Java 8中引入，有可能出现一个类继承了多个方法而它们使用的却是同样的函数签名。这种情况下，类会选择使用哪一个函数？</p><p>解决该问题的规则如下：</p><ol><li>类中的方法优先级最高。 类或父类中显式声明的方法，其优先级高于所有的默认方法</li><li>如果无法依据第一条进行判断，那么子接口的优先级更高</li><li>如果2规则也失效，则需要显式指定接口，<code>X.super.m(…)</code></li></ol><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>Java 8 的另一个特性是接口可以声明（并且可以提供实现）静态方法 ，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U extends Comparable&lt;? <span class="keyword">super</span> U&gt;&gt; <span class="function">Comparator&lt;T&gt; <span class="title">comparing</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; keyExtractor)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Objects.requireNonNull(keyExtractor);</span><br><span class="line">        <span class="keyword">return</span> (Comparator&lt;T&gt; &amp; Serializable)</span><br><span class="line">            (c1, c2) -&gt; keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Java8之后的接口和抽象类对比"><a href="#Java8之后的接口和抽象类对比" class="headerlink" title="Java8之后的接口和抽象类对比"></a>Java8之后的接口和抽象类对比</h3><p>从上面可以看到Java8之后，抽象类和接口越来越接近了，是接口向抽象类靠近，剥夺抽象类的生存空间。 </p><ul><li>与抽象类相比，接口不能搞定的：<ul><li>抽象类能够定义非 static final 的属性(field) ，而接口不能。接口的属性都是static final的。</li><li>抽象类能够定义非public方法，而接口不能。接口的方法都是public的。</li></ul></li><li>与接口相比，抽象类不能搞定的：<ul><li>接口可以多继承(实现)，而抽象类不能。抽象类只能单继承。</li></ul></li></ul><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>类型推断这一节的最后，我们看到了Lambda表达式的结构变了。它的<code>-&gt;</code>不见了，取而代之的是<code>::</code>，<code>::</code>左右两边也不是参数列表和方法主体，其实这是用了<strong>方法引用</strong>。</p><ul><li><p>什么是方法引用？</p><p><strong>方法引用</strong>简单地说,就是一个Lambda表达式 。<strong>方法引用</strong>的标准形式是：<code>类名::方法名</code>。 </p></li><li><p>为什么会有方法引用？</p><p>因为，我们有时使用Lambda表达式可能仅仅调用一个已存在的方法，而不做任何其它事。对于这种情况，通过一个方法名字来引用这个已存在的方法会更加清晰。</p></li><li><p>怎么使用方法引用？</p><p>首先，我们定义一个list：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"c"</span>, <span class="string">"A"</span>, <span class="string">"C"</span>);</span><br></pre></td></tr></table></figure><p>然后使用Lambda表达式进行排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.sort((s1, s2) -&gt; s1.compareTo(s2));</span><br></pre></td></tr></table></figure><p>这里的<code>compareTo</code>方法是已存在的方法，所以我们可以用方法引用代替它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.sort(String::compareTo);</span><br></pre></td></tr></table></figure><p>是不是看上去很简洁？</p><p>下面说一下方法引用的种类：</p></li></ul><table><thead><tr><th>方法引用种类</th><th>示例</th></tr></thead><tbody><tr><td>静态方法引用：ClassName::methodName</td><td>IntBinaryOperator staticMethod = Integer::sum;</td></tr><tr><td>实例上的实例方法引用：instanceReference::methodName</td><td>Predicate<integer> predicate = new ArrayList&lt;&gt;()::contains;</integer></td></tr><tr><td>类型上的实例方法引用：ClassName::methodNam</td><td>Function&lt;String, String&gt; function = String::toString;</td></tr><tr><td>构造方法引用：Class::new</td><td>Supplier<list> supplier = ArrayList::new;</list></td></tr></tbody></table><h2 id="变量捕获"><a href="#变量捕获" class="headerlink" title="变量捕获"></a>变量捕获</h2><p>这一节，我们说一下初学者比较常见的错误。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">list.forEach(e -&gt; sum += e);</span><br></pre></td></tr></table></figure><p>可能有一部分初学者会用这样的代码进行累加，但是这段代码是报编译错误的。</p><p>这是什么原因呐？</p><p>由于Java只允许在其中捕获那些符合有效只读（Effectively final）的局部变量。</p><p>有效只读是指：如果一个局部变量在初始化后从未被修改过，那么它就符合有效只读的要求，换句话说，加上 final后也不会导致编译错误的局部变量就是有效只读变量。 </p><h2 id="序列化Lambda表达式"><a href="#序列化Lambda表达式" class="headerlink" title="序列化Lambda表达式"></a>序列化Lambda表达式</h2><p>我们看一下序列化的接口，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>序列化接口被称为ZAM（Zero Abstract Method），即该接口中没有声明任何方法 。Serializable接口一般认为是标记性的接口。</p><p>为了能序列化，java8引入了所谓的类型关联（TypeIntersection）。</p><p>序列化Lambda表达式的具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Runnable r1 = () -&gt; System.out.println(<span class="keyword">this</span>);</span><br><span class="line">Runnable r2 = (Runnable &amp; Serializable) () -&gt; System.out.println(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><h2 id="Lambda实现原理"><a href="#Lambda实现原理" class="headerlink" title="Lambda实现原理"></a>Lambda实现原理</h2><p>最后，我们来看一下Lambda表达式的实现原理。</p><p>由于Lambda表达式提供了函数式接口中抽象方法的实现，这让人有一种感觉，似乎在编译过程中让Java编译器直接将Lambda表达式转换为匿名类更直观。那jvm是不是直接把Lambda编译成匿名内部类？ </p><p>并不是，匿名类有着种种不尽如人意的特性，会对应用程序的性能带来负面影响：</p><ul><li>编译器会为每个匿名类生成一个新的.class文件。这些新生成的类文件的文件名通常以 ClassName$1这种形式呈现，其中ClassName是匿名类出现的类的名字，紧跟着一个美元符号和一个数字。生成大量的类文件是不利的，因为每个类文件在使用之前都需要加载和验证，这会直接影响应用的启动性能。如果将Lambda表达式转换为匿名类，每个 Lambda表达式都会产生一个新的类文件，这是我们不期望发生的。</li><li>每个新的匿名类都会为类或者接口产生一个新的子类型。如果你为了实现一个比较器，使用了一百多个不同的Lambda表达式，这意味着该比较器会有一百多个不同的子类型。 这种情况下，JVM的运行时性能调优会变得更加困难。 </li></ul><p>我们看一下下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Object, String&gt; f = <span class="keyword">new</span> Function&lt;Object, String&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> o.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这段代码的对应的字节码：</p><p><img src="https://raw.githubusercontent.com/yoga0521/picture/master/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81.png" alt="匿名内部类的字节码"></p><ul><li>可以看到，通过字节码操作new，一个TestFunction$1类型的对象被实例化了。与此同时，一个指向新创建对象的引用会被压入栈。 </li><li>dup操作会复制栈上的引用。</li><li>接着这个值会被invokespecial指令处理，该指令会初始化对象。</li><li>栈顶现在包含了指向对象的引用，该值通过putfield指令保存到了LambdaBytecode类 的f1字段。 </li></ul><p>我们将这段代码使用Lambda表达式实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Object, String&gt; f = Object::toString;</span><br></pre></td></tr></table></figure><p>对应的字节码：</p><p><img src="https://raw.githubusercontent.com/yoga0521/picture/master/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81.png" alt="Lambda字节码"></p><p>通过两段字节码的对比，我们可以看到，Lambda表达式是通过<code>invokedynamic</code>字节码指令创建额外的类。</p><p><code>invokedynamic</code>最初被JDK7引入，用于支持运行于JVM上的动态类型语言。执行方法调用时，invokedynamic添加了更高层的抽象，使得一部分逻辑可以依据动态语言的特征来决定调用目标。</p><p>使用<code>invokedynamic</code>，可以将实现Lambda表达式的这部分代码的字节码生成 推迟到运行时。这种设计选择带来了一系列好结果 ：</p><ul><li>Lambda表达式的代码块到字节码的转换由高层的策略变成了纯粹的实现细节。它现在可以动态地改变，或者在未来版本中得到优化和修改，并且保持了字节码的后向兼容性。 </li><li>没有带来额外的开销，没有额外的字段，也不需要进行静态初始化，而这些如果不使用Lambda，就不会实现。</li><li>对无状态非捕获型Lambda，我们可以创建一个Lambda对象的实例，对其进行缓存，之后对同一对象的访问都返回同样的内容。</li><li>没有额外的性能开销，因为这些转换都是必须的，并且结果也进行了链接，仅在Lambda 首次被调用时需要转换。其后所有的调用都能直接跳过这一步，直接调用之前链接的实现。 </li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Lambda表达式，语法简单，有更灵活的语义。它是Java8最重要的新特新之一，大家可以多尝试一下，毕竟Java8已经发布四年多了。不要落后咯~</p><p>欢迎关注博主其他的文章。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《Java8 实战》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;JDK1.8是自JDK1.5以来最具革命性的版本。JDK1.8为Java语言、编译器、类库、开发工具与JVM（Java虚拟机）带来了大量新特性。所做的改变，在许多方面比Java历史上任何一次改变都深远。它们会让你编起程来更容易。本文主要介绍JDK1.8最重要的新特性之一：Lambda表达式。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://yoga0521.github.io/categories/Java/"/>
    
      <category term="Java8新特性" scheme="https://yoga0521.github.io/categories/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
    
      <category term="Java" scheme="https://yoga0521.github.io/tags/Java/"/>
    
      <category term="Java8" scheme="https://yoga0521.github.io/tags/Java8/"/>
    
  </entry>
  
  <entry>
    <title>LinkedHashMap源码解析</title>
    <link href="https://yoga0521.github.io/2017/01/24/LinkedHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://yoga0521.github.io/2017/01/24/LinkedHashMap源码解析/</id>
    <published>2017-01-24T11:25:37.000Z</published>
    <updated>2018-05-24T12:33:14.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>HashMap是我们最常使用的数据类型之一，也是面试中最容易问到的集合之一。本篇文章主要通过分析HashMap的源码，更深入的了解HashMap，以及对比HashMap在JDK1.8和JDK1.7的不同。</p><h2 id="LinkedHashMap简介"><a href="#LinkedHashMap简介" class="headerlink" title="LinkedHashMap简介"></a>LinkedHashMap简介</h2><h2 id="LinkedHashMap类结构"><a href="#LinkedHashMap类结构" class="headerlink" title="LinkedHashMap类结构"></a>LinkedHashMap类结构</h2><p><img src="https://raw.githubusercontent.com/yoga0521/picture/master/Java/Map/LinkedHashMap%E7%B1%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="LinkedHashMap类结构图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;HashMap是我们最常使用的数据类型之一，也是面试中最容易问到的集合之一。本篇文章主要通过分析HashMap的源码，更深入的了解HashM
      
    
    </summary>
    
      <category term="Java" scheme="https://yoga0521.github.io/categories/Java/"/>
    
      <category term="Map" scheme="https://yoga0521.github.io/categories/Java/Map/"/>
    
    
      <category term="Java" scheme="https://yoga0521.github.io/tags/Java/"/>
    
      <category term="Java8" scheme="https://yoga0521.github.io/tags/Java8/"/>
    
  </entry>
  
  <entry>
    <title>HashMap源码解析</title>
    <link href="https://yoga0521.github.io/2017/01/22/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://yoga0521.github.io/2017/01/22/HashMap源码解析/</id>
    <published>2017-01-22T07:27:57.000Z</published>
    <updated>2018-05-24T09:55:50.231Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>HashMap是我们最常使用的数据类型之一，也是面试中最容易问到的集合之一。本篇文章主要通过分析HashMap的源码，更深入的了解HashMap，以及对比HashMap在JDK1.8和JDK1.7的不同。</p><a id="more"></a><blockquote><p>本文基于jdk1.8</p></blockquote><h2 id="HashMap简介"><a href="#HashMap简介" class="headerlink" title="HashMap简介"></a>HashMap简介</h2><p>HashMap是一个散列表，属于<code>java.util</code>包，它存储的内容是键值对(key-value)映射 ，根据键的hashCode值存储数据。</p><h2 id="HashMap类结构"><a href="#HashMap类结构" class="headerlink" title="HashMap类结构"></a>HashMap类结构</h2><p><img src="https://raw.githubusercontent.com/yoga0521/picture/master/Java/Map/HashMap%E7%B1%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="HashMap类结构图"></p><p>可以从上图看出，HashMap继承AbstractMap抽象类，实现了Cloneable，Serializable和Map接口。</p><p>ps：为什么HashMap继承了AbstractMap抽象类，还要实现Map接口？</p><p>​    Java集合框架的编写者Josh Bloch说这是一个<strong>错误</strong>。。在java集合框架中，类似这样的写法很多。 JDK的维护者，后来不认为这个小小的失误值得去修改。所以就这样存在下来了。 </p><h2 id="HashMap特点"><a href="#HashMap特点" class="headerlink" title="HashMap特点"></a>HashMap特点</h2><ol><li>HashMap非线程安全，创建线程安全的HashMap的方法：<code>Map map = Collections.synchronizedMap(new HashMap());</code>，或者使用<code>ConcurrentHashMap</code>。</li><li>HashMap的key和value都允许为null。</li><li>HashMap的数据存储是无序的。</li><li>如果需要put的key为自定义的对象，需要重写该对象的equals方法和hashCode方法。<strong>注意</strong>如果对象是可变的，那你就有可能get不到你保存在HashMap中的数据了，所以重写hashCode的时候需要小心哦~</li></ol><h2 id="HashMap源码"><a href="#HashMap源码" class="headerlink" title="HashMap源码"></a>HashMap源码</h2><h3 id="HashMap常量属性"><a href="#HashMap常量属性" class="headerlink" title="HashMap常量属性"></a>HashMap常量属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始容量为16，必须为2的幂次（这个后续会讲解）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最大容量，2的30次，如果初始化的大小大于这个值，就会被这个最大容量代替</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认加载因子</span></span><br><span class="line"><span class="comment"> * 如果加载因子太大，空间利用率高，hash碰撞概率也越高；反之则hash碰撞概率低，空间利用率也越低</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果哈希桶（Node）中的节点数达到8，链表就会被转换为红黑树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 与上面的属性相反，是将红黑树转换为链表的阈值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希桶（Node）转换为树（TreeNode）的最小容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure><h3 id="HashMap成员变量"><a href="#HashMap成员变量" class="headerlink" title="HashMap成员变量"></a>HashMap成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希桶，在第一次使用时初始化，并调整为必要的大小。长度总是2的幂。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希桶，在第一次使用时初始化，并调整为必要的大小。长度总是2的幂。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashMap中k-v数据的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashMap结构被修改的次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashMap下一次扩容的大小 (capacity * load factor)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><h3 id="HashMap内部类"><a href="#HashMap内部类" class="headerlink" title="HashMap内部类"></a>HashMap内部类</h3><h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定位数据在数组中的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashMap中保存的数据的key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashMap中保存的数据的value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    V value;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表的下一个node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，设置hash，key，value，next</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TreeNode"><a href="#TreeNode" class="headerlink" title="TreeNode"></a>TreeNode</h4><p>TODO</p><h3 id="HashMap构造函数"><a href="#HashMap构造函数" class="headerlink" title="HashMap构造函数"></a>HashMap构造函数</h3><p>HashMap一共有四个构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定初始容量和加载因子的构造函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断初始容量是否小于0，是的话抛出参数非法的异常</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断初始容量是否超过最大值，超过的话用最大值代替初始容量</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">// 判断加载因子是否小于0或者是否是数字，小于0或者非数字就抛出参数非法的异常</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="comment">// 设置加载因子</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">// 将初始容量设置为最接近的2的幂次大小</span></span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定初始容量的构造函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用默认值的构造函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过一个Map创建HashMap的构造函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HashMap静态工具方法"><a href="#HashMap静态工具方法" class="headerlink" title="HashMap静态工具方法"></a>HashMap静态工具方法</h3><h4 id="hash-Object-key"><a href="#hash-Object-key" class="headerlink" title="hash(Object key)"></a>hash(Object key)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// key为null的话返回0</span></span><br><span class="line">    <span class="comment">// h = key.hashCode()：获取key的hashCode值</span></span><br><span class="line">    <span class="comment">// h ^ (h &gt;&gt;&gt; 16)：利用hashCode的高16位与低16位进行异或，防止两个hashCode的高位不同，低位相同，导致hash碰撞</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tab[i = (n - 1) &amp; hash])</code></p><p>这是定位数组下标位置的一小段代码，其中n是数组的长度，hash是调用<code>hash(Object key)</code>方法返回的值。我们可以看到，这里使用数组长度减1然后与hash相与，获取数组下标。为什么要这么操作？</p><p>当n始终是2的幂次时，<code>(n - 1) &amp; hash</code>相当于<code>hash % n</code>，即对hash取模。这也是hash算法中的<strong>除留余数法</strong>。</p><p>我们试一下数组长度为15和16，hashCode为4和5的情况下，计算数组下标的结果：</p><p><img src="https://raw.githubusercontent.com/yoga0521/picture/master/Java/Map/%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A615%E5%92%8C16%E6%97%B6%E7%9A%84hash%E5%AF%B9%E6%AF%94.png" alt="hash对比"></p><p>很明显，假设数组长度为15，hashCode为4和5的时候，会发生hash碰撞，会降低查询效率和空间利用率。</p><p><strong>ps：这也是为什么HashMap容量必须是2的幂次的原因。</strong></p><p>仔细想一下，如果hashCode二进制为0001 0001 0001 0001 0000 0000 0010 1011和0000 0000 0000 0000 0000 0000 0010 1011的情况时，进行<code>(n - 1) &amp; hash</code>，这样出来的下标是相同的。为了解决这个问题，HashMap使用<code>hash(Object key)</code>方法，进行高位异或运算，使得只有相同hash值的两个值才会被放到数组中的同一个位置上形成链表。 </p><p>我们可以看一下下面的图：</p><p><img src="https://raw.githubusercontent.com/yoga0521/picture/master/Java/Map/%E9%AB%98%E4%BD%8D%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97hash%E5%AF%B9%E6%AF%94.png" alt="高位异或运算hash对比"></p><p>综上所述：HashMap的hash过程是：<strong>获取key的hashCode -&gt; 高位异或运算 -&gt; 取模运算</strong>。</p><p><img src="https://raw.githubusercontent.com/yoga0521/picture/master/Java/Map/hash%E6%B5%81%E7%A8%8B.png" alt="hash流程"></p><h4 id="tableSizeFor-int-cap"><a href="#tableSizeFor-int-cap" class="headerlink" title="tableSizeFor(int cap)"></a>tableSizeFor(int cap)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 防止cap已经是2的幂次，如果cap是2的幂次，不进行减1的话，最后的值会变成两倍的cap</span></span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 使最高的1右边也确定为1，即有连续的两个1</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 使最高的两个1右边也确定为两个1，即有连续的四个1</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 使最高的四个1右边也确定为四个1，即有连续的八个1</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 使最高的八个1右边也确定为八个1，即有连续的十六个1</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 使最高的十六个1右边也确定为十六个1，即有连续的三十二个1</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 加1，确保为2的幂次</span></span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码里的描述可能有点抽象，不容易理解，让我们举个例子看一下：</p><p>假设我们传入的cap为33，然后<code>tableSizeFor</code>方法的流程如下：</p><p><img src="https://raw.githubusercontent.com/yoga0521/picture/master/Java/Map/tableSizeFor%E7%A4%BA%E4%BE%8B.png" alt="tableSizeFor示例"></p><h3 id="HashMap提供的API方法："><a href="#HashMap提供的API方法：" class="headerlink" title="HashMap提供的API方法："></a>HashMap提供的API方法：</h3><table><thead><tr><th>方法名</th><th>方法解释</th></tr></thead><tbody><tr><td>clear()</td><td>从HashMap中移除所有映射。</td></tr><tr><td>clone()</td><td>返回HashMap实例的浅表副本：key和value本身未被克隆。</td></tr><tr><td>compute( K key, BiFunction &lt;? super K,? super V,? extends V&gt; remappingFunction )</td><td>根据key获取映射，如果存在将BiFunction的返回值设置为新的value，并返回新的value。如果获取不到映射，就设置新的映射。如果BiFunction的返回值为null，就删除该节点。</td></tr><tr><td>computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction)</td><td></td></tr><tr><td>computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)</td><td>根据key获取映射，如果存在将BiFunction的返回值设置为新的value，并返回新的value。如果获取不到映射，就返回null。如果BiFunction的返回值为null，就删除该节点。</td></tr><tr><td>containsKey(Object key)</td><td>如果HashMap中包含指定key的映射，则返回true。</td></tr><tr><td>containsValue(Object value)</td><td>如果HashMap中包含指定value的一个或者多个映射，则返回true。</td></tr><tr><td>entrySet()</td><td>返回此HashMap中包含的映射的Set。</td></tr><tr><td>forEach(BiConsumer&lt;? super K, ? super V&gt; action)</td><td>对HashMap中的每个数据执行给定操作，直到处理完所有数据或操作抛出异常为止。</td></tr><tr><td>get(Object key)</td><td>返回指定key映射到的值;如果HashMap中不包含key的映射，则返回null。</td></tr><tr><td>getOrDefault(Object key, V defaultValue)</td><td>返回指定key映射到的值;如果HashMap中不包含key的映射，则返回defaultValue。</td></tr><tr><td>isEmpty()</td><td>判断HashMap是否为空。</td></tr><tr><td>keySet()</td><td>返回HashMap中包含的key的Set。</td></tr><tr><td>merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction)</td><td>功能大部分与compute相同，不同之处在于BiFunction中apply的参数，入参为oldValue、value，调用merge时根据两个value进行处理并返回value。</td></tr><tr><td>put(K key, V value)</td><td>将key和value添加到HashMap。</td></tr><tr><td>putAll(Map&lt;? extends K, ? extends V&gt; m)</td><td>将指定Map中的所有映射复制到此HashMap。</td></tr><tr><td>putIfAbsent(K key, V value)</td><td>如果HashMap中key不存在，就保存key-value映射，并返回null；反之就返回已存在的value，并不覆盖为value。</td></tr><tr><td>remove(Object key)</td><td>从HashMap中删除指定key的映射，并返回value。</td></tr><tr><td>remove(Object key, Object value)</td><td>只有在指定key映射到指定value时，才删除该数据。</td></tr><tr><td>replace(K key, V value)</td><td>替换key映射的value。</td></tr><tr><td>replace(K key, V oldValue, V newValue)</td><td>只有在指定key映射到指定oldValue时，才替换成newValue。</td></tr><tr><td>replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function)</td><td>对HashMap调用给定函数的结果替换每个数据的value，直到处理完所有数据或者该函数抛出异常。</td></tr><tr><td>size()</td><td>获取HashMap中的映射数量。</td></tr><tr><td>values()</td><td>返回HashMap中包含的value的集合。</td></tr></tbody></table><h3 id="HashMap重要方法"><a href="#HashMap重要方法" class="headerlink" title="HashMap重要方法"></a>HashMap重要方法</h3><h4 id="put-K-key-V-value"><a href="#put-K-key-V-value" class="headerlink" title="put(K key, V value)"></a>put(K key, V value)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict)</p><p><code>onlyIfAbsent</code>：如果为true，就不改变已存在的key对应的value，只有key不存在才会put。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 如果数组为空，进行扩容（设置数组tab和数组长度n）</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 定位数组下标，判断该位置是否null，如果为null，直接插入新节点（设置节点p和数组下标i）</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 如果定位到的节点hash和key与put的相同，后面会进行value覆盖（记录键k和节点e）</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果是红黑树节点，调用红黑树的putvalue方法</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 如果是链表节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历链表节点进行插入</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 如果定位到的节点的下一个节点为null，将该节点插入到定位到的节点之后</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 判断是否达到转换为红黑树的长度，如果达到了就进行转换</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果定位到的节点hash和key与put的相同，后面会进行value覆盖（记录键k和节点e）</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果相同key的节点存在，就覆盖value，并返回旧值，操作次数不需要加1</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent为false或者旧值为null，进行覆盖</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// HashMap定义了该方法，LinkedHashMap有实现</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 操作次数加1</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// k-v映射数量加1，如果超过扩容阈值，就进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// HashMap定义了该方法，LinkedHashMap有实现</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>resize()</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// 获取旧数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 获取旧数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">// 获取旧的扩容阈值</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果旧数组不为null</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果旧数组的长度达到了最大值，就设置扩容阈值为Integer最大值，返回旧数组，不进行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果旧数组的长度没有达到最大值，并且将新的数组长度设置为旧数组的2倍没有超过最大值，以及旧数组长度大于默认值16</span></span><br><span class="line">        <span class="comment">// 将新的扩容阈值设置为旧的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果旧数组为null，但是扩容阈值大于0（即new HashMap(int initialCapacity)后第一次put），将旧的扩容阈值设置为新数组的长度</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">// 如果旧数组为null，且扩容阈值不大于0</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">// 设置默认长度和计算扩容阈值</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 只有前面else if的条件满足下面的判断，设置新的扩容阈值</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置扩容阈值</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">// 用新的数组长度初始化新的数组</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    <span class="comment">// 设置数组</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">// 如果旧数组不为null，将旧数组复制到新数组</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 循环遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">// 如果数组中的节点不为null，进行复制操作</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 如果只是单一节点，计算在新数组中的下标，并进行赋值</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 如果节点是红黑树，进行红黑树的操作，可能会触发红黑树转为链表的操作</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">// 链表操作</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 将链表分为两组，</span></span><br><span class="line">                    <span class="comment">// 扩容之后在原位置的节点列表</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 扩容之后在原位置加上原数组长度位置的列表节点</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 判断扩容之后hash新增的1bit是否是0</span></span><br><span class="line">                        <span class="comment">// 是的话添加到原位置节点列表</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 判断扩容之后hash新增的1bit是否是1</span></span><br><span class="line">                        <span class="comment">// 是的话添加到原位置加上原数组长度位置节点列表</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 将列表复制到新数组</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回新数组</span></span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>这样做的好处：</strong> TODO</p><ul><li><p>treeifyBin(Node&lt;K,V&gt;[] tab, int hash)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 判断数组是否为空，或者数组长度是否小于哈希桶（Node）转换为树（TreeNode）的最小容量，满足的话进行扩容，即还没达到转换为红黑树的大小</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 达到了转为红黑树的大小，计算需要转换为红黑树的链表的数组下标</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//新建一个树形节点，内容和当前链表节点e一致</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//确定树头节点</span></span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//让数组的第一个元素指向新建的红黑树头结点，之后这个桶里的元素就是红黑树了</span></span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 塑造红黑树，前面的只是创建了一个二叉树，并没有设置颜色值</span></span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>红黑树相关操作</p><p>TODO</p></li></ul><p><strong><code>put(K key, V value)</code>流程：</strong></p><ol><li>如果数组为空，进行第一次扩容。</li><li>计算key的hash</li><li>定位数组的下标：<code>hash &amp; (length – 1)</code>。</li><li>如果该位置为null，插入新节点，操作计数，size+1，判断是否需要扩容，并返回null。</li><li>如果4不满足，判断该位置第一个节点的key是否与put的相符。</li><li>如果相符，就记录该节点。</li><li>如果不相符，判断该节点是否为红黑树。</li><li>如果该节点是红黑树，通过红黑树的方法进行put，记录返回节点。</li><li>如果该节点不是红黑树，就遍历列表，如果有key相符的节点，就记录该节点，如果没有就新增节点，并判断是否要转为红黑树。</li><li>判断记录节点是否为null</li><li>如果不为null，进行旧值覆盖，并返回旧值。</li><li>如果为null，操作计数，size+1，判断是否需要扩容，并返回null。</li></ol><h4 id="putIfAbsent-K-key-V-value"><a href="#putIfAbsent-K-key-V-value" class="headerlink" title="putIfAbsent(K key, V value)"></a>putIfAbsent(K key, V value)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>onlyIfAbsent</code>：为true，就不改变已存在的key对应的value，只有key不存在才会put。</p><h4 id="putAll-Map-lt-extends-K-extends-V-gt-m"><a href="#putAll-Map-lt-extends-K-extends-V-gt-m" class="headerlink" title="putAll(Map&lt;? extends K, ? extends V&gt; m)"></a>putAll(Map&lt;? extends K, ? extends V&gt; m)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    putMapEntries(m, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果HashMap数组为null，进行初始化扩容阈值</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果传入的Map的size大于扩容阈值，就进行扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 遍历传入的Map，调用putVal进行添加k-v映射</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HashMap(Map&lt;? extends K, ? extends V&gt; m)</code>也调用了<code>putMapEntries</code>方法。</p></li></ul><h4 id="get-Object-key"><a href="#get-Object-key" class="headerlink" title="get(Object key)"></a>get(Object key)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>getNode(int hash, Object key)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 数组不为空，定位到的数组下标对应的节点不为空（设置数组tab，设置数组长度n，设置定位到的第一个节点first）</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断第一个节点与需要获取的key是否相同（包括hash值），是的话就返回第一个节点（设置k）</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 没满足上面的判断，并且第一个节点的下一个节点不为null</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果是红黑树，通过红黑树的获取节点方式返回节点</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 遍历链表，获取对应的节点并返回</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找不到返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>红黑树相关操作</p><p>TODO</p></li></ul><p><strong><code>get(Object key)</code>流程：</strong></p><ol><li>计算key的hash值。</li><li>定位数组的下标：<code>hash &amp; (length – 1)</code>。</li><li>返回key对应的值。其中查找节点流程：<ol><li>如果定位到的数组下标的第一个节点与key相符，就返回该节点。</li><li>如果1没满足，判断是否是红黑树，如果是，则根据红黑树查找节点的方法返回节点。</li><li>如果2没满足，遍历链表，返回与key相符的节点。</li><li>如果3没满足，返回null。</li></ol></li></ol><h4 id="getOrDefault-Object-key-V-defaultValue"><a href="#getOrDefault-Object-key-V-defaultValue" class="headerlink" title="getOrDefault(Object key, V defaultValue)"></a>getOrDefault(Object key, V defaultValue)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 如果key不存在就返回默认值</span></span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? defaultValue : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="remove-Object-key"><a href="#remove-Object-key" class="headerlink" title="remove(Object key)"></a>remove(Object key)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">// 数组不为空，定位到的数组下标对应的节点不为空（设置数组tab，设置数组长度n，设置定位到的节点p）</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">// 如果p节点与需要remove的节点key相符，就记录为node</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="comment">// p节点与需要remove的节点key不相符，并且p的下一个节点不为null</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果是红黑树，根据红黑树的获取节点方法，获取节点记录为node</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 遍历链表，查找key相符的节点，并记录为node</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果记录的node不为null，并且matchValue为false或记录的node的value与传入的value相符，就进行remove</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="comment">// 如果记录的node为红黑树，就调用红黑树的remove方法，移除节点，可能会触发红黑树转为链表的操作</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="comment">// 如果记录的node是链表的第一个节点，将链表的第一个节点指向该节点的下一个节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            <span class="comment">// 操作次数加1</span></span><br><span class="line">            ++modCount;</span><br><span class="line">            <span class="comment">// HashMap中的映射数减1</span></span><br><span class="line">            --size;</span><br><span class="line">            <span class="comment">// HashMap定义了该方法，LinkedHashMap有实现</span></span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="comment">// 返回移除的节点</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数组为空，返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>红黑树相关操作</p><p>TODO</p></li></ul><h4 id="remove-Object-key-Object-value"><a href="#remove-Object-key-Object-value" class="headerlink" title="remove(Object key, Object value)"></a>remove(Object key, Object value)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="replace-K-key-V-value"><a href="#replace-K-key-V-value" class="headerlink" title="replace(K key, V value)"></a>replace(K key, V value)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">replace</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 获取key对应的节点，如果不为null就进行替换</span></span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 记录旧值</span></span><br><span class="line">        V oldValue = e.value;</span><br><span class="line">        <span class="comment">// 替换旧值</span></span><br><span class="line">        e.value = value;</span><br><span class="line">        <span class="comment">// HashMap定义了该方法，LinkedHashMap有实现</span></span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="comment">// 返回旧值</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不存在就返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="replace-K-key-V-oldValue-V-newValue"><a href="#replace-K-key-V-oldValue-V-newValue" class="headerlink" title="replace(K key, V oldValue, V newValue)"></a>replace(K key, V oldValue, V newValue)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e; V v;</span><br><span class="line">    <span class="comment">// 获取key对应的节点，判断value是否相符，如果满足就进行替换</span></span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        ((v = e.value) == oldValue || (v != <span class="keyword">null</span> &amp;&amp; v.equals(oldValue)))) &#123;</span><br><span class="line">        <span class="comment">// 替换旧值</span></span><br><span class="line">        e.value = newValue;</span><br><span class="line">        <span class="comment">// HashMap定义了该方法，LinkedHashMap有实现</span></span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="compute相关方法和merge"><a href="#compute相关方法和merge" class="headerlink" title="compute相关方法和merge"></a>compute相关方法和merge</h4><p>TODO</p><h2 id="HashMap引发死循环的情况"><a href="#HashMap引发死循环的情况" class="headerlink" title="HashMap引发死循环的情况"></a>HashMap引发死循环的情况</h2><h2 id="HashMap在JDK1-8和JDK1-7中的对比"><a href="#HashMap在JDK1-8和JDK1-7中的对比" class="headerlink" title="HashMap在JDK1.8和JDK1.7中的对比"></a>HashMap在JDK1.8和JDK1.7中的对比</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这篇文章，我们可以知道一下几个点：</p><ol><li>HashMap是线程不安全的，所以如果我们在多线程下，需要使用<code>Collections.synchronizedMap</code>或者<code>ConCurrentHashMap</code>。</li><li>HashMap在JDK1.8中进行了很多优化，具体可以看HashMap在JDK1.8和JDK1.7中的对比这一节。</li><li>HashMap中链表转为红黑树，需要满足两个条件，一是链表长度&gt;=8，二是数组长度&gt;=64。</li></ol><p>ps：有一些TODO的内容，后续有空了再进行添加。</p><p>欢迎关注博主其他的文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;HashMap是我们最常使用的数据类型之一，也是面试中最容易问到的集合之一。本篇文章主要通过分析HashMap的源码，更深入的了解HashMap，以及对比HashMap在JDK1.8和JDK1.7的不同。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://yoga0521.github.io/categories/Java/"/>
    
      <category term="Map" scheme="https://yoga0521.github.io/categories/Java/Map/"/>
    
    
      <category term="Java" scheme="https://yoga0521.github.io/tags/Java/"/>
    
      <category term="Java8" scheme="https://yoga0521.github.io/tags/Java8/"/>
    
  </entry>
  
  <entry>
    <title>Java内部类详解</title>
    <link href="https://yoga0521.github.io/2017/01/21/Java%E5%86%85%E9%83%A8%E7%B1%BB%E8%AF%A6%E8%A7%A3/"/>
    <id>https://yoga0521.github.io/2017/01/21/Java内部类详解/</id>
    <published>2017-01-21T13:03:14.000Z</published>
    <updated>2018-05-22T12:59:46.667Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java有四种内部类：成员内部类，局部内部类，静态内部类和匿名内部类。这篇文章主要分别说一下这四种内部类的特点。</p><a id="more"></a><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p><strong>《Think in java》 中提到过，使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。 </strong></p><p>ps：利用匿名内部类，可以实现Java多继承；另一种是接口的多实现。</p><p>内部类是一个编译时的概念，一旦编译成功，就会成为完全不同的两类。对于一个名为<code>OuterClass</code>的外部类和其内部定义的<code>InnerClass</code>内部类。编译完成后出现<code>OuterClass.class</code>和<code>OuterClass$InnerClass.class</code>两个类文件。 </p><h2 id="关于内部类的new和this"><a href="#关于内部类的new和this" class="headerlink" title="关于内部类的new和this"></a>关于内部类的new和this</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">InnerClass</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// OuterClass.this 获取外部类的引用</span></span><br><span class="line">            OuterClass.<span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"name："</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OuterClass outerClass = <span class="keyword">new</span> OuterClass();</span><br><span class="line">        <span class="comment">// outerClass.new 创建内部类对象</span></span><br><span class="line">        OuterClass.InnerClass innerClass = outerClass.new InnerClass(<span class="string">"yoga"</span>);</span><br><span class="line">        innerClass.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码的注释已经很清楚了，我们可以通过<code>OuterClass.this</code>获取外部类的引用，外部类对象通过<code>.new</code>来创建内部类。</p><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>成员内部类是外部类的一个成员，与外部类的属性和方法的等级是一样的。它可以任意的访问外部类的属性和方法（包括<code>private</code>修饰的）；而外部类需要通过内部类实例来访问内部类的属性和方法。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>成员内部类不能包含任何static修饰的变量和方法。</li><li>成员内部类依附于外部类，所以需要先创建外部类再创建内部类。</li></ol><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberOuterClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberInnerClass</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">MemberInnerClass</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            MemberOuterClass.<span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"name："</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MemberOuterClass memberOuterClass = <span class="keyword">new</span> MemberOuterClass();</span><br><span class="line">        MemberOuterClass.MemberInnerClass memberInnerClass = memberOuterClass.new MemberInnerClass(<span class="string">"yoga"</span>);</span><br><span class="line">        memberInnerClass.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>局部内部类定义在方法中的内部类，与局部变量有点类似。局部内部类前面不加<code>private</code>，<code>public</code>修饰符。</p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ol><li>作用域为定义该局部内部类的代码块。</li><li>局部内部类不可以定义静态变量。</li><li>如果在静态方法中：可以访问外部类中所有静态成员，包含私有；如果在实例方法中：可以访问外部类中所有的成员，包含私有。 </li><li>局部内部类可以访问所在方法中定义的局部变量，但是要求局部变量必须使用final修饰 。</li></ol><h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalOuterClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"yoga"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String sex = <span class="string">"male"</span>;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">LocalInner</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"name : "</span> + name);</span><br><span class="line">                System.out.println(<span class="string">"age : "</span> + age);</span><br><span class="line">                System.out.println(<span class="string">"sex : "</span> + sex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> LocalInner().print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String address = <span class="string">"HangZhou"</span>;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">LocalInner</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// System.out.println("name : " + name); 无法访问private属性</span></span><br><span class="line">                System.out.println(<span class="string">"age : "</span> + age);</span><br><span class="line">                System.out.println(<span class="string">"address : "</span> + address);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> LocalInner().print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalOuterClass.test2();</span><br><span class="line">        <span class="keyword">new</span> LocalOuterClass().test1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>匿名内部类是没有名字的局部内部类。没有修饰符。</p><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ol><li>没有构造器。</li></ol><h3 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"匿名内部类"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>静态内部类是声明在外部类内，方法体外，并且使用static修饰的内部类 。</p><h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><ol><li>它的创建是不需要依赖于外围类的：<ul><li>在外部类的外部构建内部类的实例：new Outer.Inner()；</li><li>在外部类的内部构建内部类的实例：new Inner(); </li></ul></li><li>它不能使用任何外围类的非static成员变量和方法。</li></ol><h3 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticOuterClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name = <span class="string">"yoga"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态内部类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 定义在静态内部类中的静态属性</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> String sex = <span class="string">"male"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"name："</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StaticOuterClass staticOuterClass = <span class="keyword">new</span> StaticOuterClass();</span><br><span class="line">        StaticInnerClass.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>欢迎关注博主其他的文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Java有四种内部类：成员内部类，局部内部类，静态内部类和匿名内部类。这篇文章主要分别说一下这四种内部类的特点。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://yoga0521.github.io/categories/Java/"/>
    
      <category term="内部类" scheme="https://yoga0521.github.io/categories/Java/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
    
      <category term="Java" scheme="https://yoga0521.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList源码解析</title>
    <link href="https://yoga0521.github.io/2017/01/19/ArrayList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://yoga0521.github.io/2017/01/19/ArrayList源码解析/</id>
    <published>2017-01-19T12:08:28.000Z</published>
    <updated>2018-05-29T13:38:23.365Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ArrayList是我们最常使用的数据类型之一，也是面试中最容易问到的集合之一。本篇文章主要通过分析ArrayList的源码，更深入的了解ArrayList，ArrayList在JDK1.8中添加了一些新的方法。</p><a id="more"></a><blockquote><p>本文基于jdk1.8</p></blockquote><h2 id="ArrayList简介"><a href="#ArrayList简介" class="headerlink" title="ArrayList简介"></a>ArrayList简介</h2><p>ArrayList底层是一个数组，它的容量可以动态增长。</p><h2 id="ArrayList类结构"><a href="#ArrayList类结构" class="headerlink" title="ArrayList类结构"></a>ArrayList类结构</h2><p>可以从上图看出，ArrayList继承AbstractList抽象类，实现了List，Cloneable，Serializable，RandomAccess接口。</p><h2 id="ArrayList特点"><a href="#ArrayList特点" class="headerlink" title="ArrayList特点"></a>ArrayList特点</h2><ol><li>ArrayList非线程安全，在多线程中保证线程安全的解决方法：使用<code>CopyOnWriteArrayList</code>，<code>Vector</code>，<code>List list = Collections.synchronizedList(new ArrayList());</code>。</li><li>ArrayList允许插入null。</li><li>ArrayList中的数据存储是有序的。</li><li>ArrayList中的数据可以重复。</li></ol><h2 id="ArrayList源码"><a href="#ArrayList源码" class="headerlink" title="ArrayList源码"></a>ArrayList源码</h2><h3 id="ArrayList常量属性"><a href="#ArrayList常量属性" class="headerlink" title="ArrayList常量属性"></a>ArrayList常量属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化容量为10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList容量指定为0时，返回该空数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认返回的空数组，用户调用无参构造函数，刚创建一个ArrayList时，内部大小为0，返回的是该空数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList数组的最大值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure><h3 id="ArrayList成员变量"><a href="#ArrayList成员变量" class="headerlink" title="ArrayList成员变量"></a>ArrayList成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList元素保存的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><h3 id="ArrayList内部类"><a href="#ArrayList内部类" class="headerlink" title="ArrayList内部类"></a>ArrayList内部类</h3><h4 id="ArrayListSpliterator"><a href="#ArrayListSpliterator" class="headerlink" title="ArrayListSpliterator"></a>ArrayListSpliterator</h4><p>TODO</p><h3 id="ArrayList构造函数"><a href="#ArrayList构造函数" class="headerlink" title="ArrayList构造函数"></a>ArrayList构造函数</h3><p>ArrayList一共有三个构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定一个初始容量的构造函数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 指定了初始容量为0，数组就是EMPTY_ELEMENTDATA</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造函数，构造一个初始容量为默认值10的ArrayList。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过Collection创建ArrayList。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将参数c转为数组</span></span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="comment">// 判断数组是否为空，并且设置ArrayList的大小</span></span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="comment">// 判断数组的类型是否是Object</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="comment">// 空的数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ArrayList提供的API"><a href="#ArrayList提供的API" class="headerlink" title="ArrayList提供的API"></a>ArrayList提供的API</h3><table><thead><tr><th>方法名</th><th>方法解释</th></tr></thead><tbody><tr><td>add(E e)</td><td></td></tr><tr><td>add(int index, E element)</td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td></tr></tbody></table><h3 id="ArrayList重要方法"><a href="#ArrayList重要方法" class="headerlink" title="ArrayList重要方法"></a>ArrayList重要方法</h3><h4 id="arraycopy-Object-src-int-srcPos-Object-dest-int-destPos-int-length"><a href="#arraycopy-Object-src-int-srcPos-Object-dest-int-destPos-int-length" class="headerlink" title="arraycopy(Object src,  int  srcPos,  Object dest, int destPos,  int length)"></a>arraycopy(Object src,  int  srcPos,  Object dest, int destPos,  int length)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        Object dest, <span class="keyword">int</span> destPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure><p>该方法是native修饰的，由C/C++来编写的。</p><p>参数解释：</p><table><thead><tr><th>参数名</th><th>参数解释</th></tr></thead><tbody><tr><td>src</td><td>源数组，即被复制的数组</td></tr><tr><td>srcPos</td><td>源数组被复制的起始位置</td></tr><tr><td>dest</td><td>目标数组，即源数组的元素会被复制到该数组</td></tr><tr><td>destPos</td><td>元素放置在目标数组的起始位置</td></tr><tr><td>length</td><td>复制的长度</td></tr></tbody></table><h4 id="add-E-e"><a href="#add-E-e" class="headerlink" title="add(E e)"></a>add(E e)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试容量加1，计算需要的最小容量</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 向数组中添加元素，大小加1</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="comment">// 返回成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>ensureCapacityInternal(int minCapacity)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>calculateCapacity(Object[] elementData, int minCapacity)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否为空数组</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="comment">// 获取最小的容量</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ensureExplicitCapacity(int minCapacity)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 操作次数加1</span></span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="comment">// 需要的最小容量比数组的长度大，就调用grow()进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>grow(int minCapacity)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="comment">// 获取原数组长度</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 新的大小为原数组的1.5倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 如果新的大小还是小于需要的容量大小，将需要的容量大小设置为新的大小</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">// 设置最大值</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    <span class="comment">// 扩容之后进行复制</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>hugeCapacity(int minCapacity)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">    MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="add-int-index-E-element"><a href="#add-int-index-E-element" class="headerlink" title="add(int index, E element)"></a>add(int index, E element)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断下标是否越界</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试容量加1，计算需要的最小容量</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 将下标之后的数据都往右移动一位</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="comment">// 大小加1</span></span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>rangeCheckForAdd(int index)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断下标是否越界</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="addAll-Collection-lt-extends-E-gt-c"><a href="#addAll-Collection-lt-extends-E-gt-c" class="headerlink" title="addAll(Collection&lt;? extends E&gt; c)"></a>addAll(Collection&lt;? extends E&gt; c)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将集合转换为数组</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="comment">// 集合转换为的数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="comment">// 尝试容量加1，计算需要的最小容量</span></span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">    <span class="comment">// 将转换为的数组添加到ArrayList数组的后面</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">    <span class="comment">// 增加数组大小</span></span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="addAll-int-index-Collection-lt-extends-E-gt-c"><a href="#addAll-int-index-Collection-lt-extends-E-gt-c" class="headerlink" title="addAll(int index, Collection&lt;? extends E&gt; c)"></a>addAll(int index, Collection&lt;? extends E&gt; c)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断下标是否越界</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将集合转换为数组</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="comment">// 集合转换为的数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="comment">// 尝试容量加1，计算需要的最小容量</span></span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算需要向右移动的元素数量</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index;</span><br><span class="line">    <span class="comment">// 如果需要移动的数量大于0，进行相关的移动</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                         numMoved);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将集合转换的数组添加到ArrayList中</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">    <span class="comment">// 增加ArrayList大小</span></span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="contains-Object-o"><a href="#contains-Object-o" class="headerlink" title="contains(Object o)"></a>contains(Object o)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据匹配方法返回的元素下标判断是否存在该对象</span></span><br><span class="line">    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>indexOf(Object o)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断的对象为null，遍历数组，返回匹配到的下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 判断的对象不为null，遍历数组，返回匹配到的下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有匹配到返回-1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="get-int-index"><a href="#get-int-index" class="headerlink" title="get(int index)"></a>get(int index)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断下标是否越界</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回查找的元素</span></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>elementData(int index)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回数组中的元素</span></span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="remove-int-index"><a href="#remove-int-index" class="headerlink" title="remove(int index)"></a>remove(int index)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断下标是否越界</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 操作次数加1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取下标匹配的数组元素</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算需要移动的元素数量</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 如果需要向左移动的数量大于0，就进行相关的移动</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">// 将数组最后一位元素置为null，并且大小减1</span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回原来的元素</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果需要移除的元素为null</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历数组进行匹配，并删除，返回true</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历数组进行匹配，并删除，返回true</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>fastRemove(int index)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 操作加1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 计算需要向左移动的元素数量</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 如果要移动的数量大于0，进行相关的复制</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">// 将数组最后一位元素置为null，并且大小减1</span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="removeAll-Collection-lt-gt-c"><a href="#removeAll-Collection-lt-gt-c" class="headerlink" title="removeAll(Collection&lt;?&gt; c)"></a>removeAll(Collection&lt;?&gt; c)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否为null，如果为null，抛出空指针异常</span></span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="comment">// 批量删除</span></span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>batchRemove(Collection&lt;?&gt; c, boolean complement)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取ArrayList数组</span></span><br><span class="line">    <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line">            <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line">                elementData[w++] = elementData[r];</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// Preserve behavioral compatibility with AbstractCollection,</span></span><br><span class="line">        <span class="comment">// even if c.contains() throws.</span></span><br><span class="line">        <span class="keyword">if</span> (r != size) &#123;</span><br><span class="line">            System.arraycopy(elementData, r,</span><br><span class="line">                             elementData, w,</span><br><span class="line">                             size - r);</span><br><span class="line">            w += size - r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (w != size) &#123;</span><br><span class="line">            <span class="comment">// clear to let GC do its work</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)</span><br><span class="line">                elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">            modCount += size - w;</span><br><span class="line">            size = w;</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="removeIf-Predicate-lt-super-E-gt-filter"><a href="#removeIf-Predicate-lt-super-E-gt-filter" class="headerlink" title="removeIf(Predicate&lt;? super E&gt; filter)"></a>removeIf(Predicate&lt;? super E&gt; filter)</h4><p>TODO</p><h4 id="replaceAll-UnaryOperator-operator"><a href="#replaceAll-UnaryOperator-operator" class="headerlink" title="replaceAll(UnaryOperator operator)"></a>replaceAll(UnaryOperator<e> operator)</e></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断操作方法是否为null</span></span><br><span class="line">    Objects.requireNonNull(operator);</span><br><span class="line">    <span class="comment">// 设置预期操作次数</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="comment">// 设置大小</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">    <span class="comment">// 遍历ArrayList，对每一个元素进行操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">        elementData[i] = operator.apply((E) elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在调用该方法的时候，ArrayList的操作次数改变了，就抛出并发异常</span></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 操作次数加1</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set-int-index-E-element"><a href="#set-int-index-E-element" class="headerlink" title="set(int index, E element)"></a>set(int index, E element)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断下标是否越界</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取下标对应的元素</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    <span class="comment">// 将新的元素设置到下标位置</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="comment">// 返回旧的值</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sort-Comparator-lt-super-E-gt-c"><a href="#sort-Comparator-lt-super-E-gt-c" class="headerlink" title="sort(Comparator&lt;? super E&gt; c)"></a>sort(Comparator&lt;? super E&gt; c)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置预期操作次数</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="comment">// 调用Arrays的排序</span></span><br><span class="line">    Arrays.sort((E[]) elementData, <span class="number">0</span>, size, c);</span><br><span class="line">    <span class="comment">// 在调用该方法的时候，ArrayList的操作次数改变了，就抛出并发异常</span></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 操作次数加1</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="trimToSize"><a href="#trimToSize" class="headerlink" title="trimToSize()"></a>trimToSize()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 操作次数加1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 判断ArrayList大小是否小于数组的长度，是的话就去除数组中空的值</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">        elementData = (size == <span class="number">0</span>)</span><br><span class="line">            ? EMPTY_ELEMENTDATA</span><br><span class="line">            : Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这篇文章，我们对ArrayList进行了更深入的了解，这有利于我们之后使用ArrayList。可以避免遇到一些坑。</p><p>ps：有一些TODO的内容，后续有空了再进行添加。</p><p>欢迎关注博主其他的文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;ArrayList是我们最常使用的数据类型之一，也是面试中最容易问到的集合之一。本篇文章主要通过分析ArrayList的源码，更深入的了解ArrayList，ArrayList在JDK1.8中添加了一些新的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://yoga0521.github.io/categories/Java/"/>
    
      <category term="Collection" scheme="https://yoga0521.github.io/categories/Java/Collection/"/>
    
    
      <category term="Java" scheme="https://yoga0521.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
